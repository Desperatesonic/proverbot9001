Parameter OP : Set.
-----
Parameter eval_op : OP -> nat -> nat -> nat.
-----
Definition Pat := nat.
-----
Inductive MLexp : Set :=\n  | Bool : bool -> MLexp\n  | Num : nat -> MLexp\n  | op : OP -> MLexp\n  | id : Pat -> MLexp\n  | appl : MLexp -> MLexp -> MLexp\n  | mlpair : MLexp -> MLexp -> MLexp\n  | lambda : Pat -> MLexp -> MLexp\n  | let' : Pat -> MLexp -> MLexp -> MLexp\n  | letrec : Pat -> Pat -> MLexp -> MLexp -> MLexp\n  | ite : MLexp -> MLexp -> MLexp -> MLexp.
-----
Inductive MLval : Set :=\n  | num : nat -> MLval\n  | boolean : bool -> MLval\n  | valpair : MLval -> MLval -> MLval\n  | OP_clos : OP -> MLval\n  | Clos : Pat -> MLexp -> MLenv -> MLval\n  | Clos_rec : Pat -> MLexp -> Pat -> MLenv -> MLval\nwith MLenv : Set :=\n  | Enil : MLenv\n  | Econs : Pat -> MLval -> MLenv -> MLenv.
-----
Inductive VAL_OF : MLenv -> Pat -> MLval -> Prop :=\n  | ELT : forall (e : MLenv) (I : Pat) (a : MLval), VAL_OF (Econs I a e) I a\n  | CHG :\n      forall (e : MLenv) (X I : Pat) (a b : MLval),\n      VAL_OF e I a -> X <> I :>Pat -> VAL_OF (Econs X b e) I a.
-----
Lemma determ_VAL_OF :\n forall (e : MLenv) (i : Pat) (V V' : MLval),\n VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.

*****

*****
forall (e : MLenv) (i : Pat) (V V' : MLval) (_ : VAL_OF e i V') (_ : VAL_OF e i V), eq V V'
+++++
simple induction 1.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.

*****
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
forall (e : MLenv) (I : Pat) (a : MLval) (_ : VAL_OF (Econs I a e) I V), eq V a
+++++
intros.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.

*****
H0 : VAL_OF (Econs I a e0) I V
a : MLval
I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq V a
+++++
inversion_clear H0.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.

*****
a : MLval
I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq V V
+++++
auto.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.

*****
H2 : not (eq I I)
H1 : VAL_OF e0 I V
a : MLval
I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq V a
+++++
auto.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.
auto.

*****
H2 : not (eq I I)
H1 : VAL_OF e0 I V
a : MLval
I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq V a
+++++
elim H2.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.
auto.
elim H2.

*****
H2 : not (eq I I)
H1 : VAL_OF e0 I V
a : MLval
I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq I I
+++++
auto.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.

*****
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
forall (e : MLenv) (X I : Pat) (a b : MLval) (_ : VAL_OF e I a) (_ : forall _ : VAL_OF e I V, eq V a) (_ : not (eq X I)) (_ : VAL_OF (Econs X b e) I V), eq V a
+++++
intros.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.

*****
H3 : VAL_OF (Econs X b e0) I V
H2 : not (eq X I)
H1 : forall _ : VAL_OF e0 I V, eq V a
H0 : VAL_OF e0 I a
a,b : MLval
X,I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq V a
+++++
apply H1.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
apply H1.

*****
H3 : VAL_OF (Econs X b e0) I V
H2 : not (eq X I)
H1 : forall _ : VAL_OF e0 I V, eq V a
H0 : VAL_OF e0 I a
a,b : MLval
X,I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
VAL_OF e0 I V
+++++
inversion H3.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
apply H1.
inversion H3.

*****
H8 : eq b V
H4 : eq X I
H7 : eq e1 e0
H6 : eq a0 b
H5 : eq I0 X
a0 : MLval
I0 : Pat
e1 : MLenv
H3 : VAL_OF (Econs X b e0) I V
H2 : not (eq X I)
H1 : forall _ : VAL_OF e0 I V, eq V a
H0 : VAL_OF e0 I a
a,b : MLval
X,I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
VAL_OF e0 I V
+++++
elim H2.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
apply H1.
inversion H3.
elim H2.

*****
H8 : eq b V
H4 : eq X I
H7 : eq e1 e0
H6 : eq a0 b
H5 : eq I0 X
a0 : MLval
I0 : Pat
e1 : MLenv
H3 : VAL_OF (Econs X b e0) I V
H2 : not (eq X I)
H1 : forall _ : VAL_OF e0 I V, eq V a
H0 : VAL_OF e0 I a
a,b : MLval
X,I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
eq X I
+++++
exact H4.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.
intros.
apply H1.
inversion H3.

*****
H8 : eq a0 V
H6 : eq I0 I
H7 : eq e1 e0
H5 : eq b0 b
H4 : eq X0 X
H10 : not (eq X I)
H9 : VAL_OF e0 I V
a0,b0 : MLval
X0,I0 : Pat
e1 : MLenv
H3 : VAL_OF (Econs X b e0) I V
H2 : not (eq X I)
H1 : forall _ : VAL_OF e0 I V, eq V a
H0 : VAL_OF e0 I a
a,b : MLval
X,I : Pat
e0 : MLenv
H : VAL_OF e i V'
V,V' : MLval
i : Pat
e : MLenv
*****
VAL_OF e0 I V
+++++
auto.
-----
Lemma determ_VAL_OF : forall (e : MLenv) (i : Pat) (V V' : MLval), VAL_OF e i V' -> VAL_OF e i V -> V = V' :>MLval.
simple induction 1.

*****

*****

+++++
Qed.
-----
Inductive ML_DS : MLenv -> MLexp -> MLval -> Prop :=\n  | BOOL : forall (b : bool) (e : MLenv), ML_DS e (Bool b) (boolean b)\n  | NUM : forall (n : nat) (e : MLenv), ML_DS e (Num n) (num n)\n  | Sem_OP : forall (c : OP) (e : MLenv), ML_DS e (op c) (OP_clos c)\n  | LAMBDA :\n      forall (e : MLenv) (P : Pat) (E : MLexp),\n      ML_DS e (lambda P E) (Clos P E e)\n  | IDENT :\n      forall (e : MLenv) (v : MLval) (I : Pat),\n      VAL_OF e I v -> ML_DS e (id I) v\n  | ITE1 :\n      forall (e : MLenv) (E1 E2 E3 : MLexp) (v : MLval),\n      ML_DS e E1 (boolean true) -> ML_DS e E2 v -> ML_DS e (ite E1 E2 E3) v\n  | ITE2 :\n      forall (e : MLenv) (E1 E2 E3 : MLexp) (v : MLval),\n      ML_DS e E1 (boolean false) -> ML_DS e E3 v -> ML_DS e (ite E1 E2 E3) v\n  | MLPAIR :\n      forall (e : MLenv) (E1 E2 : MLexp) (u v : MLval),\n      ML_DS e E1 u -> ML_DS e E2 v -> ML_DS e (mlpair E1 E2) (valpair u v)\n  | APPml1 :\n      forall (e e1 : MLenv) (P : Pat) (E E1 E2 : MLexp) (u v : MLval),\n      ML_DS e E1 (Clos P E e1) ->\n      ML_DS e E2 u -> ML_DS (Econs P u e1) E v -> ML_DS e (appl E1 E2) v\n  | APPml2 :\n      forall (e e1 : MLenv) (x P : Pat) (E E1 E2 : MLexp) (u v : MLval),\n      ML_DS e E1 (Clos_rec x E P e1) ->\n      ML_DS e E2 u ->\n      ML_DS (Econs x u (Econs P (Clos_rec x E P e1) e1)) E v ->\n      ML_DS e (appl E1 E2) v\n  | APPml_op :\n      forall (e : MLenv) (E1 E2 : MLexp) (n m : nat) (c : OP),\n      ML_DS e E1 (OP_clos c) ->\n      ML_DS e E2 (valpair (num n) (num m)) ->\n      ML_DS e (appl E1 E2) (num (eval_op c n m))\n  | Sem_let :\n      forall (e : MLenv) (P : Pat) (E1 E2 : MLexp) (u v : MLval),\n      ML_DS e E2 u -> ML_DS (Econs P u e) E1 v -> ML_DS e (let' P E2 E1) v\n  | Sem_letrec :\n      forall (e : MLenv) (P x : Pat) (E E2 : MLexp) (u : MLval),\n      ML_DS (Econs P (Clos_rec x E P e) e) E2 u ->\n      ML_DS e (letrec P x E E2) u.
-----
Lemma ML_DS_determ :\n forall (e : MLenv) (E : MLexp) (V : MLval),\n ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.

*****

*****
forall (e : MLenv) (E : MLexp) (V : MLval) (_ : ML_DS e E V) (V' : MLval) (_ : ML_DS e E V'), eq V V'
+++++
simple induction 1.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (b : bool) (e : MLenv) (V' : MLval) (_ : ML_DS e (Bool b) V'), eq (boolean b) V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H0 : ML_DS e0 (Bool b) V'
V' : MLval
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (boolean b) V'
+++++
inversion_clear H0.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.

*****
V' : MLval
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (boolean b) (boolean b)
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (n : nat) (e : MLenv) (V' : MLval) (_ : ML_DS e (Num n) V'), eq (num n) V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H0 : ML_DS e0 (Num n) V'
V' : MLval
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num n) V'
+++++
inversion_clear H0.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.

*****
V' : MLval
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num n) (num n)
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (c : OP) (e : MLenv) (V' : MLval) (_ : ML_DS e (op c) V'), eq (OP_clos c) V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H0 : ML_DS e0 (op c) V'
V' : MLval
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (OP_clos c) V'
+++++
inversion_clear H0.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.

*****
V' : MLval
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (OP_clos c) (OP_clos c)
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (P : Pat) (E : MLexp) (V' : MLval) (_ : ML_DS e (lambda P E) V'), eq (Clos P E e) V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H0 : ML_DS e0 (lambda P E0) V'
V' : MLval
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos P E0 e0) V'
+++++
inversion_clear H0.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H0.

*****
V' : MLval
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos P E0 e0) (Clos P E0 e0)
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (v : MLval) (I : Pat) (_ : VAL_OF e I v) (V' : MLval) (_ : ML_DS e (id I) V'), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H1 : ML_DS e0 (id I) V'
V' : MLval
H0 : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
inversion_clear H1.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H1.

*****
H2 : VAL_OF e0 I V'
V' : MLval
H0 : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H1.
auto.

*****
H2 : VAL_OF e0 I V'
V' : MLval
H0 : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
apply (determ_VAL_OF e0 I).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H1.
auto.
apply (determ_VAL_OF e0 I).

*****
H2 : VAL_OF e0 I V'
V' : MLval
H0 : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
VAL_OF e0 I V'
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H1.
auto.
apply (determ_VAL_OF e0 I).

*****
H2 : VAL_OF e0 I V'
V' : MLval
H0 : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
VAL_OF e0 I v
+++++
auto.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (E1 E2 E3 : MLexp) (v : MLval) (_ : ML_DS e E1 (boolean true)) (_ : forall (V' : MLval) (_ : ML_DS e E1 V'), eq (boolean true) V') (_ : ML_DS e E2 v) (_ : forall (V' : MLval) (_ : ML_DS e E2 V'), eq v V') (V' : MLval) (_ : ML_DS e (ite E1 E2 E3) V'), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H4 : ML_DS e0 (ite E1 E2 E3) V'
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean true) V'
H0 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
inversion_clear H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS e0 E2 V'
H5 : ML_DS e0 E1 (boolean true)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean true) V'
H0 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
exact (H3 V' H6).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS e0 E3 V'
H5 : ML_DS e0 E1 (boolean false)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean true) V'
H0 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (boolean true = boolean false).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (boolean true = boolean false).

*****
H6 : ML_DS e0 E3 V'
H5 : ML_DS e0 E1 (boolean false)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean true) V'
H0 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (boolean true) (boolean false), eq v V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (boolean true = boolean false).
intro HH.

*****
HH : eq (boolean true) (boolean false)
H6 : ML_DS e0 E3 V'
H5 : ML_DS e0 E1 (boolean false)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean true) V'
H0 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (boolean true = boolean false).

*****
H6 : ML_DS e0 E3 V'
H5 : ML_DS e0 E1 (boolean false)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean true) V'
H0 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (boolean true) (boolean false)
+++++
exact (H1 (boolean false) H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (E1 E2 E3 : MLexp) (v : MLval) (_ : ML_DS e E1 (boolean false)) (_ : forall (V' : MLval) (_ : ML_DS e E1 V'), eq (boolean false) V') (_ : ML_DS e E3 v) (_ : forall (V' : MLval) (_ : ML_DS e E3 V'), eq v V') (V' : MLval) (_ : ML_DS e (ite E1 E2 E3) V'), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H4 : ML_DS e0 (ite E1 E2 E3) V'
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E3 V'), eq v V'
H2 : ML_DS e0 E3 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean false) V'
H0 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
inversion_clear H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS e0 E2 V'
H5 : ML_DS e0 E1 (boolean true)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E3 V'), eq v V'
H2 : ML_DS e0 E3 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean false) V'
H0 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (boolean false = boolean true).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (boolean false = boolean true).

*****
H6 : ML_DS e0 E2 V'
H5 : ML_DS e0 E1 (boolean true)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E3 V'), eq v V'
H2 : ML_DS e0 E3 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean false) V'
H0 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (boolean false) (boolean true), eq v V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (boolean false = boolean true).
intro HH.

*****
HH : eq (boolean false) (boolean true)
H6 : ML_DS e0 E2 V'
H5 : ML_DS e0 E1 (boolean true)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E3 V'), eq v V'
H2 : ML_DS e0 E3 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean false) V'
H0 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (boolean false = boolean true).

*****
H6 : ML_DS e0 E2 V'
H5 : ML_DS e0 E1 (boolean true)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E3 V'), eq v V'
H2 : ML_DS e0 E3 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean false) V'
H0 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (boolean false) (boolean true)
+++++
exact (H1 (boolean true) H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS e0 E3 V'
H5 : ML_DS e0 E1 (boolean false)
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E3 V'), eq v V'
H2 : ML_DS e0 E3 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (boolean false) V'
H0 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
exact (H3 V' H6).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E1 u) (_ : forall (V' : MLval) (_ : ML_DS e E1 V'), eq u V') (_ : ML_DS e E2 v) (_ : forall (V' : MLval) (_ : ML_DS e E2 V'), eq v V') (V' : MLval) (_ : ML_DS e (mlpair E1 E2) V'), eq (valpair u v) V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H4 : ML_DS e0 (mlpair E1 E2) V'
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq u V'
H0 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (valpair u v) V'
+++++
inversion_clear H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS e0 E2 v0
H5 : ML_DS e0 E1 u0
V',u0,v0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq u V'
H0 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (valpair u v) (valpair u0 v0)
+++++
elim (H1 u0 H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
elim (H1 u0 H5).

*****
H6 : ML_DS e0 E2 v0
H5 : ML_DS e0 E1 u0
V',u0,v0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq u V'
H0 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (valpair u v) (valpair u v0)
+++++
elim (H3 v0 H6).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
elim (H1 u0 H5).
elim (H3 v0 H6).

*****
H6 : ML_DS e0 E2 v0
H5 : ML_DS e0 E1 u0
V',u0,v0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq v V'
H2 : ML_DS e0 E2 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq u V'
H0 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (valpair u v) (valpair u v)
+++++
trivial.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e e1 : MLenv) (P : Pat) (E E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E1 (Clos P E e1)) (_ : forall (V' : MLval) (_ : ML_DS e E1 V'), eq (Clos P E e1) V') (_ : ML_DS e E2 u) (_ : forall (V' : MLval) (_ : ML_DS e E2 V'), eq u V') (_ : ML_DS (Econs P u e1) E v) (_ : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E V'), eq v V') (V' : MLval) (_ : ML_DS e (appl E1 E2) V'), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H6 : ML_DS e0 (appl E1 E2) V'
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
inversion_clear H6.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.

*****
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (Clos P E0 e1 = Clos P0 E3 e3).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).

*****
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (Clos P E0 e1) (Clos P0 E3 e3), eq v V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.

*****
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
injection HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.

*****
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (_ : eq e1 e3) (_ : eq E0 E3) (_ : eq P P0), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.

*****
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (u = u0).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).

*****
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq u u0, eq v V'
+++++
intro.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).
intro.

*****
H12 : eq u u0
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
apply H5.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).
intro.
apply H5.

*****
H12 : eq u u0
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P u e1) E0 V'
+++++
try rewrite H6.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).
intro.
apply H5.
try rewrite H6.

*****
H12 : eq u u0
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P u e3) E0 V'
+++++
try rewrite H10.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).
intro.
apply H5.
try rewrite H6.
try rewrite H10.

*****
H12 : eq u u0
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P u e3) E3 V'
+++++
try rewrite H11.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).
intro.
apply H5.
try rewrite H6.
try rewrite H10.
try rewrite H11.

*****
H12 : eq u u0
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P0 u e3) E3 V'
+++++
try rewrite H12.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).
intro.
apply H5.
try rewrite H6.
try rewrite H10.
try rewrite H11.
try rewrite H12.

*****
H12 : eq u u0
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P0 u0 e3) E3 V'
+++++
exact H9.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH.
injection HH.
intros.
cut (u = u0).

*****
H11 : eq P P0
H10 : eq E0 E3
H6 : eq e1 e3
HH : eq (Clos P E0 e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq u u0
+++++
exact (H3 u0 H8).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos P0 E3 e3).

*****
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos P E0 e1) (Clos P0 E3 e3)
+++++
exact (H1 (Clos P0 E3 e3) H7).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.

*****
H9 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).

*****
H9 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (Clos P E0 e1) (Clos_rec x E3 P0 e3), eq v V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro HH.

*****
HH : eq (Clos P E0 e1) (Clos_rec x E3 P0 e3)
H9 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).

*****
H9 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos P E0 e1) (Clos_rec x E3 P0 e3)
+++++
exact (H1 (Clos_rec x E3 P0 e3) H7).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.

*****
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v (num (eval_op c n m))
+++++
cut (Clos P E0 e1 = OP_clos c).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = OP_clos c).

*****
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (Clos P E0 e1) (OP_clos c), eq v (num (eval_op c n m))
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = OP_clos c).
intro HH.

*****
HH : eq (Clos P E0 e1) (OP_clos c)
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v (num (eval_op c n m))
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos P E0 e1 = OP_clos c).

*****
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval) (_ : ML_DS (Econs P u e1) E0 V'), eq v V'
H4 : ML_DS (Econs P u e1) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos P E0 e1) V'
H0 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos P E0 e1) (OP_clos c)
+++++
exact (H1 (OP_clos c) H7).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e e1 : MLenv) (x P : Pat) (E E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E1 (Clos_rec x E P e1)) (_ : forall (V' : MLval) (_ : ML_DS e E1 V'), eq (Clos_rec x E P e1) V') (_ : ML_DS e E2 u) (_ : forall (V' : MLval) (_ : ML_DS e E2 V'), eq u V') (_ : ML_DS (Econs x u (Econs P (Clos_rec x E P e1) e1)) E v) (_ : forall (V' : MLval) (_ : ML_DS (Econs x u (Econs P (Clos_rec x E P e1) e1)) E V'), eq v V') (V' : MLval) (_ : ML_DS e (appl E1 E2) V'), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H6 : ML_DS e0 (appl E1 E2) V'
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
inversion_clear H6.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.

*****
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).

*****
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (Clos_rec x E0 P e1) (Clos P0 E3 e3), eq v V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH.

*****
HH : eq (Clos_rec x E0 P e1) (Clos P0 E3 e3)
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).

*****
H9 : ML_DS (Econs P0 u0 e3) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos_rec x E0 P e1) (Clos P0 E3 e3)
+++++
exact (H1 (Clos P0 E3 e3) H7).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.

*****
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).

*****
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3), eq v V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.

*****
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
injection HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.

*****
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (_ : eq e1 e3) (_ : eq P P0) (_ : eq E0 E3) (_ : eq x x0), eq v V'
+++++
cut (u = u0).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).

*****
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (_ : eq u u0) (_ : eq e1 e3) (_ : eq P P0) (_ : eq E0 E3) (_ : eq x x0), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
apply H5.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.
apply H5.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'
+++++
try rewrite H6.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.
apply H5.
try rewrite H6.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs x u0 (Econs P (Clos_rec x E0 P e1) e1)) E0 V'
+++++
try rewrite H10.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.
apply H5.
try rewrite H6.
try rewrite H10.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs x u0 (Econs P (Clos_rec x E0 P e3) e3)) E0 V'
+++++
try rewrite H11.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.
apply H5.
try rewrite H6.
try rewrite H10.
try rewrite H11.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs x u0 (Econs P0 (Clos_rec x E0 P0 e3) e3)) E0 V'
+++++
try rewrite H12.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.
apply H5.
try rewrite H6.
try rewrite H10.
try rewrite H11.
try rewrite H12.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V'
+++++
try rewrite H13.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).
intros.
apply H5.
try rewrite H6.
try rewrite H10.
try rewrite H11.
try rewrite H12.
try rewrite H13.

*****
H13 : eq x x0
H12 : eq E0 E3
H11 : eq P P0
H10 : eq e1 e3
H6 : eq u u0
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
+++++
exact H9.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH.
injection HH.
cut (u = u0).

*****
HH : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq u u0
+++++
exact (H3 u0 H8).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).

*****
H9 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V'
H8 : ML_DS e0 E2 u0
H7 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
+++++
exact (H1 (Clos_rec x0 E3 P0 e3) H7).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.

*****
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v (num (eval_op c n m))
+++++
cut (Clos_rec x E0 P e1 = OP_clos c).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = OP_clos c).

*****
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (Clos_rec x E0 P e1) (OP_clos c), eq v (num (eval_op c n m))
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = OP_clos c).
intro HH.

*****
HH : eq (Clos_rec x E0 P e1) (OP_clos c)
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v (num (eval_op c n m))
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H6.
cut (Clos_rec x E0 P e1 = OP_clos c).

*****
H8 : ML_DS e0 E2 (valpair (num n) (num m))
H7 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V' : MLval
H5 : forall (V' : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V'),\neq v V'
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H2 : ML_DS e0 E2 u
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (Clos_rec x E0 P e1) V'
H0 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (Clos_rec x E0 P e1) (OP_clos c)
+++++
exact (H1 (OP_clos c) H7).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (E1 E2 : MLexp) (n m : nat) (c : OP) (_ : ML_DS e E1 (OP_clos c)) (_ : forall (V' : MLval) (_ : ML_DS e E1 V'), eq (OP_clos c) V') (_ : ML_DS e E2 (valpair (num n) (num m))) (_ : forall (V' : MLval) (_ : ML_DS e E2 V'), eq (valpair (num n) (num m)) V') (V' : MLval) (_ : ML_DS e (appl E1 E2) V'), eq (num (eval_op c n m)) V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H4 : ML_DS e0 (appl E1 E2) V'
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) V'
+++++
inversion_clear H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H7 : ML_DS (Econs P u e2) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) V'
+++++
cut (OP_clos c = Clos P E0 e2).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (OP_clos c = Clos P E0 e2).

*****
H7 : ML_DS (Econs P u e2) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (OP_clos c) (Clos P E0 e2), eq (num (eval_op c n m)) V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (OP_clos c = Clos P E0 e2).
intro HH.

*****
HH : eq (OP_clos c) (Clos P E0 e2)
H7 : ML_DS (Econs P u e2) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) V'
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (OP_clos c = Clos P E0 e2).

*****
H7 : ML_DS (Econs P u e2) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (OP_clos c) (Clos P E0 e2)
+++++
exact (H1 (Clos P E0 e2) H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H7 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) V'
+++++
cut (OP_clos c = Clos_rec x E0 P e2).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (OP_clos c = Clos_rec x E0 P e2).

*****
H7 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (OP_clos c) (Clos_rec x E0 P e2), eq (num (eval_op c n m)) V'
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (OP_clos c = Clos_rec x E0 P e2).
intro HH.

*****
HH : eq (OP_clos c) (Clos_rec x E0 P e2)
H7 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) V'
+++++
discriminate HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (OP_clos c = Clos_rec x E0 P e2).

*****
H7 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V'
H6 : ML_DS e0 E2 u
H5 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (OP_clos c) (Clos_rec x E0 P e2)
+++++
exact (H1 (Clos_rec x E0 P e2) H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).

*****
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (valpair (num n) (num m)) (valpair (num n0) (num m0)), eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
intro HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.

*****
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
injection HH.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.

*****
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (_ : eq m m0) (_ : eq n n0), eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.

*****
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
cut (OP_clos c = OP_clos c0).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).

*****
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq (OP_clos c) (OP_clos c0), eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
intro HH1.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).
intro HH1.

*****
HH1 : eq (OP_clos c) (OP_clos c0)
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
injection HH1.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).
intro HH1.
injection HH1.

*****
HH1 : eq (OP_clos c) (OP_clos c0)
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq c c0, eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
intro.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).
intro HH1.
injection HH1.
intro.

*****
H8 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m)) (num (eval_op c0 n0 m0))
+++++
try rewrite H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).
intro HH1.
injection HH1.
intro.
try rewrite H4.

*****
H8 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n m0)) (num (eval_op c0 n0 m0))
+++++
try rewrite H7.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).
intro HH1.
injection HH1.
intro.
try rewrite H4.
try rewrite H7.

*****
H8 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c n0 m0)) (num (eval_op c0 n0 m0))
+++++
try rewrite H8.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).
intro HH1.
injection HH1.
intro.
try rewrite H4.
try rewrite H7.
try rewrite H8.

*****
H8 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (num (eval_op c0 n0 m0)) (num (eval_op c0 n0 m0))
+++++
trivial.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
intro HH.
injection HH.
intros.
cut (OP_clos c = OP_clos c0).

*****
H7 : eq n n0
H4 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (OP_clos c) (OP_clos c0)
+++++
exact (H1 (OP_clos c0) H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).

*****
H6 : ML_DS e0 E2 (valpair (num n0) (num m0))
H5 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS e0 E2 V'),\neq (valpair (num n) (num m)) V'
H2 : ML_DS e0 E2 (valpair (num n) (num m))
H1 : forall (V' : MLval) (_ : ML_DS e0 E1 V'), eq (OP_clos c) V'
H0 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
+++++
exact (H3 (valpair (num n0) (num m0)) H6).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (P : Pat) (E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E2 u) (_ : forall (V' : MLval) (_ : ML_DS e E2 V'), eq u V') (_ : ML_DS (Econs P u e) E1 v) (_ : forall (V' : MLval) (_ : ML_DS (Econs P u e) E1 V'), eq v V') (V' : MLval) (_ : ML_DS e (let' P E2 E1) V'), eq v V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H4 : ML_DS e0 (let' P E2 E1) V'
V' : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
inversion_clear H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.

*****
H6 : ML_DS (Econs P u0 e0) E1 V'
H5 : ML_DS e0 E2 u0
V',u0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
cut (u = u0).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (u = u0).

*****
H6 : ML_DS (Econs P u0 e0) E1 V'
H5 : ML_DS e0 E2 u0
V',u0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall _ : eq u u0, eq v V'
+++++
intro.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (u = u0).
intro.

*****
H4 : eq u u0
H6 : ML_DS (Econs P u0 e0) E1 V'
H5 : ML_DS e0 E2 u0
V',u0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq v V'
+++++
apply H3.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (u = u0).
intro.
apply H3.

*****
H4 : eq u u0
H6 : ML_DS (Econs P u0 e0) E1 V'
H5 : ML_DS e0 E2 u0
V',u0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P u e0) E1 V'
+++++
try rewrite H4.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (u = u0).
intro.
apply H3.
try rewrite H4.

*****
H4 : eq u u0
H6 : ML_DS (Econs P u0 e0) E1 V'
H5 : ML_DS e0 E2 u0
V',u0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P u0 e0) E1 V'
+++++
exact H6.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H4.
cut (u = u0).

*****
H6 : ML_DS (Econs P u0 e0) E1 V'
H5 : ML_DS e0 E2 u0
V',u0 : MLval
H3 : forall (V' : MLval) (_ : ML_DS (Econs P u e0) E1 V'), eq v V'
H2 : ML_DS (Econs P u e0) E1 v
H1 : forall (V' : MLval) (_ : ML_DS e0 E2 V'), eq u V'
H0 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq u u0
+++++
exact (H1 u0 H5).
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
forall (e : MLenv) (P x : Pat) (E E2 : MLexp) (u : MLval) (_ : ML_DS (Econs P (Clos_rec x E P e) e) E2 u) (_ : forall (V' : MLval) (_ : ML_DS (Econs P (Clos_rec x E P e) e) E2 V'), eq u V') (V' : MLval) (_ : ML_DS e (letrec P x E E2) V'), eq u V'
+++++
intros.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.

*****
H2 : ML_DS e0 (letrec P x E0 E2) V'
V' : MLval
H1 : forall (V' : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V'),\neq u V'
H0 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq u V'
+++++
inversion_clear H2.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H2.

*****
H3 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V'
V' : MLval
H1 : forall (V' : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V'),\neq u V'
H0 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
eq u V'
+++++
apply H1.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.
intros.
inversion_clear H2.
apply H1.

*****
H3 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V'
V' : MLval
H1 : forall (V' : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V'),\neq u V'
H0 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
E : MLexp
e : MLenv
*****
ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V'
+++++
exact H3.
-----
Lemma ML_DS_determ : forall (e : MLenv) (E : MLexp) (V : MLval), ML_DS e E V -> forall V' : MLval, ML_DS e E V' -> V = V' :>MLval.
simple induction 1.

*****

*****

+++++
Qed.
-----
Inductive Value : Set :=\n  | null : Value\n  | elem : bool -> Value\n  | int : nat -> Value\n  | def_op : OP -> Value.
-----
Inductive Commande : Set :=\n  | quote : Value -> Commande\n  | car : Commande\n  | cdr : Commande\n  | cons : Commande\n  | push : Commande\n  | swap : Commande\n  | branch : Commande -> Commande -> Commande\n  | cur : Commande -> Commande\n  | cur_rec : Commande -> Commande\n  | app : Commande\n  | o : Commande -> Commande -> Commande.
-----
Inductive CSem_val : Set :=\n  | val : Value -> CSem_val\n  | Cam_pair : CSem_val -> CSem_val -> CSem_val\n  | Cam_clos : Commande -> CSem_val -> CSem_val\n  | Cam_clos_rec : Commande -> CSem_val -> CSem_val\n  | Cam_nil : CSem_val.
-----
Inductive Etat : Set :=\n  | nil : Etat\n  | ETcons : CSem_val -> Etat -> Etat.
-----
Inductive CAM_DS : Etat -> Commande -> Etat -> Prop :=\n  | QUO :\n      forall (s : Etat) (a : CSem_val) (b : Value),\n      CAM_DS (ETcons a s) (quote b) (ETcons (val b) s)\n  | CAR :\n      forall (s : Etat) (a b : CSem_val),\n      CAM_DS (ETcons (Cam_pair a b) s) car (ETcons a s)\n  | CDR :\n      forall (s : Etat) (a b : CSem_val),\n      CAM_DS (ETcons (Cam_pair a b) s) cdr (ETcons b s)\n  | CONS :\n      forall (s : Etat) (a b : CSem_val),\n      CAM_DS (ETcons b (ETcons a s)) cons (ETcons (Cam_pair a b) s)\n  | PUSH :\n      forall (s : Etat) (a : CSem_val),\n      CAM_DS (ETcons a s) push (ETcons a (ETcons a s))\n  | SWAP :\n      forall (s : Etat) (a b : CSem_val),\n      CAM_DS (ETcons a (ETcons b s)) swap (ETcons b (ETcons a s))\n  | BRANCHT :\n      forall (s s1 : Etat) (c1 c2 : Commande),\n      CAM_DS s c1 s1 -> CAM_DS (ETcons (val (elem true)) s) (branch c1 c2) s1\n  | BRANCHF :\n      forall (s s2 : Etat) (c1 c2 : Commande),\n      CAM_DS s c2 s2 ->\n      CAM_DS (ETcons (val (elem false)) s) (branch c1 c2) s2\n  | CUR :\n      forall (s : Etat) (a : CSem_val) (c : Commande),\n      CAM_DS (ETcons a s) (cur c) (ETcons (Cam_clos c a) s)\n  | APPcam1 :\n      forall (s s1 : Etat) (a b : CSem_val) (c : Commande),\n      CAM_DS (ETcons (Cam_pair a b) s) c s1 ->\n      CAM_DS (ETcons (Cam_pair (Cam_clos c a) b) s) app s1\n  | APPcam2 :\n      forall (s s1 : Etat) (a b : CSem_val) (c : Commande),\n      CAM_DS (ETcons (Cam_pair (Cam_pair b (Cam_clos_rec c b)) a) s) c s1 ->\n      CAM_DS (ETcons (Cam_pair (Cam_clos_rec c b) a) s) app s1\n  | APPcam_op :\n      forall (s : Etat) (n m : nat) (oper : OP),\n      CAM_DS\n        (ETcons\n           (Cam_pair (val (def_op oper))\n              (Cam_pair (val (int n)) (val (int m)))) s) app\n        (ETcons (val (int (eval_op oper n m))) s)\n  | CUR_REC :\n      forall (s : Etat) (a : CSem_val) (c : Commande),\n      CAM_DS (ETcons a s) (cur_rec c) (ETcons (Cam_clos_rec c a) s)\n  | o_DS :\n      forall (s s1 s2 : Etat) (c1 c2 : Commande),\n      CAM_DS s c1 s1 -> CAM_DS s1 c2 s2 -> CAM_DS s (o c1 c2) s2.
-----
Inductive Squelette : Set :=\n  | nil_squelette : Squelette\n  | cons_squelette : Pat -> Squelette -> Squelette.
-----
Inductive Habite : MLenv -> Squelette -> Prop :=\n  | triv_habite : Habite Enil nil_squelette\n  | cons_habite :\n      forall (x : Pat) (u : MLval) (e : MLenv) (s : Squelette),\n      Habite e s -> Habite (Econs x u e) (cons_squelette x s).
-----
Lemma Habite_inject :\n forall (e : MLenv) (s1 s2 : Squelette),\n Habite e s1 -> Habite e s2 -> s1 = s2.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.

*****

*****
forall (e : MLenv) (s1 s2 : Squelette) (_ : Habite e s1) (_ : Habite e s2), eq s1 s2
+++++
simple induction e.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.

*****
e : MLenv
*****
forall (s1 s2 : Squelette) (_ : Habite Enil s1) (_ : Habite Enil s2), eq s1 s2
+++++
intros.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.

*****
H0 : Habite Enil s2
H : Habite Enil s1
s1,s2 : Squelette
e : MLenv
*****
eq s1 s2
+++++
inversion_clear H.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.
inversion_clear H.

*****
H0 : Habite Enil s2
s1,s2 : Squelette
e : MLenv
*****
eq nil_squelette s2
+++++
inversion_clear H0.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.
inversion_clear H.
inversion_clear H0.

*****
s1,s2 : Squelette
e : MLenv
*****
eq nil_squelette nil_squelette
+++++
trivial.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.

*****
e : MLenv
*****
forall (p : Pat) (m : MLval) (m0 : MLenv) (_ : forall (s1 s2 : Squelette) (_ : Habite m0 s1) (_ : Habite m0 s2), eq s1 s2) (s1 s2 : Squelette) (_ : Habite (Econs p m m0) s1) (_ : Habite (Econs p m m0) s2), eq s1 s2
+++++
intros.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.

*****
H1 : Habite (Econs p m m0) s2
H0 : Habite (Econs p m m0) s1
s1,s2 : Squelette
H : forall (s1 s2 : Squelette) (_ : Habite m0 s1) (_ : Habite m0 s2),\neq s1 s2
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
eq s1 s2
+++++
inversion_clear H0.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.
inversion_clear H0.

*****
H2 : Habite m0 s
s : Squelette
H1 : Habite (Econs p m m0) s2
s1,s2 : Squelette
H : forall (s1 s2 : Squelette) (_ : Habite m0 s1) (_ : Habite m0 s2),\neq s1 s2
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
eq (cons_squelette p s) s2
+++++
inversion_clear H1.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.
inversion_clear H0.
inversion_clear H1.

*****
H0 : Habite m0 s0
s0 : Squelette
H2 : Habite m0 s
s1,s2,s : Squelette
H : forall (s1 s2 : Squelette) (_ : Habite m0 s1) (_ : Habite m0 s2),\neq s1 s2
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
eq (cons_squelette p s) (cons_squelette p s0)
+++++
elim (H s s0 H2 H0).
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.
intros.
inversion_clear H0.
inversion_clear H1.
elim (H s s0 H2 H0).

*****
H0 : Habite m0 s0
s0 : Squelette
H2 : Habite m0 s
s1,s2,s : Squelette
H : forall (s1 s2 : Squelette) (_ : Habite m0 s1) (_ : Habite m0 s2),\neq s1 s2
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
eq (cons_squelette p s) (cons_squelette p s)
+++++
trivial.
-----
Lemma Habite_inject : forall (e : MLenv) (s1 s2 : Squelette), Habite e s1 -> Habite e s2 -> s1 = s2.
simple induction e.

*****

*****

+++++
Qed.
-----
Inductive Access : Pat -> Squelette -> Commande -> Prop :=\n  | Rule1 :\n      forall (P : Pat) (s : Squelette), Access P (cons_squelette P s) cdr\n  | Rule2 :\n      forall (P T : Pat) (s : Squelette) (C : Commande),\n      P <> T -> Access P s C -> Access P (cons_squelette T s) (o car C).
-----
Lemma Access_inject :\n forall (x : Pat) (s : Squelette) (C C' : Commande),\n Access x s C' -> Access x s C -> C = C' :>Commande.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.

*****

*****
forall (x : Pat) (s : Squelette) (C C' : Commande) (_ : Access x s C') (_ : Access x s C), eq C C'
+++++
intro.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.

*****
x : Pat
*****
forall (s : Squelette) (C C' : Commande) (_ : Access x s C') (_ : Access x s C), eq C C'
+++++
simple induction s.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.

*****
s : Squelette
x : Pat
*****
forall (C C' : Commande) (_ : Access x nil_squelette C') (_ : Access x nil_squelette C), eq C C'
+++++
intros.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.

*****
H0 : Access x nil_squelette C
H : Access x nil_squelette C'
C,C' : Commande
s : Squelette
x : Pat
*****
eq C C'
+++++
inversion_clear H0.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.

*****
s : Squelette
x : Pat
*****
forall (p : Pat) (s : Squelette) (_ : forall (C C' : Commande) (_ : Access x s C') (_ : Access x s C), eq C C') (C C' : Commande) (_ : Access x (cons_squelette p s) C') (_ : Access x (cons_squelette p s) C), eq C C'
+++++
intros.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.

*****
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq C C'
+++++
simple inversion H0.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.

*****
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq C C'
+++++
simple inversion H1.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.

*****
H7 : eq cdr C
H6 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H5 : eq P0 x
s2 : Squelette
P0 : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq C C'
+++++
elim H4.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
elim H4.

*****
H7 : eq cdr C
H6 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H5 : eq P0 x
s2 : Squelette
P0 : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq C cdr
+++++
elim H7.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
elim H4.
elim H7.

*****
H7 : eq cdr C
H6 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H5 : eq P0 x
s2 : Squelette
P0 : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq cdr cdr
+++++
trivial.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.

*****
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : not (eq P0 T)) (_ : Access P0 s2 C0), eq C C'
+++++
injection H8.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.

*****
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq s2 s0) (_ : eq T p) (_ : not (eq P0 T)) (_ : Access P0 s2 C0), eq C C'
+++++
injection H3.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.

*****
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq s1 s0) (_ : eq P p) (_ : eq s2 s0) (_ : eq T p) (_ : not (eq P0 T)) (_ : Access P0 s2 C0), eq C C'
+++++
intros.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.
intros.

*****
H13 : Access P0 s2 C0
H12 : not (eq P0 T)
H11 : eq T p
H10 : eq s2 s0
H6 : eq P p
H5 : eq s1 s0
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq C C'
+++++
elim H12.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.
intros.
elim H12.

*****
H13 : Access P0 s2 C0
H12 : not (eq P0 T)
H11 : eq T p
H10 : eq s2 s0
H6 : eq P p
H5 : eq s1 s0
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq P0 T
+++++
try rewrite H7.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.
intros.
elim H12.
try rewrite H7.

*****
H13 : Access P0 s2 C0
H12 : not (eq P0 T)
H11 : eq T p
H10 : eq s2 s0
H6 : eq P p
H5 : eq s1 s0
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq x T
+++++
try rewrite <- H2.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.
intros.
elim H12.
try rewrite H7.
try rewrite <- H2.

*****
H13 : Access P0 s2 C0
H12 : not (eq P0 T)
H11 : eq T p
H10 : eq s2 s0
H6 : eq P p
H5 : eq s1 s0
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq P T
+++++
try rewrite H6.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.
intros.
elim H12.
try rewrite H7.
try rewrite <- H2.
try rewrite H6.

*****
H13 : Access P0 s2 C0
H12 : not (eq P0 T)
H11 : eq T p
H10 : eq s2 s0
H6 : eq P p
H5 : eq s1 s0
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq p T
+++++
try rewrite <- H11.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
simple inversion H1.
injection H8.
injection H3.
intros.
elim H12.
try rewrite H7.
try rewrite <- H2.
try rewrite H6.
try rewrite <- H11.

*****
H13 : Access P0 s2 C0
H12 : not (eq P0 T)
H11 : eq T p
H10 : eq s2 s0
H6 : eq P p
H5 : eq s1 s0
H9 : eq (o car C0) C
H8 : eq (cons_squelette T s2) (cons_squelette p s0)
H7 : eq P0 x
C0 : Commande
s2 : Squelette
P0,T : Pat
H4 : eq cdr C'
H3 : eq (cons_squelette P s1) (cons_squelette p s0)
H2 : eq P x
s1 : Squelette
P : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq T T
+++++
auto.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.

*****
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : not (eq P T)) (_ : Access P s1 C0), eq C C'
+++++
try rewrite H4.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.

*****
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
simple inversion H1.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.

*****
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
intros.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.

*****
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq C C'
+++++
elim H8.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.

*****
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq x T
+++++
injection H5.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.
injection H5.

*****
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq s1 s0) (_ : eq T p), eq x T
+++++
injection H3.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.
injection H5.
injection H3.

*****
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq s2 s0) (_ : eq P0 p) (_ : eq s1 s0) (_ : eq T p), eq x T
+++++
intros.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.
injection H5.
injection H3.
intros.

*****
H13 : eq T p
H12 : eq s1 s0
H11 : eq P0 p
H10 : eq s2 s0
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq x T
+++++
try rewrite <- H2.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.
injection H5.
injection H3.
intros.
try rewrite <- H2.

*****
H13 : eq T p
H12 : eq s1 s0
H11 : eq P0 p
H10 : eq s2 s0
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq P0 T
+++++
try rewrite H11.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.
injection H5.
injection H3.
intros.
try rewrite <- H2.
try rewrite H11.

*****
H13 : eq T p
H12 : eq s1 s0
H11 : eq P0 p
H10 : eq s2 s0
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq p T
+++++
try rewrite <- H13.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
intros.
elim H8.
injection H5.
injection H3.
intros.
try rewrite <- H2.
try rewrite H11.
try rewrite <- H13.

*****
H13 : eq T p
H12 : eq s1 s0
H11 : eq P0 p
H10 : eq s2 s0
H9 : Access x s1 C0
H8 : not (eq x T)
H7 : eq cdr C
H3 : eq (cons_squelette P0 s2) (cons_squelette p s0)
H2 : eq P0 x
s2 : Squelette
P0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq T T
+++++
auto.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.

*****
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : not (eq P0 T0)) (_ : Access P0 s2 C1) (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
try rewrite H7.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.

*****
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : not (eq x T0)) (_ : Access x s2 C1) (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
injection H8.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.

*****
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq s2 s0) (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s2 C1) (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
injection H5.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.

*****
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq s1 s0) (_ : eq T p) (_ : eq s2 s0) (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s2 C1) (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
intros HH1 HH2 HH3.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.

*****
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s2 C1) (_ : not (eq x T)) (_ : Access x s1 C0), eq C C'
+++++
try rewrite HH1.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.
try rewrite HH1.

*****
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s2 C1) (_ : not (eq x T)) (_ : Access x s0 C0), eq C C'
+++++
try rewrite HH3.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.
try rewrite HH1.
try rewrite HH3.

*****
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s0 C1) (_ : not (eq x T)) (_ : Access x s0 C0), eq C C'
+++++
try rewrite <- H6.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.
try rewrite HH1.
try rewrite HH3.
try rewrite <- H6.

*****
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s0 C1) (_ : not (eq x T)) (_ : Access x s0 C0), eq C (o car C0)
+++++
try rewrite <- H9.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.
try rewrite HH1.
try rewrite HH3.
try rewrite <- H6.
try rewrite <- H9.

*****
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
forall (_ : eq T0 p) (_ : not (eq x T0)) (_ : Access x s0 C1) (_ : not (eq x T)) (_ : Access x s0 C0), eq (o car C1) (o car C0)
+++++
intros.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.
try rewrite HH1.
try rewrite HH3.
try rewrite <- H6.
try rewrite <- H9.
intros.

*****
H12 : Access x s0 C0
H11 : not (eq x T)
H10 : Access x s0 C1
H3 : not (eq x T0)
H2 : eq T0 p
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq (o car C1) (o car C0)
+++++
elim (H C1 C0 H12 H10).
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.
intros.
simple inversion H0.
try rewrite H4.
simple inversion H1.
try rewrite H7.
injection H8.
injection H5.
intros HH1 HH2 HH3.
try rewrite HH1.
try rewrite HH3.
try rewrite <- H6.
try rewrite <- H9.
intros.
elim (H C1 C0 H12 H10).

*****
H12 : Access x s0 C0
H11 : not (eq x T)
H10 : Access x s0 C1
H3 : not (eq x T0)
H2 : eq T0 p
HH3 : eq s2 s0
HH2 : eq T p
HH1 : eq s1 s0
H9 : eq (o car C1) C
H8 : eq (cons_squelette T0 s2) (cons_squelette p s0)
H7 : eq P0 x
C1 : Commande
s2 : Squelette
P0,T0 : Pat
H6 : eq (o car C0) C'
H5 : eq (cons_squelette T s1) (cons_squelette p s0)
H4 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H1 : Access x (cons_squelette p s0) C
H0 : Access x (cons_squelette p s0) C'
C,C' : Commande
H : forall (C C' : Commande) (_ : Access x s0 C') (_ : Access x s0 C),\neq C C'
s0 : Squelette
p : Pat
s : Squelette
x : Pat
*****
eq (o car C1) (o car C1)
+++++
trivial.
-----
Lemma Access_inject : forall (x : Pat) (s : Squelette) (C C' : Commande), Access x s C' -> Access x s C -> C = C' :>Commande.
intro.
simple induction s.

*****

*****

+++++
Qed.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.

*****

*****
forall e : MLenv, ex (fun s : Squelette => Habite e s)
+++++
intro.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.

*****
e : MLenv
*****
ex (fun s : Squelette => Habite e s)
+++++
pattern e in |- *.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.

*****
e : MLenv
*****
(fun m : MLenv => ex (fun s : Squelette => Habite m s)) e
+++++
apply MLenv_ind.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.

*****
e : MLenv
*****
ex (fun s : Squelette => Habite Enil s)
+++++
exists nil_squelette.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.
exists nil_squelette.

*****
e : MLenv
*****
Habite Enil nil_squelette
+++++
exact triv_habite.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.

*****
e : MLenv
*****
forall (p : Pat) (m : MLval) (m0 : MLenv) (_ : ex (fun s : Squelette => Habite m0 s)), ex (fun s : Squelette => Habite (Econs p m m0) s)
+++++
intros.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.
intros.

*****
H : ex (fun s : Squelette => Habite m0 s)
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
ex (fun s : Squelette => Habite (Econs p m m0) s)
+++++
elim H.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.
intros.
elim H.

*****
H : ex (fun s : Squelette => Habite m0 s)
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
forall (x : Squelette) (_ : Habite m0 x), ex (fun s : Squelette => Habite (Econs p m m0) s)
+++++
intro s.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.
intros.
elim H.
intro s.

*****
s : Squelette
H : ex (fun s : Squelette => Habite m0 s)
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
forall _ : Habite m0 s, ex (fun s : Squelette => Habite (Econs p m m0) s)
+++++
intro.
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.
intros.
elim H.
intro s.
intro.

*****
H0 : Habite m0 s
s : Squelette
H : ex (fun s : Squelette => Habite m0 s)
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
ex (fun s : Squelette => Habite (Econs p m m0) s)
+++++
exists (cons_squelette p s).
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.
intros.
elim H.
intro s.
intro.
exists (cons_squelette p s).

*****
H0 : Habite m0 s
s : Squelette
H : ex (fun s : Squelette => Habite m0 s)
m0 : MLenv
m : MLval
p : Pat
e : MLenv
*****
Habite (Econs p m m0) (cons_squelette p s)
+++++
exact (cons_habite p m m0 s H0).
-----
Lemma Squelet : forall e : MLenv, exists s : Squelette, Habite e s.
intro.
pattern e in |- *.
apply MLenv_ind.

*****

*****

+++++
Qed.
-----
Inductive Traduction : Squelette -> MLexp -> Commande -> Prop :=\n  | Bool_Trad :\n      forall (b : bool) (S : Squelette),\n      Traduction S (Bool b) (quote (elem b))\n  | Trad_num :\n      forall (n : nat) (S : Squelette), Traduction S (Num n) (quote (int n))\n  | Trad_clos :\n      forall (c : OP) (S : Squelette), Traduction S (op c) (quote (def_op c))\n  | Trad_var :\n      forall (p : Pat) (S : Squelette) (C : Commande),\n      Access p S C -> Traduction S (id p) C\n  | Trad_ite :\n      forall (S : Squelette) (E1 E2 E3 : MLexp) (C1 C2 C3 : Commande),\n      Traduction S E1 C1 ->\n      Traduction S E2 C2 ->\n      Traduction S E3 C3 ->\n      Traduction S (ite E1 E2 E3) (o push (o C1 (branch C2 C3)))\n  | Trad_pair :\n      forall (S : Squelette) (E1 E2 : MLexp) (C1 C2 : Commande),\n      Traduction S E1 C1 ->\n      Traduction S E2 C2 ->\n      Traduction S (mlpair E1 E2) (o push (o C1 (o swap (o C2 cons))))\n  | Trad_app :\n      forall (S : Squelette) (E1 E2 : MLexp) (C1 C2 : Commande),\n      Traduction S E1 C1 ->\n      Traduction S E2 C2 ->\n      Traduction S (appl E1 E2) (o push (o C1 (o swap (o C2 (o cons app)))))\n  | Trad_let :\n      forall (p : Pat) (S : Squelette) (E1 E2 : MLexp) (C1 C2 : Commande),\n      Traduction S E1 C1 ->\n      Traduction (cons_squelette p S) E2 C2 ->\n      Traduction S (let' p E1 E2) (o push (o C1 (o cons C2)))\n  | Trad_let_rec :\n      forall (p x : Pat) (S : Squelette) (E E2 : MLexp) (C C2 : Commande),\n      Traduction (cons_squelette x (cons_squelette p S)) E C ->\n      Traduction (cons_squelette p S) E2 C2 ->\n      Traduction S (letrec p x E E2) (o push (o (cur_rec C) (o cons C2)))\n  | Trad_lambda :\n      forall (S : Squelette) (p : Pat) (E : MLexp) (C : Commande),\n      Traduction (cons_squelette p S) E C ->\n      Traduction S (lambda p E) (cur C).
-----
Lemma Traduction_inject :\n forall (E : MLexp) (C C' : Commande) (s : Squelette),\n Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.

*****

*****
forall (E : MLexp) (C C' : Commande) (s : Squelette) (_ : Traduction s E C) (_ : Traduction s E C'), eq C C'
+++++
simple induction E.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (b : bool) (C C' : Commande) (s : Squelette) (_ : Traduction s (Bool b) C) (_ : Traduction s (Bool b) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H0 : Traduction s (Bool b) C'
H : Traduction s (Bool b) C
s : Squelette
C,C' : Commande
b : bool
E : MLexp
*****
eq C C'
+++++
inversion_clear H.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.

*****
H0 : Traduction s (Bool b) C'
s : Squelette
C,C' : Commande
b : bool
E : MLexp
*****
eq (quote (elem b)) C'
+++++
inversion_clear H0.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.
inversion_clear H0.

*****
s : Squelette
C,C' : Commande
b : bool
E : MLexp
*****
eq (quote (elem b)) (quote (elem b))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (n : nat) (C C' : Commande) (s : Squelette) (_ : Traduction s (Num n) C) (_ : Traduction s (Num n) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H0 : Traduction s (Num n) C'
H : Traduction s (Num n) C
s : Squelette
C,C' : Commande
n : nat
E : MLexp
*****
eq C C'
+++++
inversion_clear H.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.

*****
H0 : Traduction s (Num n) C'
s : Squelette
C,C' : Commande
n : nat
E : MLexp
*****
eq (quote (int n)) C'
+++++
inversion_clear H0.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.
inversion_clear H0.

*****
s : Squelette
C,C' : Commande
n : nat
E : MLexp
*****
eq (quote (int n)) (quote (int n))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (o : OP) (C C' : Commande) (s : Squelette) (_ : Traduction s (op o) C) (_ : Traduction s (op o) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H0 : Traduction s (op o0) C'
H : Traduction s (op o0) C
s : Squelette
C,C' : Commande
o0 : OP
E : MLexp
*****
eq C C'
+++++
inversion_clear H.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.

*****
H0 : Traduction s (op o0) C'
s : Squelette
C,C' : Commande
o0 : OP
E : MLexp
*****
eq (quote (def_op o0)) C'
+++++
inversion_clear H0.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.
inversion_clear H0.

*****
s : Squelette
C,C' : Commande
o0 : OP
E : MLexp
*****
eq (quote (def_op o0)) (quote (def_op o0))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (p : Pat) (C C' : Commande) (s : Squelette) (_ : Traduction s (id p) C) (_ : Traduction s (id p) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H0 : Traduction s (id p) C'
H : Traduction s (id p) C
s : Squelette
C,C' : Commande
p : Pat
E : MLexp
*****
eq C C'
+++++
inversion_clear H.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.

*****
H1 : Access p s C
H0 : Traduction s (id p) C'
s : Squelette
C,C' : Commande
p : Pat
E : MLexp
*****
eq C C'
+++++
inversion_clear H0.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H.
inversion_clear H0.

*****
H : Access p s C'
H1 : Access p s C
s : Squelette
C,C' : Commande
p : Pat
E : MLexp
*****
eq C C'
+++++
exact (Access_inject p s C C' H H1).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (m : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C) (_ : Traduction s m C'), eq C C') (m0 : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C) (_ : Traduction s m0 C'), eq C C') (C C' : Commande) (s : Squelette) (_ : Traduction s (appl m m0) C) (_ : Traduction s (appl m m0) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H2 : Traduction s (appl m m0) C'
H1 : Traduction s (appl m m0) C
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq C C'
+++++
inversion_clear H1.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.

*****
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
H2 : Traduction s (appl m m0) C'
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 (o cons app))))) C'
+++++
inversion_clear H2.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.

*****
H5 : Traduction s m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 (o cons app))))) (o push (o C0 (o swap (o C3 (o cons app)))))
+++++
elim (H C1 C0 s H3 H1).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C1 C0 s H3 H1).

*****
H5 : Traduction s m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 (o cons app))))) (o push (o C1 (o swap (o C3 (o cons app)))))
+++++
elim (H0 C2 C3 s H4 H5).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C1 C0 s H3 H1).
elim (H0 C2 C3 s H4 H5).

*****
H5 : Traduction s m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 (o cons app))))) (o push (o C1 (o swap (o C2 (o cons app)))))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (m : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C) (_ : Traduction s m C'), eq C C') (m0 : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C) (_ : Traduction s m0 C'), eq C C') (C C' : Commande) (s : Squelette) (_ : Traduction s (mlpair m m0) C) (_ : Traduction s (mlpair m m0) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H2 : Traduction s (mlpair m m0) C'
H1 : Traduction s (mlpair m m0) C
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq C C'
+++++
inversion_clear H1.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.

*****
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
H2 : Traduction s (mlpair m m0) C'
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 cons)))) C'
+++++
inversion_clear H2.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.

*****
H5 : Traduction s m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 cons)))) (o push (o C0 (o swap (o C3 cons))))
+++++
elim (H C1 C0 s H3 H1).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C1 C0 s H3 H1).

*****
H5 : Traduction s m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 cons)))) (o push (o C1 (o swap (o C3 cons))))
+++++
elim (H0 C2 C3 s H4 H5).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C1 C0 s H3 H1).
elim (H0 C2 C3 s H4 H5).

*****
H5 : Traduction s m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction s m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (o swap (o C2 cons)))) (o push (o C1 (o swap (o C2 cons))))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (p : Pat) (m : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C) (_ : Traduction s m C'), eq C C') (C C' : Commande) (s : Squelette) (_ : Traduction s (lambda p m) C) (_ : Traduction s (lambda p m) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H1 : Traduction s (lambda p m) C'
H0 : Traduction s (lambda p m) C
s : Squelette
C,C' : Commande
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq C C'
+++++
inversion_clear H0.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H0.

*****
H2 : Traduction (cons_squelette p s) m C0
C0 : Commande
H1 : Traduction s (lambda p m) C'
s : Squelette
C,C' : Commande
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (cur C0) C'
+++++
inversion_clear H1.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H0.
inversion_clear H1.

*****
H0 : Traduction (cons_squelette p s) m C1
C1 : Commande
H2 : Traduction (cons_squelette p s) m C0
C0 : Commande
s : Squelette
C,C' : Commande
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (cur C0) (cur C1)
+++++
elim (H C0 C1 (cons_squelette p s) H2 H0).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H0.
inversion_clear H1.
elim (H C0 C1 (cons_squelette p s) H2 H0).

*****
H0 : Traduction (cons_squelette p s) m C1
C1 : Commande
H2 : Traduction (cons_squelette p s) m C0
C0 : Commande
s : Squelette
C,C' : Commande
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (cur C0) (cur C0)
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (p : Pat) (m : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C) (_ : Traduction s m C'), eq C C') (m0 : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C) (_ : Traduction s m0 C'), eq C C') (C C' : Commande) (s : Squelette) (_ : Traduction s (let' p m m0) C) (_ : Traduction s (let' p m m0) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H2 : Traduction s (let' p m m0) C'
H1 : Traduction s (let' p m m0) C
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq C C'
+++++
inversion_clear H1.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.

*****
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
H2 : Traduction s (let' p m m0) C'
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (o push (o C1 (o cons C2))) C'
+++++
inversion_clear H2.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.

*****
H5 : Traduction (cons_squelette p s) m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (o push (o C1 (o cons C2))) (o push (o C0 (o cons C3)))
+++++
elim (H C1 C0 s H3 H1).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C1 C0 s H3 H1).

*****
H5 : Traduction (cons_squelette p s) m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (o push (o C1 (o cons C2))) (o push (o C1 (o cons C3)))
+++++
elim (H0 C2 C3 (cons_squelette p s) H4 H5).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C1 C0 s H3 H1).
elim (H0 C2 C3 (cons_squelette p s) H4 H5).

*****
H5 : Traduction (cons_squelette p s) m0 C3
H1 : Traduction s m C0
C0,C3 : Commande
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction s m C1
C1,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p : Pat
E : MLexp
*****
eq (o push (o C1 (o cons C2))) (o push (o C1 (o cons C2)))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (p p0 : Pat) (m : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C) (_ : Traduction s m C'), eq C C') (m0 : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C) (_ : Traduction s m0 C'), eq C C') (C C' : Commande) (s : Squelette) (_ : Traduction s (letrec p p0 m m0) C) (_ : Traduction s (letrec p p0 m m0) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H2 : Traduction s (letrec p p0 m m0) C'
H1 : Traduction s (letrec p p0 m m0) C
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p,p0 : Pat
E : MLexp
*****
eq C C'
+++++
inversion_clear H1.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.

*****
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction (cons_squelette p0 (cons_squelette p s)) m C0
C0,C2 : Commande
H2 : Traduction s (letrec p p0 m m0) C'
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p,p0 : Pat
E : MLexp
*****
eq (o push (o (cur_rec C0) (o cons C2))) C'
+++++
inversion_clear H2.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.

*****
H5 : Traduction (cons_squelette p s) m0 C3
H1 : Traduction (cons_squelette p0 (cons_squelette p s)) m C1
C1,C3 : Commande
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction (cons_squelette p0 (cons_squelette p s)) m C0
C0,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p,p0 : Pat
E : MLexp
*****
eq (o push (o (cur_rec C0) (o cons C2))) (o push (o (cur_rec C1) (o cons C3)))
+++++
elim (H C0 C1 (cons_squelette p0 (cons_squelette p s)) H3 H1).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C0 C1 (cons_squelette p0 (cons_squelette p s)) H3 H1).

*****
H5 : Traduction (cons_squelette p s) m0 C3
H1 : Traduction (cons_squelette p0 (cons_squelette p s)) m C1
C1,C3 : Commande
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction (cons_squelette p0 (cons_squelette p s)) m C0
C0,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p,p0 : Pat
E : MLexp
*****
eq (o push (o (cur_rec C0) (o cons C2))) (o push (o (cur_rec C0) (o cons C3)))
+++++
elim (H0 C2 C3 (cons_squelette p s) H4 H5).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H1.
inversion_clear H2.
elim (H C0 C1 (cons_squelette p0 (cons_squelette p s)) H3 H1).
elim (H0 C2 C3 (cons_squelette p s) H4 H5).

*****
H5 : Traduction (cons_squelette p s) m0 C3
H1 : Traduction (cons_squelette p0 (cons_squelette p s)) m C1
C1,C3 : Commande
H4 : Traduction (cons_squelette p s) m0 C2
H3 : Traduction (cons_squelette p0 (cons_squelette p s)) m C0
C0,C2 : Commande
s : Squelette
C,C' : Commande
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
m : MLexp
p,p0 : Pat
E : MLexp
*****
eq (o push (o (cur_rec C0) (o cons C2))) (o push (o (cur_rec C0) (o cons C2)))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****
E : MLexp
*****
forall (m : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C) (_ : Traduction s m C'), eq C C') (m0 : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C) (_ : Traduction s m0 C'), eq C C') (m1 : MLexp) (_ : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C) (_ : Traduction s m1 C'), eq C C') (C C' : Commande) (s : Squelette) (_ : Traduction s (ite m m0 m1) C) (_ : Traduction s (ite m m0 m1) C'), eq C C'
+++++
intros.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.

*****
H3 : Traduction s (ite m m0 m1) C'
H2 : Traduction s (ite m m0 m1) C
s : Squelette
C,C' : Commande
H1 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C)\n (_ : Traduction s m1 C'), eq C C'
m1 : MLexp
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq C C'
+++++
inversion_clear H2.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H2.

*****
H6 : Traduction s m1 C3
H5 : Traduction s m0 C2
H4 : Traduction s m C1
C1,C2,C3 : Commande
H3 : Traduction s (ite m m0 m1) C'
s : Squelette
C,C' : Commande
H1 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C)\n (_ : Traduction s m1 C'), eq C C'
m1 : MLexp
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (branch C2 C3))) C'
+++++
inversion_clear H3.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H2.
inversion_clear H3.

*****
H8 : Traduction s m1 C5
H7 : Traduction s m0 C4
H2 : Traduction s m C0
C0,C4,C5 : Commande
H6 : Traduction s m1 C3
H5 : Traduction s m0 C2
H4 : Traduction s m C1
C1,C2,C3 : Commande
s : Squelette
C,C' : Commande
H1 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C)\n (_ : Traduction s m1 C'), eq C C'
m1 : MLexp
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (branch C2 C3))) (o push (o C0 (branch C4 C5)))
+++++
elim (H C1 C0 s H4 H2).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H2.
inversion_clear H3.
elim (H C1 C0 s H4 H2).

*****
H8 : Traduction s m1 C5
H7 : Traduction s m0 C4
H2 : Traduction s m C0
C0,C4,C5 : Commande
H6 : Traduction s m1 C3
H5 : Traduction s m0 C2
H4 : Traduction s m C1
C1,C2,C3 : Commande
s : Squelette
C,C' : Commande
H1 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C)\n (_ : Traduction s m1 C'), eq C C'
m1 : MLexp
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (branch C2 C3))) (o push (o C1 (branch C4 C5)))
+++++
elim (H0 C2 C4 s H5 H7).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H2.
inversion_clear H3.
elim (H C1 C0 s H4 H2).
elim (H0 C2 C4 s H5 H7).

*****
H8 : Traduction s m1 C5
H7 : Traduction s m0 C4
H2 : Traduction s m C0
C0,C4,C5 : Commande
H6 : Traduction s m1 C3
H5 : Traduction s m0 C2
H4 : Traduction s m C1
C1,C2,C3 : Commande
s : Squelette
C,C' : Commande
H1 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C)\n (_ : Traduction s m1 C'), eq C C'
m1 : MLexp
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (branch C2 C3))) (o push (o C1 (branch C2 C5)))
+++++
elim (H1 C3 C5 s H6 H8).
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.
intros.
inversion_clear H2.
inversion_clear H3.
elim (H C1 C0 s H4 H2).
elim (H0 C2 C4 s H5 H7).
elim (H1 C3 C5 s H6 H8).

*****
H8 : Traduction s m1 C5
H7 : Traduction s m0 C4
H2 : Traduction s m C0
C0,C4,C5 : Commande
H6 : Traduction s m1 C3
H5 : Traduction s m0 C2
H4 : Traduction s m C1
C1,C2,C3 : Commande
s : Squelette
C,C' : Commande
H1 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m1 C)\n (_ : Traduction s m1 C'), eq C C'
m1 : MLexp
H0 : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m0 C)\n (_ : Traduction s m0 C'), eq C C'
m0 : MLexp
H : forall (C C' : Commande) (s : Squelette) (_ : Traduction s m C)\n (_ : Traduction s m C'), eq C C'
E,m : MLexp
*****
eq (o push (o C1 (branch C2 C3))) (o push (o C1 (branch C2 C3)))
+++++
trivial.
-----
Lemma Traduction_inject : forall (E : MLexp) (C C' : Commande) (s : Squelette), Traduction s E C -> Traduction s E C' -> C = C' :>Commande.
simple induction E.

*****

*****

+++++
Qed.
-----
Inductive Equiv_val : MLval -> CSem_val -> Prop :=\n  | Eqbool : forall b : bool, Equiv_val (boolean b) (val (elem b))\n  | Eqnum : forall n : nat, Equiv_val (num n) (val (int n))\n  | Eq_op : forall c : OP, Equiv_val (OP_clos c) (val (def_op c))\n  | Eqpair :\n      forall (V1 V2 : MLval) (Cval1 Cval2 : CSem_val),\n      Equiv_val V1 Cval1 ->\n      Equiv_val V2 Cval2 -> Equiv_val (valpair V1 V2) (Cam_pair Cval1 Cval2)\n  | Eqclos :\n      forall (p : Pat) (E : MLexp) (C : Commande) (e : MLenv) \n        (CV : CSem_val) (s : Squelette),\n      Equiv_env e CV ->\n      Habite e s ->\n      Traduction (cons_squelette p s) E C ->\n      Equiv_val (Clos p E e) (Cam_clos C CV)\n  | Eqclos_rec :\n      forall (p x : Pat) (E : MLexp) (e : MLenv) (C : Commande)\n        (CV : CSem_val) (s : Squelette),\n      Equiv_env e CV ->\n      Habite e s ->\n      Traduction (cons_squelette x (cons_squelette p s)) E C ->\n      Equiv_val (Clos_rec x E p e) (Cam_clos_rec C CV)\nwith Equiv_env : MLenv -> CSem_val -> Prop :=\n  | Eqenv1 : Equiv_env Enil Cam_nil\n  | Eqenv2 :\n      forall (p : Pat) (E : MLenv) (CV0 : CSem_val),\n      Equiv_env E CV0 ->\n      forall (V : MLval) (CV : CSem_val),\n      Equiv_val V CV -> Equiv_env (Econs p V E) (Cam_pair CV0 CV).
-----
Inductive compilation (E : MLexp) : Prop :=\n    preuve_compilation :\n      (forall (e : MLenv) (V : MLval),\n       ML_DS e E V ->\n       forall (s : Squelette) (C : Commande),\n       Traduction s E C ->\n       Habite e s ->\n       forall CV : CSem_val,\n       Equiv_env e CV ->\n       exists CV1 : CSem_val,\n         Equiv_val V CV1 /\\n         (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s))) ->\n      compilation E.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).

*****

*****
forall b : bool, compilation (Bool b)
+++++
intro b.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.

*****
b : bool
*****
compilation (Bool b)
+++++
apply preuve_compilation.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.

*****
b : bool
*****
forall (e : MLenv) (V : MLval) (_ : ML_DS e (Bool b) V) (s : Squelette) (C : Commande) (_ : Traduction s (Bool b) C) (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e V ML_b s C Trad_b hab CV Eq.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
ML_b : ML_DS e (Bool b) V
V : MLval
e : MLenv
b : bool
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear ML_b.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
V : MLval
e : MLenv
b : bool
*****
ex (fun CV1 : CSem_val => and (Equiv_val (boolean b) CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exists (val (elem b)).
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.
exists (val (elem b)).

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
V : MLval
e : MLenv
b : bool
*****
and (Equiv_val (boolean b) (val (elem b))) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons (val (elem b)) s))
+++++
split.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.
exists (val (elem b)).
split.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
V : MLval
e : MLenv
b : bool
*****
Equiv_val (boolean b) (val (elem b))
+++++
exact (Eqbool b).
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.
exists (val (elem b)).
split.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
V : MLval
e : MLenv
b : bool
*****
forall s : Etat, CAM_DS (ETcons CV s) C (ETcons (val (elem b)) s)
+++++
inversion_clear Trad_b.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.
exists (val (elem b)).
split.
inversion_clear Trad_b.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
C : Commande
s : Squelette
V : MLval
e : MLenv
b : bool
*****
forall s : Etat, CAM_DS (ETcons CV s) (quote (elem b)) (ETcons (val (elem b)) s)
+++++
intro s0.
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.
exists (val (elem b)).
split.
inversion_clear Trad_b.
intro s0.

*****
s0 : Etat
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
C : Commande
s : Squelette
V : MLval
e : MLenv
b : bool
*****
CAM_DS (ETcons CV s0) (quote (elem b)) (ETcons (val (elem b)) s0)
+++++
exact (QUO s0 CV (elem b)).
-----
Lemma Proof_bool : forall b : bool, compilation (Bool b).
intro b.
apply preuve_compilation.
intros e V ML_b s C Trad_b hab CV Eq.
inversion_clear ML_b.
exists (val (elem b)).
split.

*****

*****

+++++
Qed.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
-----
Lemma Proof_int : forall n : nat, compilation (Num n).

*****

*****
forall n : nat, compilation (Num n)
+++++
intro n.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.

*****
n : nat
*****
compilation (Num n)
+++++
apply preuve_compilation.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.

*****
n : nat
*****
forall (e : MLenv) (V : MLval) (_ : ML_DS e (Num n) V) (s : Squelette) (C : Commande) (_ : Traduction s (Num n) C) (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e V ML_n s C Trad_n hab CV Eq.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_n : Traduction s (Num n) C
C : Commande
s : Squelette
ML_n : ML_DS e (Num n) V
V : MLval
e : MLenv
n : nat
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear ML_n.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_n : Traduction s (Num n) C
C : Commande
s : Squelette
V : MLval
e : MLenv
n : nat
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num n) CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exists (val (int n)).
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.
exists (val (int n)).

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_n : Traduction s (Num n) C
C : Commande
s : Squelette
V : MLval
e : MLenv
n : nat
*****
and (Equiv_val (num n) (val (int n))) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons (val (int n)) s))
+++++
split.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.
exists (val (int n)).
split.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_n : Traduction s (Num n) C
C : Commande
s : Squelette
V : MLval
e : MLenv
n : nat
*****
Equiv_val (num n) (val (int n))
+++++
exact (Eqnum n).
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.
exists (val (int n)).
split.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_n : Traduction s (Num n) C
C : Commande
s : Squelette
V : MLval
e : MLenv
n : nat
*****
forall s : Etat, CAM_DS (ETcons CV s) C (ETcons (val (int n)) s)
+++++
inversion_clear Trad_n.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.
exists (val (int n)).
split.
inversion_clear Trad_n.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
C : Commande
s : Squelette
V : MLval
e : MLenv
n : nat
*****
forall s : Etat, CAM_DS (ETcons CV s) (quote (int n)) (ETcons (val (int n)) s)
+++++
intro s0.
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.
exists (val (int n)).
split.
inversion_clear Trad_n.
intro s0.

*****
s0 : Etat
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
C : Commande
s : Squelette
V : MLval
e : MLenv
n : nat
*****
CAM_DS (ETcons CV s0) (quote (int n)) (ETcons (val (int n)) s0)
+++++
exact (QUO s0 CV (int n)).
-----
Lemma Proof_int : forall n : nat, compilation (Num n).
intro n.
apply preuve_compilation.
intros e V ML_n s C Trad_n hab CV Eq.
inversion_clear ML_n.
exists (val (int n)).
split.

*****

*****

+++++
Qed.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
-----
Lemma Proof_op : forall c : OP, compilation (op c).

*****

*****
forall c : OP, compilation (op c)
+++++
intro c.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.

*****
c : OP
*****
compilation (op c)
+++++
apply preuve_compilation.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.

*****
c : OP
*****
forall (e : MLenv) (V : MLval) (_ : ML_DS e (op c) V) (s : Squelette) (C : Commande) (_ : Traduction s (op c) C) (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e V ML_c s C Trad_c hab CV Eq.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_c : Traduction s (op c) C
C : Commande
s : Squelette
ML_c : ML_DS e (op c) V
V : MLval
e : MLenv
c : OP
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear ML_c.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_c : Traduction s (op c) C
C : Commande
s : Squelette
V : MLval
e : MLenv
c : OP
*****
ex (fun CV1 : CSem_val => and (Equiv_val (OP_clos c) CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exists (val (def_op c)).
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.
exists (val (def_op c)).

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_c : Traduction s (op c) C
C : Commande
s : Squelette
V : MLval
e : MLenv
c : OP
*****
and (Equiv_val (OP_clos c) (val (def_op c))) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons (val (def_op c)) s))
+++++
split.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.
exists (val (def_op c)).
split.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_c : Traduction s (op c) C
C : Commande
s : Squelette
V : MLval
e : MLenv
c : OP
*****
Equiv_val (OP_clos c) (val (def_op c))
+++++
exact (Eq_op c).
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.
exists (val (def_op c)).
split.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
Trad_c : Traduction s (op c) C
C : Commande
s : Squelette
V : MLval
e : MLenv
c : OP
*****
forall s : Etat, CAM_DS (ETcons CV s) C (ETcons (val (def_op c)) s)
+++++
inversion_clear Trad_c.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.
exists (val (def_op c)).
split.
inversion_clear Trad_c.

*****
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
C : Commande
s : Squelette
V : MLval
e : MLenv
c : OP
*****
forall s : Etat, CAM_DS (ETcons CV s) (quote (def_op c)) (ETcons (val (def_op c)) s)
+++++
intro s0.
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.
exists (val (def_op c)).
split.
inversion_clear Trad_c.
intro s0.

*****
s0 : Etat
Eq : Equiv_env e CV
CV : CSem_val
hab : Habite e s
C : Commande
s : Squelette
V : MLval
e : MLenv
c : OP
*****
CAM_DS (ETcons CV s0) (quote (def_op c)) (ETcons (val (def_op c)) s0)
+++++
exact (QUO s0 CV (def_op c)).
-----
Lemma Proof_op : forall c : OP, compilation (op c).
intro c.
apply preuve_compilation.
intros e V ML_c s C Trad_c hab CV Eq.
inversion_clear ML_c.
exists (val (def_op c)).
split.

*****

*****

+++++
Qed.
-----
Inductive compilation_id (E : MLexp) : Prop :=\n    preuve_compilation_id :\n      (forall (e : MLenv) (s : Squelette),\n       Habite e s ->\n       forall V : MLval,\n       ML_DS e E V ->\n       forall C : Commande,\n       Traduction s E C ->\n       forall CV : CSem_val,\n       Equiv_env e CV ->\n       exists CV1 : CSem_val,\n         Equiv_val V CV1 /\\n         (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s))) ->\n      compilation_id E.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).

*****

*****
forall x : Pat, compilation_id (id x)
+++++
intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.

*****
x : Pat
*****
compilation_id (id x)
+++++
apply preuve_compilation_id.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.

*****
x : Pat
*****
forall (e : MLenv) (s : Squelette) (_ : Habite e s) (V : MLval) (_ : ML_DS e (id x) V) (C : Commande) (_ : Traduction s (id x) C) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
simple induction e.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.

*****
e : MLenv
x : Pat
*****
forall (s : Squelette) (_ : Habite Enil s) (V : MLval) (_ : ML_DS Enil (id x) V) (C : Commande) (_ : Traduction s (id x) C) (CV : CSem_val) (_ : Equiv_env Enil CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
intros.

*****
H2 : Equiv_env Enil CV
CV : CSem_val
H1 : Traduction s (id x) C
C : Commande
H0 : ML_DS Enil (id x) V
V : MLval
H : Habite Enil s
s : Squelette
e : MLenv
x : Pat
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H0.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
intros.
inversion_clear H0.

*****
H3 : VAL_OF Enil x V
H2 : Equiv_env Enil CV
CV : CSem_val
H1 : Traduction s (id x) C
C : Commande
V : MLval
H : Habite Enil s
s : Squelette
e : MLenv
x : Pat
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H3.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.

*****
e : MLenv
x : Pat
*****
forall (p : Pat) (m : MLval) (m0 : MLenv) (_ : forall (s : Squelette) (_ : Habite m0 s) (V : MLval) (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C) (CV : CSem_val) (_ : Equiv_env m0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (_ : Habite (Econs p m m0) s) (V : MLval) (_ : ML_DS (Econs p m m0) (id x) V) (C : Commande) (_ : Traduction s (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
do 6 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.

*****
H0 : Habite (Econs p m m0) s
s : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (V : MLval) (_ : ML_DS (Econs p m m0) (id x) V) (C : Commande) (_ : Traduction s (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H0.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.

*****
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (V : MLval) (_ : ML_DS (Econs p m m0) (id x) V) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.

*****
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : ML_DS (Econs p m m0) (id x) V) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.

*****
H0 : ML_DS (Econs p m m0) (id x) V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H0.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.

*****
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
simple inversion H2.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.

*****
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
injection H0.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.

*****
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : eq e0 m0) (_ : eq a m) (_ : eq I p) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
do 3 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.

*****
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite <- H3.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.

*****
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (C : Commande) (_ : Traduction (cons_squelette p s0) (id I) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H7.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.

*****
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (C : Commande) (_ : Traduction (cons_squelette p s0) (id p) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
do 2 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.

*****
H8 : Traduction (cons_squelette p s0) (id p) C
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H8.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.

*****
H9 : Access p (cons_squelette p s0) C
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H9.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.

*****
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) cdr (ETcons CV1 s)))
+++++
do 2 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.

*****
H8 : Equiv_env (Econs p m m0) CV
CV : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) cdr (ETcons CV1 s)))
+++++
inversion_clear H8.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.

*****
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) cdr (ETcons CV2 s)))
+++++
try rewrite <- H4.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.
try rewrite <- H4.

*****
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val a CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) cdr (ETcons CV2 s)))
+++++
try rewrite H6.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.
try rewrite <- H4.
try rewrite H6.

*****
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val m CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) cdr (ETcons CV2 s)))
+++++
exists CV1.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.
try rewrite <- H4.
try rewrite H6.
exists CV1.

*****
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
and (Equiv_val m CV1) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) cdr (ETcons CV1 s))
+++++
split.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.
try rewrite <- H4.
try rewrite H6.
exists CV1.
split.

*****
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
Equiv_val m CV1
+++++
exact H10.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.
try rewrite <- H4.
try rewrite H6.
exists CV1.
split.

*****
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) cdr (ETcons CV1 s)
+++++
intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
do 2 intro.
inversion_clear H8.
try rewrite <- H4.
try rewrite H6.
exists CV1.
split.
intro.

*****
s1 : Etat
H10 : Equiv_val m CV1
H9 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
C : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
CAM_DS (ETcons (Cam_pair CV0 CV1) s1) cdr (ETcons CV1 s1)
+++++
apply CDR.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.

*****
H10 : Access p s0 C0
H8 : not (eq p p)
C,C0 : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o car C0) (ETcons CV1 s)))
+++++
elim H8.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H0.
do 3 intro.
try rewrite <- H3.
try rewrite H7.
do 2 intro.
inversion_clear H8.
inversion_clear H9.
elim H8.

*****
H10 : Access p s0 C0
H8 : not (eq p p)
C,C0 : Commande
H7 : eq I p
H6 : eq a m
H5 : eq e0 m0
H4 : eq a V
H3 : eq I x
H0 : eq (Econs I a e0) (Econs p m m0)
a : MLval
I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
eq p p
+++++
trivial.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.

*****
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : VAL_OF e0 I a) (_ : not (eq X I)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
injection H4.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.

*****
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : eq e0 m0) (_ : eq b m) (_ : eq X p) (_ : VAL_OF e0 I a) (_ : not (eq X I)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
do 3 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.

*****
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : VAL_OF e0 I a) (_ : not (eq X I)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H5.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.

*****
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : VAL_OF e0 x a) (_ : not (eq X x)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H7.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.

*****
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : VAL_OF e0 x a) (_ : not (eq p x)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H6.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.

*****
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : VAL_OF e0 x V) (_ : not (eq p x)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H0.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.

*****
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : VAL_OF m0 x V) (_ : not (eq p x)) (C : Commande) (_ : Traduction (cons_squelette p s0) (id x) C) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
do 4 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.

*****
H10 : Traduction (cons_squelette p s0) (id x) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear H10.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.

*****
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
simple inversion H11.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.

*****
H13 : eq cdr C
H12 : eq (cons_squelette P s1) (cons_squelette p s0)
H10 : eq P x
s1 : Squelette
P : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
injection H12.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
injection H12.

*****
H13 : eq cdr C
H12 : eq (cons_squelette P s1) (cons_squelette p s0)
H10 : eq P x
s1 : Squelette
P : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : eq s1 s0) (_ : eq P p) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H10.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
injection H12.
try rewrite H10.

*****
H13 : eq cdr C
H12 : eq (cons_squelette P s1) (cons_squelette p s0)
H10 : eq P x
s1 : Squelette
P : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : eq s1 s0) (_ : eq x p) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
do 2 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
injection H12.
try rewrite H10.
do 2 intro.

*****
H15 : eq x p
H14 : eq s1 s0
H13 : eq cdr C
H12 : eq (cons_squelette P s1) (cons_squelette p s0)
H10 : eq P x
s1 : Squelette
P : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
elim H9.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
injection H12.
try rewrite H10.
do 2 intro.
elim H9.

*****
H15 : eq x p
H14 : eq s1 s0
H13 : eq cdr C
H12 : eq (cons_squelette P s1) (cons_squelette p s0)
H10 : eq P x
s1 : Squelette
P : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
eq p x
+++++
elim H15.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
injection H12.
try rewrite H10.
do 2 intro.
elim H9.
elim H15.

*****
H15 : eq x p
H14 : eq s1 s0
H13 : eq cdr C
H12 : eq (cons_squelette P s1) (cons_squelette p s0)
H10 : eq P x
s1 : Squelette
P : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
eq x x
+++++
auto.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.

*****
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : not (eq P T)) (_ : Access P s1 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H13.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.

*****
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : not (eq x T)) (_ : Access x s1 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
injection H14.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.

*****
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : eq s1 s0) (_ : eq T p) (_ : not (eq x T)) (_ : Access x s1 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
do 2 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.

*****
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : not (eq x T)) (_ : Access x s1 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H12.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.

*****
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : not (eq x p)) (_ : Access x s1 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite H10.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.

*****
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : not (eq x p)) (_ : Access x s0 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
try rewrite <- H15.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.

*****
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : not (eq x p)) (_ : Access x s0 C0) (CV : CSem_val) (_ : Equiv_env (Econs p m m0) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o car C0) (ETcons CV1 s)))
+++++
do 4 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.

*****
H18 : Equiv_env (Econs p m m0) CV
CV : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o car C0) (ETcons CV1 s)))
+++++
inversion_clear H18.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
cut (ML_DS m0 (id x) V).
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall _ : ML_DS m0 (id x) V, ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
cut (Traduction s0 (id x) C0).
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : Traduction s0 (id x) C0) (_ : ML_DS m0 (id x) V), ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
intros Hyp_Trad Hyp_ML.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.

*****
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).

*****
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (x : CSem_val) (_ : and (Equiv_val V x) (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x s))), ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
do 2 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.

*****
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
elim H18.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.

*****
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall (_ : Equiv_val V x0) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)), ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
do 2 intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.

*****
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ex (fun CV2 : CSem_val => and (Equiv_val V CV2) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons CV2 s)))
+++++
exists x0.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.
exists x0.

*****
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
and (Equiv_val V x0) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons x0 s))
+++++
split.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.
exists x0.
split.

*****
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
Equiv_val V x0
+++++
exact H21.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.
exists x0.
split.

*****
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV1) s) (o car C0) (ETcons x0 s)
+++++
intro.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.
exists x0.
split.
intro.

*****
s2 : Etat
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
CAM_DS (ETcons (Cam_pair CV0 CV1) s2) (o car C0) (ETcons x0 s2)
+++++
apply (o_DS (ETcons (Cam_pair CV0 CV1) s2) (ETcons CV0 s2) (ETcons x0 s2) car C0).
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.
exists x0.
split.
intro.
apply (o_DS (ETcons (Cam_pair CV0 CV1) s2) (ETcons CV0 s2) (ETcons x0 s2) car C0).

*****
s2 : Etat
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
CAM_DS (ETcons (Cam_pair CV0 CV1) s2) car (ETcons CV0 s2)
+++++
apply CAR.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
intros Hyp_Trad Hyp_ML.
elim (H s0 H1 V Hyp_ML C0 Hyp_Trad CV0 H19).
do 2 intro.
elim H18.
do 2 intro.
exists x0.
split.
intro.
apply (o_DS (ETcons (Cam_pair CV0 CV1) s2) (ETcons CV0 s2) (ETcons x0 s2) car C0).

*****
s2 : Etat
H22 : forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s)
H21 : Equiv_val V x0
H18 : and (Equiv_val V x0)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C0 (ETcons x0 s))
x0 : CSem_val
Hyp_ML : ML_DS m0 (id x) V
Hyp_Trad : Traduction s0 (id x) C0
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
CAM_DS (ETcons CV0 s2) C0 (ETcons x0 s2)
+++++
exact (H22 s2).
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
Traduction s0 (id x) C0
+++++
apply Trad_var.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
cut (Traduction s0 (id x) C0).
apply Trad_var.

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
Access x s0 C0
+++++
exact H17.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
ML_DS m0 (id x) V
+++++
apply IDENT.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.
do 6 intro.
inversion_clear H0.
intro.
intro.
inversion_clear H0.
simple inversion H2.
injection H4.
do 3 intro.
try rewrite H5.
try rewrite H7.
try rewrite H6.
try rewrite H0.
do 4 intro.
inversion_clear H10.
simple inversion H11.
try rewrite H13.
injection H14.
do 2 intro.
try rewrite H12.
try rewrite H10.
try rewrite <- H15.
do 4 intro.
inversion_clear H18.
cut (ML_DS m0 (id x) V).
apply IDENT.

*****
H20 : Equiv_val m CV1
H19 : Equiv_env m0 CV0
CV,CV0,CV1 : CSem_val
H17 : Access x s0 C0
H16 : not (eq x p)
H12 : eq T p
H10 : eq s1 s0
H15 : eq (o car C0) C
H14 : eq (cons_squelette T s1) (cons_squelette p s0)
H13 : eq P x
C0 : Commande
s1 : Squelette
P,T : Pat
H11 : Access x (cons_squelette p s0) C
C : Commande
H9 : not (eq p x)
H8 : VAL_OF m0 x V
H7 : eq X p
H3 : eq b m
H0 : eq e0 m0
H6 : eq a V
H5 : eq I x
H4 : eq (Econs X b e0) (Econs p m m0)
a,b : MLval
X,I : Pat
e0 : MLenv
H2 : VAL_OF (Econs p m m0) x V
V : MLval
H1 : Habite m0 s0
s,s0 : Squelette
H : forall (s : Squelette) (_ : Habite m0 s) (V : MLval)\n (_ : ML_DS m0 (id x) V) (C : Commande) (_ : Traduction s (id x) C)\n (CV : CSem_val) (_ : Equiv_env m0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
m0 : MLenv
m : MLval
p : Pat
e : MLenv
x : Pat
*****
VAL_OF m0 x V
+++++
exact H8.
-----
Lemma Proof_ident : forall x : Pat, compilation_id (id x).
intro.
apply preuve_compilation_id.
simple induction e.

*****

*****

+++++
Qed.
-----
Lemma Proof_abstraction :\n forall (E : MLexp) (p : Pat), compilation (lambda p E).
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).

*****

*****
forall (E : MLexp) (p : Pat), compilation (lambda p E)
+++++
intros E p.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.

*****
p : Pat
E : MLexp
*****
compilation (lambda p E)
+++++
apply preuve_compilation.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.

*****
p : Pat
E : MLexp
*****
forall (e : MLenv) (V : MLval) (_ : ML_DS e (lambda p E) V) (s : Squelette) (C : Commande) (_ : Traduction s (lambda p E) C) (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e V ML_lambda.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.

*****
ML_lambda : ML_DS e (lambda p E) V
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
forall (s : Squelette) (C : Commande) (_ : Traduction s (lambda p E) C) (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
inversion_clear ML_lambda.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.

*****
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
forall (s : Squelette) (C : Commande) (_ : Traduction s (lambda p E) C) (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val (Clos p E e) CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros s C Trad_lam.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.

*****
Trad_lam : Traduction s (lambda p E) C
C : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
forall (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val (Clos p E e) CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_lam.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.

*****
H : Traduction (cons_squelette p s) E C0
C,C0 : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
forall (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val (Clos p E e) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (cur C0) (ETcons CV1 s)))
+++++
intros hab CV Eq_e_CV.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.
intros hab CV Eq_e_CV.

*****
Eq_e_CV : Equiv_env e CV
CV : CSem_val
hab : Habite e s
H : Traduction (cons_squelette p s) E C0
C,C0 : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (Clos p E e) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (cur C0) (ETcons CV1 s)))
+++++
exists (Cam_clos C0 CV).
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.
intros hab CV Eq_e_CV.
exists (Cam_clos C0 CV).

*****
Eq_e_CV : Equiv_env e CV
CV : CSem_val
hab : Habite e s
H : Traduction (cons_squelette p s) E C0
C,C0 : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
and (Equiv_val (Clos p E e) (Cam_clos C0 CV)) (forall s : Etat, CAM_DS (ETcons CV s) (cur C0) (ETcons (Cam_clos C0 CV) s))
+++++
split.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.
intros hab CV Eq_e_CV.
exists (Cam_clos C0 CV).
split.

*****
Eq_e_CV : Equiv_env e CV
CV : CSem_val
hab : Habite e s
H : Traduction (cons_squelette p s) E C0
C,C0 : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
Equiv_val (Clos p E e) (Cam_clos C0 CV)
+++++
apply (Eqclos p E C0 e CV s Eq_e_CV hab H).
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.
intros hab CV Eq_e_CV.
exists (Cam_clos C0 CV).
split.

*****
Eq_e_CV : Equiv_env e CV
CV : CSem_val
hab : Habite e s
H : Traduction (cons_squelette p s) E C0
C,C0 : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV s) (cur C0) (ETcons (Cam_clos C0 CV) s)
+++++
intro.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.
intros hab CV Eq_e_CV.
exists (Cam_clos C0 CV).
split.
intro.

*****
s0 : Etat
Eq_e_CV : Equiv_env e CV
CV : CSem_val
hab : Habite e s
H : Traduction (cons_squelette p s) E C0
C,C0 : Commande
s : Squelette
V : MLval
e : MLenv
p : Pat
E : MLexp
*****
CAM_DS (ETcons CV s0) (cur C0) (ETcons (Cam_clos C0 CV) s0)
+++++
apply CUR.
-----
Lemma Proof_abstraction : forall (E : MLexp) (p : Pat), compilation (lambda p E).
intros E p.
apply preuve_compilation.
intros e V ML_lambda.
inversion_clear ML_lambda.
intros s C Trad_lam.
inversion_clear Trad_lam.
intros hab CV Eq_e_CV.
exists (Cam_clos C0 CV).
split.

*****

*****

+++++
Qed.
-----
Lemma final_proof :\n forall (E : MLexp) (e : MLenv) (V : MLval),\n ML_DS e E V ->\n forall (s : Squelette) (C : Commande),\n Traduction s E C ->\n Habite e s ->\n forall V : MLval,\n ML_DS e E V ->\n forall CV : CSem_val,\n Equiv_env e CV ->\n exists CV1 : CSem_val,\n   Equiv_val V CV1 /\\n   (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).

*****

*****
forall (E : MLexp) (e : MLenv) (V : MLval) (_ : ML_DS e E V) (s : Squelette) (C : Commande) (_ : Traduction s E C) (_ : Habite e s) (V0 : MLval) (_ : ML_DS e E V0) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros E e V.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.

*****
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : ML_DS e E V) (s : Squelette) (C : Commande) (_ : Traduction s E C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
simple induction 1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (b : bool) (e : MLenv) (s : Squelette) (C : Commande) (_ : Traduction s (Bool b) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (Bool b) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_b : ML_DS e0 (Bool b) V0
V0 : MLval
hab : Habite e0 s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
cut (compilation (Bool b)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_b : ML_DS e0 (Bool b) V0
V0 : MLval
hab : Habite e0 s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (Bool b), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
2: exact (Proof_bool b).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_b : ML_DS e0 (Bool b) V0
V0 : MLval
hab : Habite e0 s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (Bool b), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro comp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.

*****
comp : compilation (Bool b)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_b : ML_DS e0 (Bool b) V0
V0 : MLval
hab : Habite e0 s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
elim comp; intro hyp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.

*****
hyp : forall (e : MLenv) (V : MLval) (_ : ML_DS e (Bool b) V) \n (s : Squelette) (C : Commande) (_ : Traduction s (Bool b) C)\n (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
comp : compilation (Bool b)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_b : ML_DS e0 (Bool b) V0
V0 : MLval
hab : Habite e0 s
Trad_b : Traduction s (Bool b) C
C : Commande
s : Squelette
e0 : MLenv
b : bool
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (n : nat) (e : MLenv) (s : Squelette) (C : Commande) (_ : Traduction s (Num n) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (Num n) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_int : ML_DS e0 (Num n) V0
V0 : MLval
hab : Habite e0 s
Trad_int : Traduction s (Num n) C
C : Commande
s : Squelette
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
cut (compilation (Num n)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_int : ML_DS e0 (Num n) V0
V0 : MLval
hab : Habite e0 s
Trad_int : Traduction s (Num n) C
C : Commande
s : Squelette
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (Num n), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
2: exact (Proof_int n).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_int : ML_DS e0 (Num n) V0
V0 : MLval
hab : Habite e0 s
Trad_int : Traduction s (Num n) C
C : Commande
s : Squelette
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (Num n), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro comp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.

*****
comp : compilation (Num n)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_int : ML_DS e0 (Num n) V0
V0 : MLval
hab : Habite e0 s
Trad_int : Traduction s (Num n) C
C : Commande
s : Squelette
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
elim comp; intro hyp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.

*****
hyp : forall (e : MLenv) (V : MLval) (_ : ML_DS e (Num n) V) \n (s : Squelette) (C : Commande) (_ : Traduction s (Num n) C)\n (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
comp : compilation (Num n)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_int : ML_DS e0 (Num n) V0
V0 : MLval
hab : Habite e0 s
Trad_int : Traduction s (Num n) C
C : Commande
s : Squelette
e0 : MLenv
n : nat
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (c : OP) (e : MLenv) (s : Squelette) (C : Commande) (_ : Traduction s (op c) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (op c) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_op : ML_DS e0 (op c) V0
V0 : MLval
hab : Habite e0 s
Trad_op : Traduction s (op c) C
C : Commande
s : Squelette
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
cut (compilation (op c)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_op : ML_DS e0 (op c) V0
V0 : MLval
hab : Habite e0 s
Trad_op : Traduction s (op c) C
C : Commande
s : Squelette
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (op c), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
2: exact (Proof_op c).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_op : ML_DS e0 (op c) V0
V0 : MLval
hab : Habite e0 s
Trad_op : Traduction s (op c) C
C : Commande
s : Squelette
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (op c), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro comp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.

*****
comp : compilation (op c)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_op : ML_DS e0 (op c) V0
V0 : MLval
hab : Habite e0 s
Trad_op : Traduction s (op c) C
C : Commande
s : Squelette
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
elim comp; intro hyp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.

*****
hyp : forall (e : MLenv) (V : MLval) (_ : ML_DS e (op c) V) \n (s : Squelette) (C : Commande) (_ : Traduction s (op c) C)\n (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
comp : compilation (op c)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_op : ML_DS e0 (op c) V0
V0 : MLval
hab : Habite e0 s
Trad_op : Traduction s (op c) C
C : Commande
s : Squelette
e0 : MLenv
c : OP
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (P : Pat) (E : MLexp) (s : Squelette) (C : Commande) (_ : Traduction s (lambda P E) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (lambda P E) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_lambda : ML_DS e0 (lambda P E0) V0
V0 : MLval
hab : Habite e0 s
Trad_lam : Traduction s (lambda P E0) C
C : Commande
s : Squelette
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
cut (compilation (lambda P E0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_lambda : ML_DS e0 (lambda P E0) V0
V0 : MLval
hab : Habite e0 s
Trad_lam : Traduction s (lambda P E0) C
C : Commande
s : Squelette
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (lambda P E0), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
2: exact (Proof_abstraction E0 P).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_lambda : ML_DS e0 (lambda P E0) V0
V0 : MLval
hab : Habite e0 s
Trad_lam : Traduction s (lambda P E0) C
C : Commande
s : Squelette
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation (lambda P E0), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro comp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.

*****
comp : compilation (lambda P E0)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_lambda : ML_DS e0 (lambda P E0) V0
V0 : MLval
hab : Habite e0 s
Trad_lam : Traduction s (lambda P E0) C
C : Commande
s : Squelette
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
elim comp; intro hyp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.

*****
hyp : forall (e : MLenv) (V : MLval) (_ : ML_DS e (lambda P E0) V)\n (s : Squelette) (C : Commande) (_ : Traduction s (lambda P E0) C)\n (_ : Habite e s) (CV : CSem_val) (_ : Equiv_env e CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
comp : compilation (lambda P E0)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_lambda : ML_DS e0 (lambda P E0) V0
V0 : MLval
hab : Habite e0 s
Trad_lam : Traduction s (lambda P E0) C
C : Commande
s : Squelette
E0 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (v : MLval) (I : Pat) (_ : VAL_OF e I v) (s : Squelette) (C : Commande) (_ : Traduction s (id I) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (id I) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_pat : ML_DS e0 (id I) V0
V0 : MLval
hab : Habite e0 s
Trad_pat : Traduction s (id I) C
C : Commande
s : Squelette
VAL_I : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
cut (compilation_id (id I)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_pat : ML_DS e0 (id I) V0
V0 : MLval
hab : Habite e0 s
Trad_pat : Traduction s (id I) C
C : Commande
s : Squelette
VAL_I : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation_id (id I), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
2: exact (Proof_ident I).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).

*****
Eq : Equiv_env e0 CV
CV : CSem_val
ML_pat : ML_DS e0 (id I) V0
V0 : MLval
hab : Habite e0 s
Trad_pat : Traduction s (id I) C
C : Commande
s : Squelette
VAL_I : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : compilation_id (id I), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
intro comp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.

*****
comp : compilation_id (id I)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_pat : ML_DS e0 (id I) V0
V0 : MLval
hab : Habite e0 s
Trad_pat : Traduction s (id I) C
C : Commande
s : Squelette
VAL_I : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
elim comp; intro hyp.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.

*****
hyp : forall (e : MLenv) (s : Squelette) (_ : Habite e s) \n (V : MLval) (_ : ML_DS e (id I) V) (C : Commande)\n (_ : Traduction s (id I) C) (CV : CSem_val) (_ : Equiv_env e CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
comp : compilation_id (id I)
Eq : Equiv_env e0 CV
CV : CSem_val
ML_pat : ML_DS e0 (id I) V0
V0 : MLval
hab : Habite e0 s
Trad_pat : Traduction s (id I) C
C : Commande
s : Squelette
VAL_I : VAL_OF e0 I v
I : Pat
v : MLval
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (E1 E2 E3 : MLexp) (v : MLval) (_ : ML_DS e E1 (boolean true)) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E1 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS e E2 v) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E2 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (ite E1 E2 E3) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (ite E1 E2 E3) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.

*****
Trad_if : Traduction s (ite E1 E2 E3) C
C : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (ite E1 E2 E3) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.

*****
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (ite E1 E2 E3) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros hab V_final ML_DS_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.

*****
ML_DS_if : ML_DS e0 (ite E1 E2 E3) V_final
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
inversion_clear ML_DS_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.

*****
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val V_final x) (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros CV_final HH; elim HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.

*****
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val V_final CV_final) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros Eq_Vf_CVf CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
exists CV_final.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val V_final CV_final) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV_final s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val V_final CV_final
+++++
exact Eq_Vf_CVf.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV_final s)
+++++
intro s0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) (o push (o C1 (branch C2 C3))) (ETcons CV_final s0)
+++++
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0), CAM_DS (ETcons CV0 s0) (o push (o C1 (branch C2 C3))) (ETcons CV_final s0)
+++++
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))) (_ : CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)), CAM_DS (ETcons CV0 s0) (o push (o C1 (branch C2 C3))) (ETcons CV_final s0)
+++++
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))
+++++
exact (PUSH s0 CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val (boolean true) x) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x s))), CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
intros CV1 HH'; elim HH'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.

*****
HH' : and (Equiv_val (boolean true) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (boolean true) CV1) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s)), CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
intro Eq_1; inversion_clear Eq_1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.

*****
HH' : and (Equiv_val (boolean true) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem true)) s), CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
intro CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem true)) s)
HH' : and (Equiv_val (boolean true) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem true)) s)
HH' : and (Equiv_val (boolean true) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) C1 (ETcons (val (elem true)) (ETcons CV0 s0))
+++++
exact (CAM_C1 (ETcons CV0 s0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem true)) s)
HH' : and (Equiv_val (boolean true) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (val (elem true)) (ETcons CV0 s0)) (branch C2 C3) (ETcons CV_final s0)
+++++
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem true)) s)
HH' : and (Equiv_val (boolean true) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) C2 (ETcons CV_final s0)
+++++
exact (CAM_C2 s0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).

*****
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
cut (boolean false = boolean true).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).

*****
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (boolean false) (boolean true)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intro HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.

*****
HH : eq (boolean false) (boolean true)
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
discriminate HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.

*****
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean true)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (boolean false) (boolean true)
+++++
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (E1 E2 E3 : MLexp) (v : MLval) (_ : ML_DS e E1 (boolean false)) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E1 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS e E3 v) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E3 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (ite E1 E2 E3) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (ite E1 E2 E3) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.

*****
Trad_if : Traduction s (ite E1 E2 E3) C
C : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (ite E1 E2 E3) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.

*****
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (ite E1 E2 E3) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros hab V_final ML_DS_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.

*****
ML_DS_if : ML_DS e0 (ite E1 E2 E3) V_final
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
inversion_clear ML_DS_if.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.

*****
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
cut (boolean false = boolean true).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).

*****
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (boolean false) (boolean true)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intro HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.

*****
HH : eq (boolean false) (boolean true)
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
discriminate HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.

*****
H4 : ML_DS e0 E2 V_final
H3 : ML_DS e0 E1 (boolean true)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (boolean false) (boolean true)
+++++
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).

*****
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val V_final x) (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros CV_final HH; elim HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.

*****
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val V_final CV_final) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
intros Eq_Vf_CVf CAM_C3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.

*****
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV1 s)))
+++++
exists CV_final.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.

*****
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val V_final CV_final) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV_final s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.

*****
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val V_final CV_final
+++++
exact Eq_Vf_CVf.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.

*****
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (branch C2 C3))) (ETcons CV_final s)
+++++
intro s0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.

*****
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) (o push (o C1 (branch C2 C3))) (ETcons CV_final s0)
+++++
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).

*****
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0), CAM_DS (ETcons CV0 s0) (o push (o C1 (branch C2 C3))) (ETcons CV_final s0)
+++++
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).

*****
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))) (_ : CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)), CAM_DS (ETcons CV0 s0) (o push (o C1 (branch C2 C3))) (ETcons CV_final s0)
+++++
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).

*****
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))
+++++
exact (PUSH s0 CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).

*****
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).

*****
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val (boolean false) x) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x s))), CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
intros CV1 HH'; elim HH'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.

*****
HH' : and (Equiv_val (boolean false) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (boolean false) CV1) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s)), CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
intro Eq_1; inversion_clear Eq_1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.

*****
HH' : and (Equiv_val (boolean false) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem false)) s), CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
intro CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem false)) s)
HH' : and (Equiv_val (boolean false) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem false)) s)
HH' : and (Equiv_val (boolean false) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) C1 (ETcons (val (elem false)) (ETcons CV0 s0))
+++++
exact (CAM_C1 (ETcons CV0 s0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem false)) s)
HH' : and (Equiv_val (boolean false) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (val (elem false)) (ETcons CV0 s0)) (branch C2 C3) (ETcons CV_final s0)
+++++
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (elem false)) s)
HH' : and (Equiv_val (boolean false) CV1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV1 s))
CV1 : CSem_val
s0 : Etat
CAM_C3 : forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s)
Eq_Vf_CVf : Equiv_val V_final CV_final
HH : and (Equiv_val V_final CV_final)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C3 (ETcons CV_final s))
CV_final : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS e0 E3 V_final
H3 : ML_DS e0 E1 (boolean false)
V_final : MLval
hab : Habite e0 s
H2 : Traduction s E3 C3
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2,C3 : Commande
s : Squelette
hyp_E3 : forall (s : Squelette) (C : Commande) (_ : Traduction s E3 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E3 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E3 : ML_DS e0 E3 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (boolean false)
v : MLval
E1,E2,E3 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) C3 (ETcons CV_final s0)
+++++
exact (CAM_C3 s0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E1 u) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E1 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS e E2 v) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E2 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (mlpair E1 E2) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (mlpair E1 E2) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.

*****
Trad_p : Traduction s (mlpair E1 E2) C
C : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (mlpair E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_p.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.

*****
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (mlpair E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
intros hab V_final ML_DS_pair.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.

*****
ML_DS_pair : ML_DS e0 (mlpair E1 E2) V_final
V_final : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V_final CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
inversion_clear ML_DS_pair.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.

*****
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val u0 x) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
intros CV_E1 HH; elim HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.

*****
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val u0 CV_E1) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)), ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
intros eq_u0_CV_E1 CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val v0 x) (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
intros CV_E2 HH'; elim HH'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.

*****
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val v0 CV_E2) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)), ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
intros eq_v0_CV_E2 CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (valpair u0 v0) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons CV1 s)))
+++++
exists (Cam_pair CV_E1 CV_E2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val (valpair u0 v0) (Cam_pair CV_E1 CV_E2)) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons (Cam_pair CV_E1 CV_E2) s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val (valpair u0 v0) (Cam_pair CV_E1 CV_E2)
+++++
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 cons)))) (ETcons (Cam_pair CV_E1 CV_E2) s)
+++++
intro s0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) (o push (o C1 (o swap (o C2 cons)))) (ETcons (Cam_pair CV_E1 CV_E2) s0)
+++++
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))
+++++
apply (PUSH s0 CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (o swap (o C2 cons))) (ETcons (Cam_pair CV_E1 CV_E2) s0)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 s0)) C1 (ETcons CV_E1 (ETcons CV0 s0))
+++++
apply CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E1 (ETcons CV0 s0)) (o swap (o C2 cons)) (ETcons (Cam_pair CV_E1 CV_E2) s0)
+++++
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E1 (ETcons CV0 s0)) swap (ETcons CV0 (ETcons CV_E1 s0))
+++++
apply SWAP.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV_E1 s0)) (o C2 cons) (ETcons (Cam_pair CV_E1 CV_E2) s0)
+++++
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV_E1 s0)) C2 (ETcons CV_E2 (ETcons CV_E1 s0))
+++++
apply CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.

*****
s0 : Etat
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_v0_CV_E2 : Equiv_val v0 CV_E2
HH' : and (Equiv_val v0 CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_u0_CV_E1 : Equiv_val u0 CV_E1
HH : and (Equiv_val u0 CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS e0 E2 v0
H2 : ML_DS e0 E1 u0
V_final,u0,v0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 v
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 u
u,v : MLval
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E2 (ETcons CV_E1 s0)) cons (ETcons (Cam_pair CV_E1 CV_E2) s0)
+++++
apply CONS.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e e1 : MLenv) (P : Pat) (E E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E1 (Clos P E e1)) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E1 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS e E2 u) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E2 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS (Econs P u e1) E v) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E C) (_ : Habite (Econs P u e1) s) (V : MLval) (_ : ML_DS (Econs P u e1) E V) (CV : CSem_val) (_ : Equiv_env (Econs P u e1) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (appl E1 E2) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.

*****
Trad_appl : Traduction s (appl E1 E2) C
C : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.

*****
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros hab V0 ML_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.

*****
ML_appl : ML_DS e0 (appl E1 E2) V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear ML_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.

*****
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Clos P E0 e1 = Clos P0 E3 e3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).

*****
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (Clos P E0 e1) (Clos P0 E3 e3)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH1; injection HH1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.

*****
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq e1 e3) (_ : eq E0 E3) (_ : eq P P0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq1 eq2 eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.

*****
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (u = u0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).

*****
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq u u0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.

*****
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (ML_DS (Econs P0 u0 e3) E3 V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).

*****
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : ML_DS (Econs P0 u0 e3) E3 V0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.

*****
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : ML_DS (Econs P u e1) E0 V0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH2; cut (v = V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).

*****
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq v V0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq5; try rewrite <- eq5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.

*****
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val u x) (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CVal_E2 HH3; elim HH3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.

*****
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val u CVal_E2) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros Eq_u_Cval_E2 CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val (Clos P E0 e1) x) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros Closure HH4; elim HH4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.

*****
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (Clos P E0 e1) Closure) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq_clos.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.

*****
eq_clos : Equiv_val (Clos P E0 e1) Closure
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear eq_clos.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.

*****
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Habite (Econs P u e1) (cons_squelette P s0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : Habite (Econs P u e1) (cons_squelette P s0), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro hab_P_e1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.

*****
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).

*****
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq_env_closure.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.

*****
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).

*****
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val v x) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV_final HH5; elim HH5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.

*****
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val v CV_final) (_ : forall s : Etat, CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq_v_CV_final CAM_C0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
exists CV_final.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val v CV_final) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV_final s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val v CV_final
+++++
exact eq_v_CV_final.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV_final s)
+++++
intro sq.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 sq) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV_final sq)
+++++
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 sq) push (ETcons CV0 (ETcons CV0 sq))
+++++
apply PUSH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 sq)) (o C1 (o swap (o C2 (o cons app)))) (ETcons CV_final sq)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 sq)) C1 (ETcons (Cam_clos C0 CV) (ETcons CV0 sq))
+++++
apply CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (o swap (o C2 (o cons app))) (ETcons CV_final sq)
+++++
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) swap (ETcons CV0 (ETcons (Cam_clos C0 CV) sq))
+++++
apply SWAP.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (o C2 (o cons app)) (ETcons CV_final sq)
+++++
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) C2 (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq))
+++++
apply CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (o cons app) (ETcons CV_final sq)
+++++
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) cons (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq)
+++++
apply CONS.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) app (ETcons CV_final sq)
+++++
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).

*****
sq : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s)
eq_v_CV_final : Equiv_val v CV_final
HH5 : and (Equiv_val v CV_final)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV CVal_E2) s) C0 (ETcons CV_final s))
CV_final : CSem_val
eq_env_closure : Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair CV CVal_E2) sq) C0 (ETcons CV_final sq)
+++++
apply CAM_C0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.

*****
hab_P_e1 : Habite (Econs P u e1) (cons_squelette P s0)
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)
+++++
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos C0 CV) s)
H7 : Traduction (cons_squelette P s0) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
s0 : Squelette
CV : CSem_val
C0 : Commande
HH4 : and (Equiv_val (Clos P E0 e1) Closure)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Closure s))
Closure : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s)
Eq_u_Cval_E2 : Equiv_val u CVal_E2
HH3 : and (Equiv_val u CVal_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CVal_E2 s))
CVal_E2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq5 : eq v V0
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Habite (Econs P u e1) (cons_squelette P s0)
+++++
apply (cons_habite P u e1 s0 H6).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).

*****
HH2 : ML_DS (Econs P u e1) E0 V0
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).

*****
eq4 : eq u u0
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ML_DS (Econs P0 u0 e3) E3 V0
+++++
exact H4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.

*****
eq3 : eq P P0
eq2 : eq E0 E3
eq1 : eq e1 e3
HH1 : eq (Clos P E0 e1) (Clos P0 E3 e3)
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq u u0
+++++
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).

*****
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (Clos P E0 e1) (Clos P0 E3 e3)
+++++
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).

*****
H4 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).

*****
H4 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (Clos P E0 e1) (Clos_rec x E3 P0 e3)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro hyp_not; discriminate hyp_not.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.

*****
H4 : ML_DS (Econs x u0 (Econs P0 (Clos_rec x E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x E3 P0 e3)
u0 : MLval
E3 : MLexp
x,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (Clos P E0 e1) (Clos_rec x E3 P0 e3)
+++++
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).

*****
H3 : ML_DS e0 E2 (valpair (num n) (num m))
H2 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Clos P E0 e1 = OP_clos c).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).

*****
H3 : ML_DS e0 E2 (valpair (num n) (num m))
H2 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (Clos P E0 e1) (OP_clos c)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro hyp_not; discriminate hyp_not.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.

*****
H3 : ML_DS e0 E2 (valpair (num n) (num m))
H2 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs P u e1) s) (V : MLval)\n (_ : ML_DS (Econs P u e1) E0 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e1) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs P u e1) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos P E0 e1)
u,v : MLval
E0,E1,E2 : MLexp
P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (Clos P E0 e1) (OP_clos c)
+++++
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e e1 : MLenv) (x P : Pat) (E E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E1 (Clos_rec x E P e1)) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E1 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS e E2 u) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E2 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS (Econs x u (Econs P (Clos_rec x E P e1) e1)) E v) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E C) (_ : Habite (Econs x u (Econs P (Clos_rec x E P e1) e1)) s) (V : MLval) (_ : ML_DS (Econs x u (Econs P (Clos_rec x E P e1) e1)) E V) (CV : CSem_val) (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E P e1) e1)) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (appl E1 E2) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.

*****
Trad_appl : Traduction s (appl E1 E2) C
C : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.

*****
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros hab V0 ML_app.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.

*****
ML_app : ML_DS e0 (appl E1 E2) V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear ML_app.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.

*****
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).

*****
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (Clos_rec x E0 P e1) (Clos P0 E3 e3)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH1; discriminate HH1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.

*****
H4 : ML_DS (Econs P0 u0 e3) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos P0 E3 e3)
u0 : MLval
E3 : MLexp
P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (Clos_rec x E0 P e1) (Clos P0 E3 e3)
+++++
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).

*****
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH1; injection HH1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.

*****
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq e1 e3) (_ : eq P P0) (_ : eq E0 E3) (_ : eq x x0), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq1 eq2 eq3 eq4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.

*****
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).

*****
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0, ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.

*****
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs x u0 (Econs P (Clos_rec x E0 P e1) e1)) E0 V0, ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (u = u0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).

*****
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq u u0) (_ : ML_DS (Econs x u0 (Econs P (Clos_rec x E0 P e1) e1)) E0 V0), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq5; try rewrite <- eq5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.

*****
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0, ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro ML_E0'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.

*****
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (v = V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).

*****
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq v V0, ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq6; try rewrite <- eq6.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.

*****
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).

*****
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val u x) (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV_E2 HH3; elim HH3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.

*****
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val u CV_E2) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq_u_CV_E2 CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).

*****
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x0 : CSem_val) (_ : and (Equiv_val (Clos_rec x E0 P e1) x0) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x0 s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV_E1 HH2; elim HH2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.

*****
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (Clos_rec x E0 P e1) CV_E1) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq_V1_CV_E1 CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
simple inversion eq_V1_CV_E1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.

*****
H6 : eq (val (elem b)) CV_E1
H5 : eq (boolean b) (Clos_rec x E0 P e1)
b : bool
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
discriminate H5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.

*****
H6 : eq (val (int n)) CV_E1
H5 : eq (num n) (Clos_rec x E0 P e1)
n : nat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
discriminate H5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.

*****
H6 : eq (val (def_op c)) CV_E1
H5 : eq (OP_clos c) (Clos_rec x E0 P e1)
c : OP
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
discriminate H5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.

*****
H8 : eq (Cam_pair Cval1 Cval2) CV_E1
H7 : eq (valpair V1 V2) (Clos_rec x E0 P e1)
Cval1,Cval2 : CSem_val
V1,V2 : MLval
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val V1 Cval1) (_ : Equiv_val V2 Cval2), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
discriminate H7.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.

*****
H9 : eq (Cam_clos C0 CV) CV_E1
H8 : eq (Clos p E4 e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
e2 : MLenv
C0 : Commande
E4 : MLexp
p : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_env e2 CV) (_ : Habite e2 s0) (_ : Traduction (cons_squelette p s0) E4 C0), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
discriminate H8.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.

*****
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_env e2 CV) (_ : Habite e2 s0) (_ : Traduction (cons_squelette x1 (cons_squelette p s0)) E4 C0), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
injection H8.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.

*****
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq e2 e1) (_ : eq p P) (_ : eq E4 E0) (_ : eq x1 x) (_ : Equiv_env e2 CV) (_ : Habite e2 s0) (_ : Traduction (cons_squelette x1 (cons_squelette p s0)) E4 C0), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq7 eq8 eq9 eq10.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.

*****
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_env e2 CV) (_ : Habite e2 s0) (_ : Traduction (cons_squelette x1 (cons_squelette p s0)) E4 C0), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.

*****
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_env e1 CV) (_ : Habite e1 s0) (_ : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.

*****
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).

*****
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro hab0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.

*****
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).

*****
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro Eq_env0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.

*****
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).

*****
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val v x) (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV_E0 HH4; elim HH4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.

*****
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val v CV_E0) (_ : forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq_v_CV_E0 CAM_C0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
exists CV_E0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val v CV_E0) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV_E0 s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val v CV_E0
+++++
exact eq_v_CV_E0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.

*****
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV_E0 s)
+++++
intro S.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV_E0 S)
+++++
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) push (ETcons CV0 (ETcons CV0 S))
+++++
apply PUSH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) (o C1 (o swap (o C2 (o cons app)))) (ETcons CV_E0 S)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) C1 (ETcons CV_E1 (ETcons CV0 S))
+++++
apply CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E1 (ETcons CV0 S)) (o swap (o C2 (o cons app))) (ETcons CV_E0 S)
+++++
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E1 (ETcons CV0 S)) swap (ETcons CV0 (ETcons CV_E1 S))
+++++
apply SWAP.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV_E1 S)) (o C2 (o cons app)) (ETcons CV_E0 S)
+++++
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV_E1 S)) C2 (ETcons CV_E2 (ETcons CV_E1 S))
+++++
apply CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E2 (ETcons CV_E1 S)) (o cons app) (ETcons CV_E0 S)
+++++
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_E2 (ETcons CV_E1 S)) cons (ETcons (Cam_pair CV_E1 CV_E2) S)
+++++
apply CONS.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair CV_E1 CV_E2) S) app (ETcons CV_E0 S)
+++++
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s), CAM_DS (ETcons (Cam_pair CV_E1 CV_E2) S) app (ETcons CV_E0 S)
+++++
2: auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s), CAM_DS (ETcons (Cam_pair CV_E1 CV_E2) S) app (ETcons CV_E0 S)
+++++
try rewrite <- H9.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.

*****
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV (Cam_clos_rec C0 CV)) CV_E2) s) C0 (ETcons CV_E0 s), CAM_DS (ETcons (Cam_pair (Cam_clos_rec C0 CV) CV_E2) S) app (ETcons CV_E0 S)
+++++
intro Good_CAM_C0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.

*****
Good_CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV (Cam_clos_rec C0 CV)) CV_E2) s)\n C0 (ETcons CV_E0 s)
S : Etat
CAM_C0 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s)
eq_v_CV_E0 : Equiv_val v CV_E0
HH4 : and (Equiv_val v CV_E0)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0\n (ETcons CV_E0 s))
CV_E0 : CSem_val
Eq_env0 : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (Cam_pair (Cam_pair CV CV_E1) CV_E2)
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair (Cam_clos_rec C0 CV) CV_E2) S) app (ETcons CV_E0 S)
+++++
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).

*****
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)
+++++
apply Eqenv2; auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.

*****
hab0 : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1))\n (cons_squelette x (cons_squelette P s0))
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_env (Econs P (Clos_rec x E0 P e1) e1) (Cam_pair CV CV_E1)
+++++
apply Eqenv2; auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.

*****
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))
+++++
apply cons_habite; auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.

*****
H7 : Traduction (cons_squelette x (cons_squelette P s0)) E0 C0
H6 : Habite e1 s0
H5 : Equiv_env e1 CV
eq10 : eq x1 x
eq9 : eq E4 E0
eq8 : eq p P
eq7 : eq e2 e1
H9 : eq (Cam_clos_rec C0 CV) CV_E1
H8 : eq (Clos_rec x1 E4 p e2) (Clos_rec x E0 P e1)
s0 : Squelette
CV : CSem_val
C0 : Commande
e2 : MLenv
E4 : MLexp
p,x1 : Pat
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s)
eq_V1_CV_E1 : Equiv_val (Clos_rec x E0 P e1) CV_E1
HH2 : and (Equiv_val (Clos_rec x E0 P e1) CV_E1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_E1 s))
CV_E1 : CSem_val
CAM_C2 : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s)
eq_u_CV_E2 : Equiv_val u CV_E2
HH3 : and (Equiv_val u CV_E2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_E2 s))
CV_E2 : CSem_val
eq6 : eq v V0
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Habite (Econs P (Clos_rec x E0 P e1) e1) (cons_squelette P s0)
+++++
apply cons_habite; auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.

*****
ML_E0' : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V0
eq5 : eq u u0
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').

*****
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq u u0
+++++
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).

*****
eq4 : eq x x0
eq3 : eq E0 E3
eq2 : eq P P0
eq1 : eq e1 e3
HH1 : eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
+++++
auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0
H3 : ML_DS e0 E2 u0
H2 : ML_DS e0 E1 (Clos_rec x0 E3 P0 e3)
u0 : MLval
E3 : MLexp
x0,P0 : Pat
e3 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (Clos_rec x E0 P e1) (Clos_rec x0 E3 P0 e3)
+++++
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).

*****
H3 : ML_DS e0 E2 (valpair (num n) (num m))
H2 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (OP_clos c = Clos_rec x E0 P e1).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).

*****
H3 : ML_DS e0 E2 (valpair (num n) (num m))
H2 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (OP_clos c) (Clos_rec x E0 P e1)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro Hyp_false; discriminate Hyp_false.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.

*****
H3 : ML_DS e0 E2 (valpair (num n) (num m))
H2 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E0 : forall (s : Squelette) (C : Commande) (_ : Traduction s E0 C)\n (_ : Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) s)\n (V : MLval)\n (_ : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 V)\n (CV : CSem_val)\n (_ : Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E0 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (Clos_rec x E0 P e1)
u,v : MLval
E0,E1,E2 : MLexp
x,P : Pat
e0,e1 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (OP_clos c) (Clos_rec x E0 P e1)
+++++
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (E1 E2 : MLexp) (n m : nat) (c : OP) (_ : ML_DS e E1 (OP_clos c)) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E1 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS e E2 (valpair (num n) (num m))) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E2 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (appl E1 E2) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.

*****
Trad_appl : Traduction s (appl E1 E2) C
C : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.

*****
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (appl E1 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros hab V0 ML_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.

*****
ML_appl : ML_DS e0 (appl E1 E2) V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear ML_appl.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.

*****
H4 : ML_DS (Econs P u e2) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs P u e2) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (OP_clos c = Clos P E0 e2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs P u e2) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq (OP_clos c) (Clos P E0 e2), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H4 : ML_DS (Econs P u e2) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos P E0 e2)
u : MLval
E0 : MLexp
P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq (OP_clos c) (Clos P E0 e2), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH; discriminate HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.

*****
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (OP_clos c = Clos_rec x E0 P e2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).

*****
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (OP_clos c) (Clos_rec x E0 P e2)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).

*****
H4 : ML_DS (Econs x u (Econs P (Clos_rec x E0 P e2) e2)) E0 V0
H3 : ML_DS e0 E2 u
H2 : ML_DS e0 E1 (Clos_rec x E0 P e2)
u : MLval
E0 : MLexp
x,P : Pat
e2 : MLenv
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (OP_clos c) (Clos_rec x E0 P e2)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH; discriminate HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.

*****
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).

*****
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).

*****
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH; injection HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.

*****
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq m m0) (_ : eq n n0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq1 eq2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.

*****
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
cut (OP_clos c = OP_clos c0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).

*****
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq (OP_clos c) (OP_clos c0)) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH1; injection HH1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.

*****
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq c c0) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.

*****
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c0 n0 m0)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.

*****
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val (OP_clos c) x) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH2; elim HH2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.

*****
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (v : Value) (_ : and (Equiv_val (OP_clos c) (val v)) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val v) s))), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV_c HH3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.

*****
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim HH3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.

*****
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (OP_clos c) (val CV_c)) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros eq_c_CV_c CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val (valpair (num n) (num m)) x) (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros CV_nm HH4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.

*****
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim HH4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.

*****
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (valpair (num n) (num m)) CV_nm) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro eq_nm_CV_nm.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.

*****
eq_nm_CV_nm : Equiv_val (valpair (num n) (num m)) CV_nm
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear eq_nm_CV_nm.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.

*****
H5 : Equiv_val (num m) Cval2
H4 : Equiv_val (num n) Cval1
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons (Cam_pair Cval1 Cval2) s), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear H4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.

*****
H5 : Equiv_val (num m) Cval2
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons (Cam_pair (val (int n)) Cval2) s), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
inversion_clear H5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.

*****
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons (Cam_pair (val (int n)) (val (int m))) s), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
exists (val (int (eval_op c n m))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val (num (eval_op c n m)) (val (int (eval_op c n m)))) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons (val (int (eval_op c n m))) s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val (num (eval_op c n m)) (val (int (eval_op c n m)))
+++++
exact (Eqnum (eval_op c n m)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons (val (int (eval_op c n m))) s)
+++++
intro S.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons (val (int (eval_op c n m))) S)
+++++
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) push (ETcons CV0 (ETcons CV0 S))
+++++
apply PUSH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) (o C1 (o swap (o C2 (o cons app)))) (ETcons (val (int (eval_op c n m))) S)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) C1 (ETcons (val CV_c) (ETcons CV0 S))
+++++
apply CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (val CV_c) (ETcons CV0 S)) (o swap (o C2 (o cons app))) (ETcons (val (int (eval_op c n m))) S)
+++++
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (val CV_c) (ETcons CV0 S)) swap (ETcons CV0 (ETcons (val CV_c) S))
+++++
apply SWAP.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons (val CV_c) S)) (o C2 (o cons app)) (ETcons (val (int (eval_op c n m))) S)
+++++
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons (val CV_c) S)) C2 (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S))
+++++
apply CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (o cons app) (ETcons (val (int (eval_op c n m))) S)
+++++
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s), CAM_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (o cons app) (ETcons (val (int (eval_op c n m))) S)
+++++
2: auto.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
eq_c_CV_c : Equiv_val (OP_clos c) (val CV_c)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s), CAM_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (o cons app) (ETcons (val (int (eval_op c n m))) S)
+++++
inversion_clear eq_c_CV_c.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (def_op c)) s), CAM_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (o cons app) (ETcons (val (int (eval_op c n m))) S)
+++++
intro U_CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.

*****
U_CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (def_op c)) s)
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (o cons app) (ETcons (val (int (eval_op c n m))) S)
+++++
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).

*****
U_CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (def_op c)) s)
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) cons (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S)
+++++
apply CONS.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.

*****
U_CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val (def_op c)) s)
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons CV0 s) C2\n (ETcons (Cam_pair (val (int n)) (val (int m))) s)
Cval1,Cval2 : CSem_val
HH4 : and (Equiv_val (valpair (num n) (num m)) CV_nm)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C2 (ETcons CV_nm s))
CV_nm : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)
HH3 : and (Equiv_val (OP_clos c) (val CV_c))\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s))
CV_c : Value
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) app (ETcons (val (int (eval_op c n m))) S)
+++++
apply (APPcam_op S n m c).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).

*****
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (c0 : CSem_val) (_ : forall _ : and (Equiv_val (OP_clos c) c0) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c0 s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))) (c1 : CSem_val) (_ : forall _ : and (Equiv_val (OP_clos c) c1) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c1 s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))) (_ : and (Equiv_val (OP_clos c) (Cam_pair c0 c1)) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_pair c0 c1) s))), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.

*****
H6 : and (Equiv_val (OP_clos c) (Cam_pair c1 c2))\n (forall s : Etat,\n CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_pair c1 c2) s))
H5 : forall\n _ : and (Equiv_val (OP_clos c) c2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c2 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
c2 : CSem_val
H4 : forall\n _ : and (Equiv_val (OP_clos c) c1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c1 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
HH2,c1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim H6.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.

*****
H6 : and (Equiv_val (OP_clos c) (Cam_pair c1 c2))\n (forall s : Etat,\n CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_pair c1 c2) s))
H5 : forall\n _ : and (Equiv_val (OP_clos c) c2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c2 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
c2 : CSem_val
H4 : forall\n _ : and (Equiv_val (OP_clos c) c1)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c1 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
HH2,c1 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (OP_clos c) (Cam_pair c1 c2)) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_pair c1 c2) s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH5; inversion_clear HH5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.

*****
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (c0 : Commande) (c1 : CSem_val) (_ : forall _ : and (Equiv_val (OP_clos c) c1) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c1 s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))) (_ : and (Equiv_val (OP_clos c) (Cam_clos c0 c1)) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos c0 c1) s))), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.

*****
H5 : and (Equiv_val (OP_clos c) (Cam_clos c1 c2))\n (forall s : Etat,\n CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos c1 c2) s))
H4 : forall\n _ : and (Equiv_val (OP_clos c) c2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c2 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
c2 : CSem_val
c1 : Commande
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim H5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.

*****
H5 : and (Equiv_val (OP_clos c) (Cam_clos c1 c2))\n (forall s : Etat,\n CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos c1 c2) s))
H4 : forall\n _ : and (Equiv_val (OP_clos c) c2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c2 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
c2 : CSem_val
c1 : Commande
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (OP_clos c) (Cam_clos c1 c2)) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos c1 c2) s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH5; inversion_clear HH5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.

*****
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (c0 : Commande) (c1 : CSem_val) (_ : forall _ : and (Equiv_val (OP_clos c) c1) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c1 s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))) (_ : and (Equiv_val (OP_clos c) (Cam_clos_rec c0 c1)) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos_rec c0 c1) s))), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.

*****
H5 : and (Equiv_val (OP_clos c) (Cam_clos_rec c1 c2))\n (forall s : Etat,\n CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos_rec c1 c2) s))
H4 : forall\n _ : and (Equiv_val (OP_clos c) c2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c2 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
c2 : CSem_val
c1 : Commande
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim H5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.

*****
H5 : and (Equiv_val (OP_clos c) (Cam_clos_rec c1 c2))\n (forall s : Etat,\n CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos_rec c1 c2) s))
H4 : forall\n _ : and (Equiv_val (OP_clos c) c2)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons c2 s)),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val (num (eval_op c n m)) CV1)\n (forall s : Etat,\n CAM_DS (ETcons CV0 s)\n (o push (o C1 (o swap (o C2 (o cons app))))) \n (ETcons CV1 s)))
c2 : CSem_val
c1 : Commande
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (OP_clos c) (Cam_clos_rec c1 c2)) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (Cam_clos_rec c1 c2) s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH5; inversion_clear HH5.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.

*****
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : and (Equiv_val (OP_clos c) Cam_nil) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Cam_nil s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intros.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.

*****
H4 : and (Equiv_val (OP_clos c) Cam_nil)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Cam_nil s))
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
elim H4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.

*****
H4 : and (Equiv_val (OP_clos c) Cam_nil)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Cam_nil s))
HH2 : CSem_val
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
eq3 : eq c c0
HH1 : eq (OP_clos c) (OP_clos c0)
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val (OP_clos c) Cam_nil) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons Cam_nil s)), ex (fun CV1 : CSem_val => and (Equiv_val (num (eval_op c n m)) CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o swap (o C2 (o cons app))))) (ETcons CV1 s)))
+++++
intro HH4; inversion_clear HH4.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.

*****
eq2 : eq n n0
eq1 : eq m m0
HH : eq (valpair (num n) (num m)) (valpair (num n0) (num m0))
H3 : ML_DS e0 E2 (valpair (num n0) (num m0))
H2 : ML_DS e0 E1 (OP_clos c0)
c0 : OP
n0,m0 : nat
V0 : MLval
hab : Habite e0 s
H1 : Traduction s E2 C2
H0 : Traduction s E1 C1
C,C1,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 (valpair (num n) (num m))
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E1 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS e0 E1 (OP_clos c)
c : OP
n,m : nat
E1,E2 : MLexp
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq (OP_clos c) (OP_clos c0)
+++++
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (P : Pat) (E1 E2 : MLexp) (u v : MLval) (_ : ML_DS e E2 u) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite e s) (V : MLval) (_ : ML_DS e E2 V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (_ : ML_DS (Econs P u e) E1 v) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C) (_ : Habite (Econs P u e) s) (V : MLval) (_ : ML_DS (Econs P u e) E1 V) (CV : CSem_val) (_ : Equiv_env (Econs P u e) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (let' P E2 E1) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (let' P E2 E1) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.

*****
Trad_let' : Traduction s (let' P E2 E1) C
C : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (let' P E2 E1) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_let'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.

*****
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (let' P E2 E1) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros hab V0 ML_let.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.

*****
ML_let : ML_DS e0 (let' P E2 E1) V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
inversion_clear ML_let.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.

*****
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
cut (u = u0); cut (v = V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : eq v V0) (_ : eq u u0), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros eq1 eq2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.

*****
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
try rewrite <- eq1; try rewrite <- eq2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.

*****
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).

*****
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val u x) (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros CV_u HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.

*****
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
elim HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.

*****
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val u CV_u) (_ : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros eq_u_CV_u CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).

*****
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val v x) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros CV_v HH2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.

*****
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
elim HH2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.

*****
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val v CV_v) (_ : forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)), ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
intros eq_v_CV_v CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val v CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV1 s)))
+++++
exists CV_v.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val v CV_v) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV_v s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val v CV_v
+++++
exact eq_v_CV_v.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o C1 (o cons C2))) (ETcons CV_v s)
+++++
intro S.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) (o push (o C1 (o cons C2))) (ETcons CV_v S)
+++++
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) push (ETcons CV0 (ETcons CV0 S))
+++++
apply PUSH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) (o C1 (o cons C2)) (ETcons CV_v S)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) C1 (ETcons CV_u (ETcons CV0 S))
+++++
apply CAM_C1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_u (ETcons CV0 S)) (o cons C2) (ETcons CV_v S)
+++++
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV_u (ETcons CV0 S)) cons (ETcons (Cam_pair CV0 CV_u) S)
+++++
apply CONS.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s)
eq_v_CV_v : Equiv_val v CV_v
HH2 : and (Equiv_val v CV_v)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 CV_u) s) C2 (ETcons CV_v s))
CV_v : CSem_val
CAM_C1 : forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons CV_u s))
CV_u : CSem_val
eq2 : eq u u0
eq1 : eq v V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair CV0 CV_u) S) C2 (ETcons CV_v S)
+++++
apply CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
cut (u = u0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq u u0, eq v V0
+++++
intro eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
cut (ML_DS (Econs P u0 e0) E1 V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs P u0 e0) E1 V0, eq v V0
+++++
2: exact H3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs P u0 e0) E1 V0, eq v V0
+++++
try rewrite <- eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs P u e0) E1 V0, eq v V0
+++++
intro ML_E1'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.

*****
ML_E1' : ML_DS (Econs P u e0) E1 V0
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq u u0
+++++
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq v V0, eq u u0
+++++
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
cut (u = u0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq u u0, eq v V0
+++++
intro eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
cut (ML_DS (Econs P u0 e0) E1 V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs P u0 e0) E1 V0, eq v V0
+++++
2: exact H3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs P u0 e0) E1 V0, eq v V0
+++++
try rewrite <- eq3.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.

*****
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : ML_DS (Econs P u e0) E1 V0, eq v V0
+++++
intro ML_E1'.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.

*****
ML_E1' : ML_DS (Econs P u e0) E1 V0
eq3 : eq u u0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq v V0
+++++
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H3 : ML_DS (Econs P u0 e0) E1 V0
H2 : ML_DS e0 E2 u0
V0,u0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E1 C2
H0 : Traduction s E2 C1
C,C1,C2 : Commande
s : Squelette
hyp_E1 : forall (s : Squelette) (C : Commande) (_ : Traduction s E1 C)\n (_ : Habite (Econs P u e0) s) (V : MLval)\n (_ : ML_DS (Econs P u e0) E1 V) (CV : CSem_val)\n (_ : Equiv_env (Econs P u e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E1 : ML_DS (Econs P u e0) E1 v
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 E2 V) \n (CV : CSem_val) (_ : Equiv_env e0 CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS e0 E2 u
u,v : MLval
E1,E2 : MLexp
P : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq u u0
+++++
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).

*****
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (e : MLenv) (P x : Pat) (E E2 : MLexp) (u : MLval) (_ : ML_DS (Econs P (Clos_rec x E P e) e) E2 u) (_ : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C) (_ : Habite (Econs P (Clos_rec x E P e) e) s) (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E P e) e) E2 V) (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E P e) e) CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))) (s : Squelette) (C : Commande) (_ : Traduction s (letrec P x E E2) C) (_ : Habite e s) (V : MLval) (_ : ML_DS e (letrec P x E E2) V) (CV : CSem_val) (_ : Equiv_env e CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
+++++
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.

*****
Trad_letrec : Traduction s (letrec P x E0 E2) C
C : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (letrec P x E0 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)))
+++++
inversion_clear Trad_letrec.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.

*****
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Habite e0 s) (V : MLval) (_ : ML_DS e0 (letrec P x E0 E2) V) (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
intros hab V0 ML_letrec.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.

*****
ML_letrec : ML_DS e0 (letrec P x E0 E2) V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
inversion_clear ML_letrec.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.

*****
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (CV : CSem_val) (_ : Equiv_env e0 CV), ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
intros CV0 eq_e0_CV0.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
cut (u = V0).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall _ : eq u V0, ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
intro eq1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.

*****
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val V0 CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
try rewrite <- eq1.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.

*****
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val u CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).

*****
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (x : CSem_val) (_ : and (Equiv_val u x) (forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2 (ETcons x s))), ex (fun CV1 : CSem_val => and (Equiv_val u CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
intros CV_u HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.

*****
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val u CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
elim HH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.

*****
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall (_ : Equiv_val u CV_u) (_ : forall s : Etat, CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2 (ETcons CV_u s)), ex (fun CV1 : CSem_val => and (Equiv_val u CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
intros eq_u_CV_u CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
ex (fun CV1 : CSem_val => and (Equiv_val u CV1) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV1 s)))
+++++
exists CV_u.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
and (Equiv_val u CV_u) (forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV_u s))
+++++
split.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
Equiv_val u CV_u
+++++
exact eq_u_CV_u.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.

*****
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
forall s : Etat, CAM_DS (ETcons CV0 s) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV_u s)
+++++
intro S.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) (o push (o (cur_rec C0) (o cons C2))) (ETcons CV_u S)
+++++
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 S) push (ETcons CV0 (ETcons CV0 S))
+++++
apply PUSH.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) (o (cur_rec C0) (o cons C2)) (ETcons CV_u S)
+++++
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons CV0 (ETcons CV0 S)) (cur_rec C0) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S))
+++++
apply CUR_REC.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).
apply CUR_REC.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (o cons C2) (ETcons CV_u S)
+++++
apply (o_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S) (ETcons CV_u S) cons C2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).
apply CUR_REC.
apply (o_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S) (ETcons CV_u S) cons C2).

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) cons (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S)
+++++
apply CONS.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).
apply CUR_REC.
apply (o_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S) (ETcons CV_u S) cons C2).
apply CONS.

*****
S : Etat
CAM_C2 : forall s : Etat,\nCAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s)
eq_u_CV_u : Equiv_val u CV_u
HH : and (Equiv_val u CV_u)\n (forall s : Etat,\n CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) s) C2\n (ETcons CV_u s))
CV_u : CSem_val
eq1 : eq u V0
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
CAM_DS (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S) C2 (ETcons CV_u S)
+++++
apply CAM_C2.
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).
apply CUR_REC.
apply (o_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S) (ETcons CV_u S) cons C2).
apply CONS.
apply CAM_C2.

*****
eq_e0_CV0 : Equiv_env e0 CV0
CV0 : CSem_val
H2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V0
V0 : MLval
hab : Habite e0 s
H1 : Traduction (cons_squelette P s) E2 C2
H0 : Traduction (cons_squelette x (cons_squelette P s)) E0 C0
C,C0,C2 : Commande
s : Squelette
hyp_E2 : forall (s : Squelette) (C : Commande) (_ : Traduction s E2 C)\n (_ : Habite (Econs P (Clos_rec x E0 P e0) e0) s) \n (V : MLval) (_ : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 V)\n (CV : CSem_val) (_ : Equiv_env (Econs P (Clos_rec x E0 P e0) e0) CV),\nex\n (fun CV1 : CSem_val =>\n and (Equiv_val V CV1)\n (forall s0 : Etat, CAM_DS (ETcons CV s0) C (ETcons CV1 s0)))
ML_E2 : ML_DS (Econs P (Clos_rec x E0 P e0) e0) E2 u
u : MLval
E0,E2 : MLexp
P,x : Pat
e0 : MLenv
H : ML_DS e E V
V : MLval
e : MLenv
E : MLexp
*****
eq u V0
+++++
apply (ML_DS_determ (Econs P (Clos_rec x E0 P e0) e0) E2 u ML_E2 V0 H2).
-----
Lemma final_proof : forall (E : MLexp) (e : MLenv) (V : MLval), ML_DS e E V -> forall (s : Squelette) (C : Commande), Traduction s E C -> Habite e s -> forall V : MLval, ML_DS e E V -> forall CV : CSem_val, Equiv_env e CV -> exists CV1 : CSem_val, Equiv_val V CV1 /\\ (forall s : Etat, CAM_DS (ETcons CV s) C (ETcons CV1 s)).
intros E e V.
simple induction 1.
intros b e0 s C Trad_b hab V0 ML_b CV Eq.
cut (compilation (Bool b)).
2: exact (Proof_bool b).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_b s C Trad_b hab CV Eq).
intros n e0 s C Trad_int hab V0 ML_int CV Eq.
cut (compilation (Num n)).
2: exact (Proof_int n).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_int s C Trad_int hab CV Eq).
intros c e0 s C Trad_op hab V0 ML_op CV Eq.
cut (compilation (op c)).
2: exact (Proof_op c).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_op s C Trad_op hab CV Eq).
intros e0 P E0 s C Trad_lam hab V0 ML_lambda CV Eq.
cut (compilation (lambda P E0)).
2: exact (Proof_abstraction E0 P).
intro comp.
elim comp; intro hyp.
exact (hyp e0 V0 ML_lambda s C Trad_lam hab CV Eq).
intros e0 v I VAL_I s C Trad_pat hab V0 ML_pat CV Eq.
cut (compilation_id (id I)).
2: exact (Proof_ident I).
intro comp.
elim comp; intro hyp.
exact (hyp e0 s hab V0 ML_pat C Trad_pat CV Eq).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C2.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean true) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem true)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHT (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C2 s0).
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) H3 (boolean true) ML_E1).
intros e0 E1 E2 E3 v ML_E1 hyp_E1 ML_E3 hyp_E3 s C Trad_if.
inversion_clear Trad_if.
intros hab V_final ML_DS_if.
inversion_clear ML_DS_if.
cut (boolean false = boolean true).
intro HH.
discriminate HH.
exact (ML_DS_determ e0 E1 (boolean false) ML_E1 (boolean true) H3).
intros CV0 eq_e0_CV0.
elim (hyp_E3 s C3 H2 hab V_final H4 CV0 eq_e0_CV0).
intros CV_final HH; elim HH.
intros Eq_Vf_CVf CAM_C3.
exists CV_final.
split.
exact Eq_Vf_CVf.
intro s0.
cut (CAM_DS (ETcons CV0 (ETcons CV0 s0)) (o C1 (branch C2 C3)) (ETcons CV_final s0)).
cut (CAM_DS (ETcons CV0 s0) push (ETcons CV0 (ETcons CV0 s0))).
exact (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_final s0) push (o C1 (branch C2 C3))).
exact (PUSH s0 CV0).
elim (hyp_E1 s C1 H0 hab (boolean false) ML_E1 CV0 eq_e0_CV0).
intros CV1 HH'; elim HH'.
intro Eq_1; inversion_clear Eq_1.
intro CAM_C1.
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons (val (elem false)) (ETcons CV0 s0)) (ETcons CV_final s0) C1 (branch C2 C3)).
exact (CAM_C1 (ETcons CV0 s0)).
apply (BRANCHF (ETcons CV0 s0) (ETcons CV_final s0) C2 C3).
exact (CAM_C3 s0).
intros e0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_p.
inversion_clear Trad_p.
intros hab V_final ML_DS_pair.
inversion_clear ML_DS_pair.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab u0 H2 CV0 eq_e0_CV0).
intros CV_E1 HH; elim HH.
intros eq_u0_CV_E1 CAM_C1.
elim (hyp_E2 s C2 H1 hab v0 H3 CV0 eq_e0_CV0).
intros CV_E2 HH'; elim HH'.
intros eq_v0_CV_E2 CAM_C2.
exists (Cam_pair CV_E1 CV_E2).
split.
apply (Eqpair u0 v0 CV_E1 CV_E2 eq_u0_CV_E1 eq_v0_CV_E2).
intro s0.
apply (o_DS (ETcons CV0 s0) (ETcons CV0 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) push (o C1 (o swap (o C2 cons)))).
apply (PUSH s0 CV0).
apply (o_DS (ETcons CV0 (ETcons CV0 s0)) (ETcons CV_E1 (ETcons CV0 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C1 (o swap (o C2 cons))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 s0)) (ETcons CV0 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) swap (o C2 cons)).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 s0)) (ETcons CV_E2 (ETcons CV_E1 s0)) (ETcons (Cam_pair CV_E1 CV_E2) s0) C2 cons).
apply CAM_C2.
apply CONS.
intros e0 e1 P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
cut (Clos P E0 e1 = Clos P0 E3 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3.
cut (u = u0).
intro eq4.
cut (ML_DS (Econs P0 u0 e3) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
intro HH2; cut (v = V0).
intro eq5; try rewrite <- eq5.
intros CV0 eq_e0_CV0.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CVal_E2 HH3; elim HH3.
intros Eq_u_Cval_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos P E0 e1) ML_E1 CV0 eq_e0_CV0).
intros Closure HH4; elim HH4.
intro eq_clos.
inversion_clear eq_clos.
intro CAM_C1.
cut (Habite (Econs P u e1) (cons_squelette P s0)).
intro hab_P_e1.
cut (Equiv_env (Econs P u e1) (Cam_pair CV CVal_E2)).
intro eq_env_closure.
elim (hyp_E0 (cons_squelette P s0) C0 H7 hab_P_e1 v ML_E0 (Cam_pair CV CVal_E2) eq_env_closure).
intros CV_final HH5; elim HH5.
intros eq_v_CV_final CAM_C0.
exists CV_final.
split.
exact eq_v_CV_final.
intro sq.
apply (o_DS (ETcons CV0 sq) (ETcons CV0 (ETcons CV0 sq)) (ETcons CV_final sq) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 sq)) (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV_final sq) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (Cam_clos C0 CV) (ETcons CV0 sq)) (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (Cam_clos C0 CV) sq)) (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons CV_final sq) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CVal_E2 (ETcons (Cam_clos C0 CV) sq)) (ETcons (Cam_pair (Cam_clos C0 CV) CVal_E2) sq) (ETcons CV_final sq) cons app).
apply CONS.
apply (APPcam1 sq (ETcons CV_final sq) CV CVal_E2 C0).
apply CAM_C0.
apply (Eqenv2 P e1 CV H5 u CVal_E2 Eq_u_Cval_E2).
apply (cons_habite P u e1 s0 H6).
apply (ML_DS_determ (Econs P u e1) E0 v ML_E0 V0 HH2).
exact H4.
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos P0 E3 e3) H2).
cut (Clos P E0 e1 = Clos_rec x E3 P0 e3).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (Clos_rec x E3 P0 e3) H2).
cut (Clos P E0 e1 = OP_clos c).
intro hyp_not; discriminate hyp_not.
apply (ML_DS_determ e0 E1 (Clos P E0 e1) ML_E1 (OP_clos c) H2).
intros e0 e1 x P E0 E1 E2 u v ML_E1 hyp_E1 ML_E2 hyp_E2 ML_E0 hyp_E0 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_app.
inversion_clear ML_app.
cut (Clos_rec x E0 P e1 = Clos P0 E3 e3).
intro HH1; discriminate HH1.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos P0 E3 e3) H2).
intros CV0 eq_e0_CV0.
cut (Clos_rec x E0 P e1 = Clos_rec x0 E3 P0 e3).
intro HH1; injection HH1.
intros eq1 eq2 eq3 eq4.
cut (ML_DS (Econs x0 u0 (Econs P0 (Clos_rec x0 E3 P0 e3) e3)) E3 V0).
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3; try rewrite <- eq4.
cut (u = u0).
intro eq5; try rewrite <- eq5.
intro ML_E0'.
cut (v = V0).
intro eq6; try rewrite <- eq6.
elim (hyp_E2 s C2 H1 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_E2 HH3; elim HH3.
intros eq_u_CV_E2 CAM_C2.
elim (hyp_E1 s C1 H0 hab (Clos_rec x E0 P e1) ML_E1 CV0 eq_e0_CV0).
intros CV_E1 HH2; elim HH2.
intros eq_V1_CV_E1 CAM_C1.
simple inversion eq_V1_CV_E1.
discriminate H5.
discriminate H5.
discriminate H5.
discriminate H7.
discriminate H8.
injection H8.
intros eq7 eq8 eq9 eq10.
try rewrite eq7; try rewrite eq8; try rewrite eq9; try rewrite eq10.
intros.
cut (Habite (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (cons_squelette x (cons_squelette P s0))).
intro hab0.
cut (Equiv_env (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) (Cam_pair (Cam_pair CV CV_E1) CV_E2)).
intro Eq_env0.
elim (hyp_E0 (cons_squelette x (cons_squelette P s0)) C0 H7 hab0 v ML_E0 (Cam_pair (Cam_pair CV CV_E1) CV_E2) Eq_env0).
intros CV_E0 HH4; elim HH4.
intros eq_v_CV_E0 CAM_C0.
exists CV_E0.
split.
exact eq_v_CV_E0.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E0 S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV_E0 S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons CV_E1 (ETcons CV0 S)) (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E0 S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons CV_E1 S)) (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons CV_E0 S) C2 (o cons app)).
apply CAM_C2.
apply (o_DS (ETcons CV_E2 (ETcons CV_E1 S)) (ETcons (Cam_pair CV_E1 CV_E2) S) (ETcons CV_E0 S) cons app).
apply CONS.
cut (forall s : Etat, CAM_DS (ETcons (Cam_pair (Cam_pair CV CV_E1) CV_E2) s) C0 (ETcons CV_E0 s)).
2: auto.
try rewrite <- H9.
intro Good_CAM_C0.
apply (APPcam2 S (ETcons CV_E0 S) CV_E2 CV C0 (Good_CAM_C0 S)).
apply Eqenv2; auto.
apply Eqenv2; auto.
apply cons_habite; auto.
apply cons_habite; auto.
apply (ML_DS_determ (Econs x u (Econs P (Clos_rec x E0 P e1) e1)) E0 v ML_E0 V0 ML_E0').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H3).
auto.
apply (ML_DS_determ e0 E1 (Clos_rec x E0 P e1) ML_E1 (Clos_rec x0 E3 P0 e3) H2).
cut (OP_clos c = Clos_rec x E0 P e1).
intro Hyp_false; discriminate Hyp_false.
apply (ML_DS_determ e0 E1 (OP_clos c) H2 (Clos_rec x E0 P e1) ML_E1).
intros e0 E1 E2 n m c ML_E1 hyp_E1 ML_E2 hyp_E2 s C Trad_appl.
inversion_clear Trad_appl.
intros hab V0 ML_appl.
inversion_clear ML_appl.
intros CV0 eq_e0_CV0.
cut (OP_clos c = Clos P E0 e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos P E0 e2) H2).
intro HH; discriminate HH.
cut (OP_clos c = Clos_rec x E0 P e2).
2: exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (Clos_rec x E0 P e2) H2).
intro HH; discriminate HH.
cut (valpair (num n) (num m) = valpair (num n0) (num m0)).
2: exact (ML_DS_determ e0 E2 (valpair (num n) (num m)) ML_E2 (valpair (num n0) (num m0)) H3).
intro HH; injection HH.
intros eq1 eq2.
cut (OP_clos c = OP_clos c0).
intro HH1; injection HH1.
intro eq3.
try rewrite <- eq1; try rewrite <- eq2; try rewrite <- eq3.
intros CV0 eq_e0_CV0.
elim (hyp_E1 s C1 H0 hab (OP_clos c) ML_E1 CV0 eq_e0_CV0).
intro HH2; elim HH2.
intros CV_c HH3.
elim HH3.
intros eq_c_CV_c CAM_C1.
elim (hyp_E2 s C2 H1 hab (valpair (num n) (num m)) ML_E2 CV0 eq_e0_CV0).
intros CV_nm HH4.
elim HH4.
intro eq_nm_CV_nm.
inversion_clear eq_nm_CV_nm.
inversion_clear H4.
inversion_clear H5.
intro CAM_C2.
exists (val (int (eval_op c n m))).
split.
exact (Eqnum (eval_op c n m)).
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) push (o C1 (o swap (o C2 (o cons app))))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (val CV_c) (ETcons CV0 S)) (ETcons (val (int (eval_op c n m))) S) C1 (o swap (o C2 (o cons app)))).
apply CAM_C1.
apply (o_DS (ETcons (val CV_c) (ETcons CV0 S)) (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) swap (o C2 (o cons app))).
apply SWAP.
apply (o_DS (ETcons CV0 (ETcons (val CV_c) S)) (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val CV_c) S)) (ETcons (val (int (eval_op c n m))) S) C2 (o cons app)).
apply CAM_C2.
cut (forall s : Etat, CAM_DS (ETcons CV0 s) C1 (ETcons (val CV_c) s)).
2: auto.
inversion_clear eq_c_CV_c.
intro U_CAM_C1.
apply (o_DS (ETcons (Cam_pair (val (int n)) (val (int m))) (ETcons (val (def_op c)) S)) (ETcons (Cam_pair (val (def_op c)) (Cam_pair (val (int n)) (val (int m)))) S) (ETcons (val (int (eval_op c n m))) S) cons app).
apply CONS.
apply (APPcam_op S n m c).
intros.
elim H6.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H5.
intro HH5; inversion_clear HH5.
intros.
elim H4.
intro HH4; inversion_clear HH4.
exact (ML_DS_determ e0 E1 (OP_clos c) ML_E1 (OP_clos c0) H2).
intros e0 P E1 E2 u v ML_E2 hyp_E2 ML_E1 hyp_E1 s C Trad_let'.
inversion_clear Trad_let'.
intros hab V0 ML_let.
inversion_clear ML_let.
intros CV0 eq_e0_CV0.
cut (u = u0); cut (v = V0).
intros eq1 eq2.
try rewrite <- eq1; try rewrite <- eq2.
elim (hyp_E2 s C1 H0 hab u ML_E2 CV0 eq_e0_CV0).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C1.
elim (hyp_E1 (cons_squelette P s) C2 H1 (cons_habite P u e0 s hab) v ML_E1 (Cam_pair CV0 CV_u) (Eqenv2 P e0 CV0 eq_e0_CV0 u CV_u eq_u_CV_u)).
intros CV_v HH2.
elim HH2.
intros eq_v_CV_v CAM_C2.
exists CV_v.
split.
exact eq_v_CV_v.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_v S) push (o C1 (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u (ETcons CV0 S)) (ETcons CV_v S) C1 (o cons C2)).
apply CAM_C1.
apply (o_DS (ETcons CV_u (ETcons CV0 S)) (ETcons (Cam_pair CV0 CV_u) S) (ETcons CV_v S) cons C2).
apply CONS.
apply CAM_C2.
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intro; apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
cut (u = u0).
intro eq3.
cut (ML_DS (Econs P u0 e0) E1 V0).
2: exact H3.
try rewrite <- eq3.
intro ML_E1'.
apply (ML_DS_determ (Econs P u e0) E1 v ML_E1 V0 ML_E1').
apply (ML_DS_determ e0 E2 u ML_E2 u0 H2).
intros e0 P x E0 E2 u ML_E2 hyp_E2 s C Trad_letrec.
inversion_clear Trad_letrec.
intros hab V0 ML_letrec.
inversion_clear ML_letrec.
intros CV0 eq_e0_CV0.
cut (u = V0).
intro eq1.
try rewrite <- eq1.
elim (hyp_E2 (cons_squelette P s) C2 H1 (cons_habite P (Clos_rec x E0 P e0) e0 s hab) u ML_E2 (Cam_pair CV0 (Cam_clos_rec C0 CV0)) (Eqenv2 P e0 CV0 eq_e0_CV0 (Clos_rec x E0 P e0) (Cam_clos_rec C0 CV0) (Eqclos_rec P x E0 e0 C0 CV0 s eq_e0_CV0 hab H0))).
intros CV_u HH.
elim HH.
intros eq_u_CV_u CAM_C2.
exists CV_u.
split.
exact eq_u_CV_u.
intro S.
apply (o_DS (ETcons CV0 S) (ETcons CV0 (ETcons CV0 S)) (ETcons CV_u S) push (o (cur_rec C0) (o cons C2))).
apply PUSH.
apply (o_DS (ETcons CV0 (ETcons CV0 S)) (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons CV_u S) (cur_rec C0) (o cons C2)).
apply CUR_REC.
apply (o_DS (ETcons (Cam_clos_rec C0 CV0) (ETcons CV0 S)) (ETcons (Cam_pair CV0 (Cam_clos_rec C0 CV0)) S) (ETcons CV_u S) cons C2).
apply CONS.
apply CAM_C2.
apply (ML_DS_determ (Econs P (Clos_rec x E0 P e0) e0) E2 u ML_E2 V0 H2).

*****

*****

+++++
Qed.
-----
