Require Export GeoCoq.Elements.OriginalProofs.proposition_01.
-----
Require Export GeoCoq.Elements.OriginalProofs.lemma_congruenceflip.
-----
Require Export GeoCoq.Elements.OriginalProofs.lemma_NCdistinct.
-----
Require Export GeoCoq.Elements.OriginalProofs.lemma_differenceofparts.
-----
Section Euclid.
-----
Context `{Ax:euclidean_neutral_ruler_compass}.
-----
Lemma proposition_02 : \n   forall A B C, \n   neq A B -> neq B C ->\n   exists X, Cong A X B C.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : neq A B) (_ : neq B C), ex (fun X : Point => Cong A X B C)
+++++
Proof.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.

*****
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
forall (A B C : Point) (_ : neq A B) (_ : neq B C), ex (fun X : Point => Cong A X B C)
+++++
intros.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.

*****
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.

*****
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong A B B D) by (conclude_def equilateral ).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).

*****
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).

*****
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).

*****
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong B D D A) by (conclude_def equilateral ).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).

*****
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (nCol A B D) by (conclude_def Triangle ).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).

*****
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (eq B B) by (conclude cn_equalityreflexive).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).

*****
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.

*****
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (InCirc B J) by (conclude_def InCirc ).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).

*****
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (neq D B) by (forward_using lemma_NCdistinct).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).

*****
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\ BetS D B G /\ OnCirc P J /\ OnCirc G J /\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.

*****
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (neq D G) by (forward_using lemma_betweennotequal).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).

*****
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.

*****
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).

*****
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).

*****
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (eq D D) by (conclude cn_equalityreflexive).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).

*****
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).

*****
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).

*****
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D G D G) by (conclude cn_congruencereflexive).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).

*****
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (InCirc A R) by (conclude_def InCirc ).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).

*****
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (neq D A) by (forward_using lemma_NCdistinct).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).

*****
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\ BetS D A L /\ OnCirc Q R /\ OnCirc L R /\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.

*****
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).

*****
H32 : Cong D L D G
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D B D B) by (conclude cn_congruencereflexive).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).

*****
H33 : Cong D B D B
H32 : Cong D L D G
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).

*****
H34 : Cong D B D A
H33 : Cong D B D B
H32 : Cong D L D G
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).

*****
H35 : Cong D G D L
H34 : Cong D B D A
H33 : Cong D B D B
H32 : Cong D L D G
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong B G A L) by (conclude lemma_differenceofparts).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
assert (Cong B G A L) by (conclude lemma_differenceofparts).

*****
H36 : Cong B G A L
H35 : Cong D G D L
H34 : Cong D B D A
H33 : Cong D B D B
H32 : Cong D L D G
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
assert (Cong A L B C) by (conclude cn_congruencetransitive).
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
assert (Cong B G A L) by (conclude lemma_differenceofparts).
assert (Cong A L B C) by (conclude cn_congruencetransitive).

*****
H37 : Cong A L B C
H36 : Cong B G A L
H35 : Cong D G D L
H34 : Cong D B D A
H33 : Cong D B D B
H32 : Cong D L D G
H31 : BetS Q A L
H30 : OnCirc L R
H29 : OnCirc Q R
H28 : BetS D A L
H27 : Col D A Q
Q,L : Point
H26 : neq D A
H25 : InCirc A R
H24 : Cong D G D G
H23 : Cong D A D B
H22 : Cong D A B D
H21 : eq D D
H20 : Cong B C B G
H19 : Cong B G B C
H18 : CI R D D G
R : Circle
H17 : neq D G
H16 : BetS P B G
H15 : OnCirc G J
H14 : OnCirc P J
H13 : BetS D B G
H12 : Col D B P
P,G : Point
H11 : neq D B
H10 : InCirc B J
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
ex (fun X : Point => Cong A X B C)
+++++
close.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
assert (Cong B G A L) by (conclude lemma_differenceofparts).
assert (Cong A L B C) by (conclude cn_congruencetransitive).
close.

*****

*****

+++++
Unshelve.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
assert (Cong B G A L) by (conclude lemma_differenceofparts).
assert (Cong A L B C) by (conclude cn_congruencetransitive).
close.
Unshelve.

*****
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Point
+++++
exact A.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
assert (Cong B G A L) by (conclude lemma_differenceofparts).
assert (Cong A L B C) by (conclude cn_congruencetransitive).
close.
Unshelve.
exact A.

*****
H9 : CI J B B C
J : Circle
H8 : eq B B
H7 : nCol A B D
H6 : Cong B D D A
H5 : Cong B D B A
H4 : Cong B D A B
H3 : Cong A B B D
H2 : Triangle A B D
H1 : equilateral A B D
D : Point
H0 : neq B C
H : neq A B
A,B,C : Point
Ax : euclidean_neutral_ruler_compass Ax0
Ax0 : euclidean_neutral
*****
Point
+++++
exact A.
-----
Lemma proposition_02 : forall A B C, neq A B -> neq B C -> exists X, Cong A X B C.
Proof.
intros.
let Tf:=fresh in assert (Tf:exists D, (equilateral A B D /\\ Triangle A B D)) by (conclude proposition_01);destruct Tf as [D];spliter.
assert (Cong A B B D) by (conclude_def equilateral ).
assert (Cong B D A B) by (conclude lemma_congruencesymmetric).
assert (Cong B D B A) by (forward_using lemma_congruenceflip).
assert (Cong B D D A) by (conclude_def equilateral ).
assert (nCol A B D) by (conclude_def Triangle ).
assert (eq B B) by (conclude cn_equalityreflexive).
let Tf:=fresh in assert (Tf:exists J, CI J B B C) by (conclude postulate_Euclid3);destruct Tf as [J];spliter.
assert (InCirc B J) by (conclude_def InCirc ).
assert (neq D B) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists P G, (Col D B P /\\ BetS D B G /\\ OnCirc P J /\\ OnCirc G J /\\ BetS P B G)) by (conclude postulate_line_circle);destruct Tf as [P[G]];spliter.
assert (neq D G) by (forward_using lemma_betweennotequal).
let Tf:=fresh in assert (Tf:exists R, CI R D D G) by (conclude postulate_Euclid3);destruct Tf as [R];spliter.
assert (Cong B G B C) by (conclude axiom_circle_center_radius).
assert (Cong B C B G) by (conclude lemma_congruencesymmetric).
assert (eq D D) by (conclude cn_equalityreflexive).
assert (Cong D A B D) by (conclude lemma_congruencesymmetric).
assert (Cong D A D B) by (forward_using lemma_congruenceflip).
assert (Cong D G D G) by (conclude cn_congruencereflexive).
assert (InCirc A R) by (conclude_def InCirc ).
assert (neq D A) by (forward_using lemma_NCdistinct).
let Tf:=fresh in assert (Tf:exists Q L, (Col D A Q /\\ BetS D A L /\\ OnCirc Q R /\\ OnCirc L R /\\ BetS Q A L)) by (conclude postulate_line_circle);destruct Tf as [Q[L]];spliter.
assert (Cong D L D G) by (conclude axiom_circle_center_radius).
assert (Cong D B D B) by (conclude cn_congruencereflexive).
assert (Cong D B D A) by (conclude lemma_congruencesymmetric).
assert (Cong D G D L) by (conclude lemma_congruencesymmetric).
assert (Cong B G A L) by (conclude lemma_differenceofparts).
assert (Cong A L B C) by (conclude cn_congruencetransitive).
close.
Unshelve.
exact A.
exact A.

*****

*****

+++++
Qed.
-----
End Euclid.
-----
