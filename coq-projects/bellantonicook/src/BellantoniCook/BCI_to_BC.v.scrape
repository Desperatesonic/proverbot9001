From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import BellantoniCook.Lib BellantoniCook.Bitstring BellantoniCook.BC BellantoniCook.BCI.
-----
Fixpoint conv n s (e : BCI) : BC :=\n  match e with\n    | zeroI => comp n s zero nil nil\n    | projIn i => proj n s i\n    | projIs i => proj n s (n + i)\n    | succI b => comp n s (succ b) nil [proj n s n]\n    | predI => comp n s pred nil [proj n s n]\n    | condI => comp n s cond nil \n      [proj n s n; proj n s (S n); proj n s (S (S n)); proj n s (S (S (S n)))]\n    | recI g h0 h1 => rec (conv (n-1) s g) \n                          (conv n (S s) h0) \n                          (conv n (S s) h1)\n    | compI g ln ls =>\n      comp n s (conv (length ln) (length ls) g) \n       (map (conv n 0) ln) (map (conv n s) ls) \n  end.
-----
Definition zeroI_e := compI zeroI nil nil.
-----
Definition leftI (d:nat)(x:TypeI) : nat :=\n match x with\n | I n _ => n\n | E _ => d\n end.
-----
Lemma inf_list_maxl_l : forall l n s,\n inf_list l = I n s ->\n n = maxl (map (leftI 0) l).
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).

*****

*****
forall (l : list TypeI) (n s : nat) (_ : eq (inf_list l) (I n s)), eq n (maxl (map (leftI Datatypes.O) l))
+++++
Proof.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.

*****

*****
forall (l : list TypeI) (n s : nat) (_ : eq (inf_list l) (I n s)), eq n (maxl (map (leftI Datatypes.O) l))
+++++
induction l.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.

*****

*****
forall (n s : nat) (_ : eq (inf_list nil) (I n s)), eq n (maxl (map (leftI Datatypes.O) nil))
+++++
intros.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.

*****
H : eq (inf_list nil) (I n s)
n,s : nat
*****
eq n (maxl (map (leftI Datatypes.O) nil))
+++++
compute in *.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
compute in *.

*****
H : eq (I Datatypes.O Datatypes.O) (I n s)
n,s : nat
*****
eq n Datatypes.O
+++++
injection H.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
compute in *.
injection H.

*****
H : eq (I Datatypes.O Datatypes.O) (I n s)
n,s : nat
*****
forall (_ : eq Datatypes.O s) (_ : eq Datatypes.O n), eq n Datatypes.O
+++++
auto.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.

*****
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
a : TypeI
*****
forall (n s : nat) (_ : eq (inf_list (cons a l)) (I n s)), eq n (maxl (map (leftI Datatypes.O) (cons a l)))
+++++
intros.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.

*****
H : eq (inf_list (cons a l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
a : TypeI
*****
eq n (maxl (map (leftI Datatypes.O) (cons a l)))
+++++
simpl in *.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.

*****
H : eq (unionI a (inf_list l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
a : TypeI
*****
eq n (Init.Nat.max (leftI Datatypes.O a) (maxl (map (leftI Datatypes.O) l)))
+++++
destruct a.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.

*****
H : eq (unionI (I n0 n1) (inf_list l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
n0,n1 : nat
*****
eq n (Init.Nat.max (leftI Datatypes.O (I n0 n1)) (maxl (map (leftI Datatypes.O) l)))
+++++
simpl in *.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.

*****
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n0 n2) (Init.Nat.max n1 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
n0,n1 : nat
*****
eq n (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
destruct (inf_list l).
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).

*****
H : eq (I (Init.Nat.max n0 n2) (Init.Nat.max n1 n3)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq n (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
injection H.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.

*****
H : eq (I (Init.Nat.max n0 n2) (Init.Nat.max n1 n3)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
forall (_ : eq (Init.Nat.max n1 n3) s) (_ : eq (Init.Nat.max n0 n2) n), eq n (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
clear H.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.

*****
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
forall (_ : eq (Init.Nat.max n1 n3) s) (_ : eq (Init.Nat.max n0 n2) n), eq n (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
intros.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.

*****
H0 : eq (Init.Nat.max n0 n2) n
H : eq (Init.Nat.max n1 n3) s
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq n (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
subst.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.
subst.

*****
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq (Init.Nat.max n0 n2) (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
f_equal.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.
subst.
f_equal.

*****
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq n2 (maxl (map (leftI Datatypes.O) l))
+++++
eapply IHl.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.
subst.
f_equal.
eapply IHl.

*****
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq (I n2 n3) (I n2 ?s)
+++++
eauto.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).

*****
H : eq (E (Enat (S (S (S Datatypes.O))))) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (E e) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
e : ErrorI
l : list TypeI
n0,n1 : nat
*****
eq n (Init.Nat.max n0 (maxl (map (leftI Datatypes.O) l)))
+++++
discriminate.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.

*****
H : eq (unionI (E e) (inf_list l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
e : ErrorI
*****
eq n (Init.Nat.max (leftI Datatypes.O (E e)) (maxl (map (leftI Datatypes.O) l)))
+++++
simpl in *.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.

*****
H : eq (E (Enat (S (S (S Datatypes.O))))) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq n (maxl (map (leftI Datatypes.O) l))
l : list TypeI
e : ErrorI
*****
eq n (maxl (map (leftI Datatypes.O) l))
+++++
discriminate.
-----
Lemma inf_list_maxl_l : forall l n s, inf_list l = I n s -> n = maxl (map (leftI 0) l).
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Definition rightI (d:nat)(x:TypeI) : nat :=\n match x with\n | I _ n => n\n | E _ => d\n end.
-----
Lemma inf_list_maxl_r : forall l n s,\n inf_list l = I n s ->\n s = maxl (map (rightI 0) l).
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).

*****

*****
forall (l : list TypeI) (n s : nat) (_ : eq (inf_list l) (I n s)), eq s (maxl (map (rightI Datatypes.O) l))
+++++
Proof.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.

*****

*****
forall (l : list TypeI) (n s : nat) (_ : eq (inf_list l) (I n s)), eq s (maxl (map (rightI Datatypes.O) l))
+++++
induction l.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.

*****

*****
forall (n s : nat) (_ : eq (inf_list nil) (I n s)), eq s (maxl (map (rightI Datatypes.O) nil))
+++++
intros.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.

*****
H : eq (inf_list nil) (I n s)
n,s : nat
*****
eq s (maxl (map (rightI Datatypes.O) nil))
+++++
compute in *.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
compute in *.

*****
H : eq (I Datatypes.O Datatypes.O) (I n s)
n,s : nat
*****
eq s Datatypes.O
+++++
injection H.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
compute in *.
injection H.

*****
H : eq (I Datatypes.O Datatypes.O) (I n s)
n,s : nat
*****
forall (_ : eq Datatypes.O s) (_ : eq Datatypes.O n), eq s Datatypes.O
+++++
auto.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.

*****
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
a : TypeI
*****
forall (n s : nat) (_ : eq (inf_list (cons a l)) (I n s)), eq s (maxl (map (rightI Datatypes.O) (cons a l)))
+++++
intros.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.

*****
H : eq (inf_list (cons a l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
a : TypeI
*****
eq s (maxl (map (rightI Datatypes.O) (cons a l)))
+++++
simpl in *.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.

*****
H : eq (unionI a (inf_list l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
a : TypeI
*****
eq s (Init.Nat.max (rightI Datatypes.O a) (maxl (map (rightI Datatypes.O) l)))
+++++
destruct a.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.

*****
H : eq (unionI (I n0 n1) (inf_list l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
n0,n1 : nat
*****
eq s (Init.Nat.max (rightI Datatypes.O (I n0 n1)) (maxl (map (rightI Datatypes.O) l)))
+++++
simpl in *.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.

*****
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n0 n2) (Init.Nat.max n1 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
n0,n1 : nat
*****
eq s (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
destruct (inf_list l).
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).

*****
H : eq (I (Init.Nat.max n0 n2) (Init.Nat.max n1 n3)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq s (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
injection H.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.

*****
H : eq (I (Init.Nat.max n0 n2) (Init.Nat.max n1 n3)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
forall (_ : eq (Init.Nat.max n1 n3) s) (_ : eq (Init.Nat.max n0 n2) n), eq s (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
clear H.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.

*****
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
forall (_ : eq (Init.Nat.max n1 n3) s) (_ : eq (Init.Nat.max n0 n2) n), eq s (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
intros.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.

*****
H0 : eq (Init.Nat.max n0 n2) n
H : eq (Init.Nat.max n1 n3) s
n,s : nat
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq s (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
subst.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.
subst.

*****
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq (Init.Nat.max n1 n3) (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
f_equal.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.
subst.
f_equal.

*****
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq n3 (maxl (map (rightI Datatypes.O) l))
+++++
eapply IHl.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).
injection H.
clear H.
intros.
subst.
f_equal.
eapply IHl.

*****
IHl : forall (n s : nat) (_ : eq (I n2 n3) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
n2,n3 : nat
l : list TypeI
n0,n1 : nat
*****
eq (I n2 n3) (I ?n n3)
+++++
eauto.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.
destruct (inf_list l).

*****
H : eq (E (Enat (S (S (S Datatypes.O))))) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (E e) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
e : ErrorI
l : list TypeI
n0,n1 : nat
*****
eq s (Init.Nat.max n1 (maxl (map (rightI Datatypes.O) l)))
+++++
discriminate.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.

*****
H : eq (unionI (E e) (inf_list l)) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
e : ErrorI
*****
eq s (Init.Nat.max (rightI Datatypes.O (E e)) (maxl (map (rightI Datatypes.O) l)))
+++++
simpl in *.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.
intros.
simpl in *.
destruct a.
simpl in *.

*****
H : eq (E (Enat (S (S (S Datatypes.O))))) (I n s)
n,s : nat
IHl : forall (n s : nat) (_ : eq (inf_list l) (I n s)),\neq s (maxl (map (rightI Datatypes.O) l))
l : list TypeI
e : ErrorI
*****
eq s (maxl (map (rightI Datatypes.O) l))
+++++
discriminate.
-----
Lemma inf_list_maxl_r : forall l n s, inf_list l = I n s -> s = maxl (map (rightI 0) l).
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma in_inf_list_le_l l n s n' s' :\n In (I n' s') l -> inf_list l = I n s -> n' <= n.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.

*****
n,s,n',s' : nat
l : list TypeI
*****
forall (_ : In (I n' s') l) (_ : eq (inf_list l) (I n s)), le n' n
+++++
Proof.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.

*****
n,s,n',s' : nat
l : list TypeI
*****
forall (_ : In (I n' s') l) (_ : eq (inf_list l) (I n s)), le n' n
+++++
intros.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.

*****
H0 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
le n' n
+++++
apply inf_list_maxl_l in H0.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.

*****
H0 : eq n (maxl (map (leftI Datatypes.O) l))
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
le n' n
+++++
subst.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.

*****
H : In (I n' s') l
s,n',s' : nat
l : list TypeI
*****
le n' (maxl (map (leftI Datatypes.O) l))
+++++
apply in_map with (f:=leftI 0) in H.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.

*****
H : In (leftI Datatypes.O (I n' s')) (map (leftI Datatypes.O) l)
s,n',s' : nat
l : list TypeI
*****
le n' (maxl (map (leftI Datatypes.O) l))
+++++
induction (map (leftI 0) l).
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).

*****
H : In (leftI Datatypes.O (I n' s')) nil
s,n',s' : nat
l : list TypeI
*****
le n' (maxl nil)
+++++
simpl in *.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).
simpl in *.

*****
H : False
s,n',s' : nat
l : list TypeI
*****
le n' Datatypes.O
+++++
elim H.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).

*****
IHl0 : forall _ : In (leftI Datatypes.O (I n' s')) l0, le n' (maxl l0)
H : In (leftI Datatypes.O (I n' s')) (cons a l0)
l0 : list nat
s,n',s',a : nat
l : list TypeI
*****
le n' (maxl (cons a l0))
+++++
simpl in *.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).
simpl in *.

*****
IHl0 : forall _ : In n' l0, le n' (maxl l0)
H : or (eq a n') (In n' l0)
l0 : list nat
s,n',s',a : nat
l : list TypeI
*****
le n' (Init.Nat.max a (maxl l0))
+++++
destruct H.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).
simpl in *.
destruct H.

*****
IHl0 : forall _ : In n' l0, le n' (maxl l0)
H : eq a n'
l0 : list nat
s,n',s',a : nat
l : list TypeI
*****
le n' (Init.Nat.max a (maxl l0))
+++++
subst a.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).
simpl in *.
destruct H.
subst a.

*****
IHl0 : forall _ : In n' l0, le n' (maxl l0)
l0 : list nat
s,n',s' : nat
l : list TypeI
*****
le n' (Init.Nat.max n' (maxl l0))
+++++
apply maxl_cons.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).
simpl in *.
destruct H.

*****
IHl0 : forall _ : In n' l0, le n' (maxl l0)
H : In n' l0
l0 : list nat
s,n',s',a : nat
l : list TypeI
*****
le n' (Init.Nat.max a (maxl l0))
+++++
apply le_maxl_cons.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).
simpl in *.
destruct H.
apply le_maxl_cons.

*****
IHl0 : forall _ : In n' l0, le n' (maxl l0)
H : In n' l0
l0 : list nat
s,n',s',a : nat
l : list TypeI
*****
le n' (maxl l0)
+++++
tauto.
-----
Lemma in_inf_list_le_l l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n.
Proof.
intros.
apply inf_list_maxl_l in H0.
subst.
apply in_map with (f:=leftI 0) in H.
induction (map (leftI 0) l).

*****

*****

+++++
Qed.
-----
Lemma in_inf_list_le_r l n s n' s' :\n In (I n' s') l -> inf_list l = I n s -> s' <= s.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.

*****
n,s,n',s' : nat
l : list TypeI
*****
forall (_ : In (I n' s') l) (_ : eq (inf_list l) (I n s)), le s' s
+++++
Proof.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.

*****
n,s,n',s' : nat
l : list TypeI
*****
forall (_ : In (I n' s') l) (_ : eq (inf_list l) (I n s)), le s' s
+++++
intros.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.

*****
H0 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
le s' s
+++++
apply inf_list_maxl_r in H0.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.

*****
H0 : eq s (maxl (map (rightI Datatypes.O) l))
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
le s' s
+++++
subst.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.

*****
H : In (I n' s') l
n,n',s' : nat
l : list TypeI
*****
le s' (maxl (map (rightI Datatypes.O) l))
+++++
apply in_map with (f:=rightI 0) in H.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.

*****
H : In (rightI Datatypes.O (I n' s')) (map (rightI Datatypes.O) l)
n,n',s' : nat
l : list TypeI
*****
le s' (maxl (map (rightI Datatypes.O) l))
+++++
induction (map (rightI 0) l).
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).

*****
H : In (rightI Datatypes.O (I n' s')) nil
n,n',s' : nat
l : list TypeI
*****
le s' (maxl nil)
+++++
simpl in *.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).
simpl in *.

*****
H : False
n,n',s' : nat
l : list TypeI
*****
le s' Datatypes.O
+++++
elim H.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).

*****
IHl0 : forall _ : In (rightI Datatypes.O (I n' s')) l0, le s' (maxl l0)
H : In (rightI Datatypes.O (I n' s')) (cons a l0)
l0 : list nat
n,n',s',a : nat
l : list TypeI
*****
le s' (maxl (cons a l0))
+++++
simpl in *.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).
simpl in *.

*****
IHl0 : forall _ : In s' l0, le s' (maxl l0)
H : or (eq a s') (In s' l0)
l0 : list nat
n,n',s',a : nat
l : list TypeI
*****
le s' (Init.Nat.max a (maxl l0))
+++++
destruct H.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).
simpl in *.
destruct H.

*****
IHl0 : forall _ : In s' l0, le s' (maxl l0)
H : eq a s'
l0 : list nat
n,n',s',a : nat
l : list TypeI
*****
le s' (Init.Nat.max a (maxl l0))
+++++
subst a.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).
simpl in *.
destruct H.
subst a.

*****
IHl0 : forall _ : In s' l0, le s' (maxl l0)
l0 : list nat
n,n',s' : nat
l : list TypeI
*****
le s' (Init.Nat.max s' (maxl l0))
+++++
apply maxl_cons.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).
simpl in *.
destruct H.

*****
IHl0 : forall _ : In s' l0, le s' (maxl l0)
H : In s' l0
l0 : list nat
n,n',s',a : nat
l : list TypeI
*****
le s' (Init.Nat.max a (maxl l0))
+++++
apply le_maxl_cons.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).
simpl in *.
destruct H.
apply le_maxl_cons.

*****
IHl0 : forall _ : In s' l0, le s' (maxl l0)
H : In s' l0
l0 : list nat
n,n',s',a : nat
l : list TypeI
*****
le s' (maxl l0)
+++++
tauto.
-----
Lemma in_inf_list_le_r l n s n' s' : In (I n' s') l -> inf_list l = I n s -> s' <= s.
Proof.
intros.
apply inf_list_maxl_r in H0.
subst.
apply in_map with (f:=rightI 0) in H.
induction (map (rightI 0) l).

*****

*****

+++++
Qed.
-----
Lemma in_inf_list_le l n s n' s' :\n In (I n' s') l -> inf_list l = I n s -> n' <= n /\ s' <= s.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.

*****
n,s,n',s' : nat
l : list TypeI
*****
forall (_ : In (I n' s') l) (_ : eq (inf_list l) (I n s)), and (le n' n) (le s' s)
+++++
Proof.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.

*****
n,s,n',s' : nat
l : list TypeI
*****
forall (_ : In (I n' s') l) (_ : eq (inf_list l) (I n s)), and (le n' n) (le s' s)
+++++
intros.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.

*****
H0 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
and (le n' n) (le s' s)
+++++
generalize H0.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.

*****
H0 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
forall _ : eq (inf_list l) (I n s), and (le n' n) (le s' s)
+++++
intros.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.

*****
H0,H1 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
and (le n' n) (le s' s)
+++++
eapply in_inf_list_le_r in H0.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.
eapply in_inf_list_le_r in H0.

*****
H0 : le ?s' s
H1 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
and (le n' n) (le s' s)
+++++
eauto.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.
eapply in_inf_list_le_r in H0.
eauto.

*****
H0 : le ?s' s
H1 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
and (le n' n) (le s' s)
+++++
eapply in_inf_list_le_l in H1.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.
eapply in_inf_list_le_r in H0.
eauto.
eapply in_inf_list_le_l in H1.

*****
H0 : le ?s'0 s
H1 : le ?n'0 n
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
and (le n' n) (le s' s)
+++++
eauto.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.
eapply in_inf_list_le_r in H0.
eauto.
eapply in_inf_list_le_l in H1.

*****
H0 : le ?s'0 s
H1 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
In (I n' ?s') l
+++++
eauto.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.
eapply in_inf_list_le_r in H0.

*****
H0,H1 : eq (inf_list l) (I n s)
H : In (I n' s') l
n,s,n',s' : nat
l : list TypeI
*****
In (I ?n' s') l
+++++
eauto.
-----
Lemma in_inf_list_le l n s n' s' : In (I n' s') l -> inf_list l = I n s -> n' <= n /\\ s' <= s.
Proof.
intros.
generalize H0.
intros.
eapply in_inf_list_le_r in H0.

*****

*****

+++++
Qed.
-----
Lemma in_inf_list_err : forall l err,\n In (E err) l -> exists err', inf_list l = E err'.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.

*****

*****
forall (l : list TypeI) (err : ErrorI) (_ : In (E err) l), ex (fun err' : ErrorI => eq (inf_list l) (E err'))
+++++
Proof.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.

*****

*****
forall (l : list TypeI) (err : ErrorI) (_ : In (E err) l), ex (fun err' : ErrorI => eq (inf_list l) (E err'))
+++++
induction l.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.

*****

*****
forall (err : ErrorI) (_ : In (E err) nil), ex (fun err' : ErrorI => eq (inf_list nil) (E err'))
+++++
simpl.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.

*****

*****
forall (_ : ErrorI) (_ : False), ex (fun err' : ErrorI => eq (I Datatypes.O Datatypes.O) (E err'))
+++++
intros.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.

*****
H : False
err : ErrorI
*****
ex (fun err' : ErrorI => eq (I Datatypes.O Datatypes.O) (E err'))
+++++
elim H.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.

*****
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
forall (err : ErrorI) (_ : In (E err) (cons a l)), ex (fun err' : ErrorI => eq (inf_list (cons a l)) (E err'))
+++++
simpl.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.

*****
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
forall (err : ErrorI) (_ : or (eq a (E err)) (In (E err) l)), ex (fun err' : ErrorI => eq (unionI a (inf_list l)) (E err'))
+++++
intros.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.

*****
H : or (eq a (E err)) (In (E err) l)
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => eq (unionI a (inf_list l)) (E err'))
+++++
destruct H.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.

*****
H : eq a (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => eq (unionI a (inf_list l)) (E err'))
+++++
subst.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
subst.

*****
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
*****
ex (fun err' : ErrorI => eq (unionI (E err) (inf_list l)) (E err'))
+++++
simpl.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
subst.
simpl.

*****
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
*****
ex (fun err' : ErrorI => eq (E (Enat (S (S (S Datatypes.O))))) (E err'))
+++++
eauto.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.

*****
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => eq (unionI a (inf_list l)) (E err'))
+++++
destruct (IHl err H).
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => eq (unionI a (inf_list l)) (E err'))
+++++
rewrite H0.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).
rewrite H0.

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => eq (unionI a (E x)) (E err'))
+++++
simpl.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).
rewrite H0.
simpl.

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => eq (unionI a (E x)) (E err'))
+++++
destruct a.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).
rewrite H0.
simpl.
destruct a.

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => eq (unionI (I n n0) (E x)) (E err'))
+++++
simpl.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).
rewrite H0.
simpl.
destruct a.
simpl.

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => eq (E (Enat (S (S (S Datatypes.O))))) (E err'))
+++++
eauto.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).
rewrite H0.
simpl.
destruct a.

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
e : ErrorI
*****
ex (fun err' : ErrorI => eq (unionI (E e) (E x)) (E err'))
+++++
simpl.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.
simpl.
intros.
destruct H.
destruct (IHl err H).
rewrite H0.
simpl.
destruct a.
simpl.

*****
H0 : eq (inf_list l) (E x)
x : ErrorI
H : In (E err) l
err : ErrorI
IHl : forall (err : ErrorI) (_ : In (E err) l),\nex (fun err' : ErrorI => eq (inf_list l) (E err'))
l : list TypeI
e : ErrorI
*****
ex (fun err' : ErrorI => eq (E (Enat (S (S (S Datatypes.O))))) (E err'))
+++++
eauto.
-----
Lemma in_inf_list_err : forall l err, In (E err) l -> exists err', inf_list l = E err'.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma in_inf_list_err_conv : forall l err, \n  inf_list l = E err ->\n  exists err', In (E err') l.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.

*****

*****
forall (l : list TypeI) (err : ErrorI) (_ : eq (inf_list l) (E err)), ex (fun err' : ErrorI => In (E err') l)
+++++
Proof.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.

*****

*****
forall (l : list TypeI) (err : ErrorI) (_ : eq (inf_list l) (E err)), ex (fun err' : ErrorI => In (E err') l)
+++++
induction l.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.

*****

*****
forall (err : ErrorI) (_ : eq (inf_list nil) (E err)), ex (fun err' : ErrorI => In (E err') nil)
+++++
simpl.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.

*****

*****
forall (err : ErrorI) (_ : eq (I Datatypes.O Datatypes.O) (E err)), ex (fun _ : ErrorI => False)
+++++
intros.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.

*****
H : eq (I Datatypes.O Datatypes.O) (E err)
err : ErrorI
*****
ex (fun _ : ErrorI => False)
+++++
trivial.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.

*****
H : eq (I Datatypes.O Datatypes.O) (E err)
err : ErrorI
*****
ex (fun _ : ErrorI => False)
+++++
discriminate.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.

*****
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
a : TypeI
*****
forall (err : ErrorI) (_ : eq (inf_list (cons a l)) (E err)), ex (fun err' : ErrorI => In (E err') (cons a l))
+++++
simpl.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.

*****
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
a : TypeI
*****
forall (err : ErrorI) (_ : eq (unionI a (inf_list l)) (E err)), ex (fun err' : ErrorI => or (eq a (E err')) (In (E err') l))
+++++
intros.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.

*****
H : eq (unionI a (inf_list l)) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => or (eq a (E err')) (In (E err') l))
+++++
trivial.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.

*****
H : eq (unionI a (inf_list l)) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
a : TypeI
*****
ex (fun err' : ErrorI => or (eq a (E err')) (In (E err') l))
+++++
destruct a.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.

*****
H : eq (unionI (I n n0) (inf_list l)) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
simpl in H.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.

*****
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n n2) (Init.Nat.max n0 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
case_eq (inf_list l).
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).

*****
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n n2) (Init.Nat.max n0 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
forall (n1 n2 : nat) (_ : eq (inf_list l) (I n1 n2)), ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
intros.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.

*****
H0 : eq (inf_list l) (I n1 n2)
n1,n2 : nat
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n n2) (Init.Nat.max n0 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
rewrite H0 in H.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.
rewrite H0 in H.

*****
H0 : eq (inf_list l) (I n1 n2)
H : eq (I (Init.Nat.max n n1) (Init.Nat.max n0 n2)) (E err)
n1,n2 : nat
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
discriminate.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).

*****
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n n2) (Init.Nat.max n0 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
forall (e : ErrorI) (_ : eq (inf_list l) (E e)), ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
intros.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.

*****
H0 : eq (inf_list l) (E e)
e : ErrorI
H : eq\n match inf_list l with\n | I n2 s2 => I (Init.Nat.max n n2) (Init.Nat.max n0 s2)\n | E _ => E (Enat (S (S (S Datatypes.O))))\n end (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
rewrite H0 in H.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.
rewrite H0 in H.

*****
H0 : eq (inf_list l) (E e)
e : ErrorI
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
destruct (IHl e).
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.
rewrite H0 in H.
destruct (IHl e).

*****
H0 : eq (inf_list l) (E e)
e : ErrorI
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
eq (inf_list l) (E e)
+++++
trivial.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.
rewrite H0 in H.
destruct (IHl e).

*****
H1 : In (E x) l
x : ErrorI
H0 : eq (inf_list l) (E e)
e : ErrorI
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
trivial.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.
rewrite H0 in H.
destruct (IHl e).
trivial.

*****
H1 : In (E x) l
x : ErrorI
H0 : eq (inf_list l) (E e)
e : ErrorI
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
ex (fun err' : ErrorI => or (eq (I n n0) (E err')) (In (E err') l))
+++++
exists x.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
case_eq (inf_list l).
intros.
rewrite H0 in H.
destruct (IHl e).
trivial.
exists x.

*****
H1 : In (E x) l
x : ErrorI
H0 : eq (inf_list l) (E e)
e : ErrorI
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
n,n0 : nat
*****
or (eq (I n n0) (E x)) (In (E x) l)
+++++
auto.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.

*****
H : eq (unionI (E e) (inf_list l)) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
e : ErrorI
*****
ex (fun err' : ErrorI => or (eq (E e) (E err')) (In (E err') l))
+++++
simpl in H.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.

*****
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
e : ErrorI
*****
ex (fun err' : ErrorI => or (eq (E e) (E err')) (In (E err') l))
+++++
eexists.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.
simpl.
intros.
trivial.
destruct a.
simpl in H.
eexists.

*****
H : eq (E (Enat (S (S (S Datatypes.O))))) (E err)
err : ErrorI
IHl : forall (err : ErrorI) (_ : eq (inf_list l) (E err)),\nex (fun err' : ErrorI => In (E err') l)
l : list TypeI
e : ErrorI
*****
or (eq (E e) (E ?err')) (In (E ?err') l)
+++++
eauto.
-----
Lemma in_inf_list_err_conv : forall l err, inf_list l = E err -> exists err', In (E err') l.
Proof.
induction l.

*****

*****

+++++
Qed.
-----
Lemma inf_list_ex : forall l e n s,\n In e l -> inf_list (map inf l) = I n s ->\n   exists n', exists s', n' <= n /\ s' <= s /\ inf e = I n' s'.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.

*****

*****
forall (l : list BCI) (e : BCI) (n s : nat) (_ : In e l) (_ : eq (inf_list (map inf l)) (I n s)), ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (inf e) (I n' s')))))
+++++
Proof.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.

*****

*****
forall (l : list BCI) (e : BCI) (n s : nat) (_ : In e l) (_ : eq (inf_list (map inf l)) (I n s)), ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (inf e) (I n' s')))))
+++++
intros.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.

*****
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (inf e) (I n' s')))))
+++++
case_eq (inf e).
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).

*****
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
forall (n0 n1 : nat) (_ : eq (inf e) (I n0 n1)), ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (I n0 n1) (I n' s')))))
+++++
intros n' s' H1.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
ex (fun n'0 : nat => ex (fun s'0 : nat => and (le n'0 n) (and (le s'0 s) (eq (I n' s') (I n'0 s'0)))))
+++++
exists n'.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
ex (fun s'0 : nat => and (le n' n) (and (le s'0 s) (eq (I n' s') (I n' s'0))))
+++++
exists s'.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
and (le n' n) (and (le s' s) (eq (I n' s') (I n' s')))
+++++
split.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
le n' n
+++++
apply in_inf_list_le_l with (l:=map inf l) (s:=s) (s':=s').
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
apply in_inf_list_le_l with (l:=map inf l) (s:=s) (s':=s').

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (I n' s') (map inf l)
+++++
rewrite <- H1.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
apply in_inf_list_le_l with (l:=map inf l) (s:=s) (s':=s').
rewrite <- H1.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (inf e) (map inf l)
+++++
apply in_map.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
apply in_inf_list_le_l with (l:=map inf l) (s:=s) (s':=s').
rewrite <- H1.
apply in_map.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In e l
+++++
assumption.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
apply in_inf_list_le_l with (l:=map inf l) (s:=s) (s':=s').

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
eq (inf_list (map inf l)) (I n s)
+++++
assumption.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
and (le s' s) (eq (I n' s') (I n' s'))
+++++
split.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
split.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
le s' s
+++++
apply in_inf_list_le_r with (l:=map inf l) (n:=n) (n':=n').
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
split.
apply in_inf_list_le_r with (l:=map inf l) (n:=n) (n':=n').

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (I n' s') (map inf l)
+++++
rewrite <- H1.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
split.
apply in_inf_list_le_r with (l:=map inf l) (n:=n) (n':=n').
rewrite <- H1.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (inf e) (map inf l)
+++++
apply in_map.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
split.
apply in_inf_list_le_r with (l:=map inf l) (n:=n) (n':=n').
rewrite <- H1.
apply in_map.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In e l
+++++
assumption.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
split.
apply in_inf_list_le_r with (l:=map inf l) (n:=n) (n':=n').

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
eq (inf_list (map inf l)) (I n s)
+++++
assumption.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros n' s' H1.
exists n'.
exists s'.
split.
split.

*****
H1 : eq (inf e) (I n' s')
n',s' : nat
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
eq (I n' s') (I n' s')
+++++
reflexivity.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).

*****
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
forall (e0 : ErrorI) (_ : eq (inf e) (E e0)), ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E e0) (I n' s')))))
+++++
intros err H1.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.

*****
H1 : eq (inf e) (E err)
err : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E err) (I n' s')))))
+++++
assert (In (E err) (map inf l)).
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).

*****
H1 : eq (inf e) (E err)
err : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (E err) (map inf l)
+++++
rewrite <- H1.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
rewrite <- H1.

*****
H1 : eq (inf e) (E err)
err : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (inf e) (map inf l)
+++++
apply in_map.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
rewrite <- H1.
apply in_map.

*****
H1 : eq (inf e) (E err)
err : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In e l
+++++
assumption.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).

*****
H2 : In (E err) (map inf l)
H1 : eq (inf e) (E err)
err : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
ex (fun n' : nat => ex (fun s' : nat => and (le n' n) (and (le s' s) (eq (E err) (I n' s')))))
+++++
contradict H0.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
contradict H0.

*****
H2 : In (E err) (map inf l)
H1 : eq (inf e) (E err)
err : ErrorI
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
not (eq (inf_list (map inf l)) (I n s))
+++++
intro.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
contradict H0.
intro.

*****
H0 : eq (inf_list (map inf l)) (I n s)
H2 : In (E err) (map inf l)
H1 : eq (inf e) (E err)
err : ErrorI
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
False
+++++
edestruct in_inf_list_err.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
contradict H0.
intro.
edestruct in_inf_list_err.

*****
H0 : eq (inf_list (map inf l)) (I n s)
H2 : In (E err) (map inf l)
H1 : eq (inf e) (E err)
err : ErrorI
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
In (E ?err) ?l
+++++
eauto.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
contradict H0.
intro.
edestruct in_inf_list_err.

*****
H3 : eq (inf_list ?l) (E x)
x : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H2 : In (E err) (map inf l)
H1 : eq (inf e) (E err)
err : ErrorI
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
False
+++++
rewrite H0 in H3.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).
intros err H1.
assert (In (E err) (map inf l)).
contradict H0.
intro.
edestruct in_inf_list_err.
rewrite H0 in H3.

*****
H3 : eq (I n s) (E x)
x : ErrorI
H0 : eq (inf_list (map inf l)) (I n s)
H2 : In (E err) (map inf l)
H1 : eq (inf e) (E err)
err : ErrorI
H : In e l
n,s : nat
e : BCI
l : list BCI
*****
False
+++++
discriminate.
-----
Lemma inf_list_ex : forall l e n s, In e l -> inf_list (map inf l) = I n s -> exists n', exists s', n' <= n /\\ s' <= s /\\ inf e = I n' s'.
Proof.
intros.
case_eq (inf e).

*****

*****

+++++
Qed.
-----
Opaque maxl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s',\n  n' <= n ->\n  s' <= s ->\n  inf e = I n' s' ->\n  arities (conv n s e) = ok_arities n s.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.

*****

*****
forall (e : BCI) (n s n' s' : nat) (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')), eq (arities (conv n s e)) (ok_arities n s)
+++++
Proof.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.

*****

*****
forall (e : BCI) (n s n' s' : nat) (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')), eq (arities (conv n s e)) (ok_arities n s)
+++++
induction e using BCI_ind2; simpl; intros; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.

*****
H1 : eq (I (S i) Datatypes.O) (I n' s')
H0 : le s' s
H : le n' n
i,n,s,n',s' : nat
*****
eq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb i m' end then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
injection H1; intros; subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.

*****
H0 : le Datatypes.O s
H : le (S i) n
H1 : eq (I (S i) Datatypes.O) (I (S i) Datatypes.O)
i,n,s : nat
*****
eq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb i m' end then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (n + s); intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le Datatypes.O s
H : le (S i) n
H1 : eq (I (S i) Datatypes.O) (I (S i) Datatypes.O)
i,n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
contradict H2; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.

*****
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le Datatypes.O s
H : le (S i) n
H1 : eq (I (S i) Datatypes.O) (I (S i) Datatypes.O)
i,n,s : nat
*****
eq (if Nat.leb i n0 then ok_arities n s else error_proj n s i) (ok_arities n s)
+++++
case_eq (leb i n0); intros; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.

*****
H3 : eq (Nat.leb i n0) false
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le Datatypes.O s
H : le (S i) n
H1 : eq (I (S i) Datatypes.O) (I (S i) Datatypes.O)
i,n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
apply leb_complete_conv in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.

*****
H3 : lt n0 i
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le Datatypes.O s
H : le (S i) n
H1 : eq (I (S i) Datatypes.O) (I (S i) Datatypes.O)
i,n,s : nat
*****
eq (error_proj n s i) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.

*****
H1 : eq (I Datatypes.O (S i)) (I n' s')
H0 : le s' s
H : le n' n
i,n,s,n',s' : nat
*****
eq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then ok_arities n s else error_proj n s (Init.Nat.add n i)) (ok_arities n s)
+++++
injection H1; intros; subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.

*****
H0 : le (S i) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S i)) (I Datatypes.O (S i))
i,n,s : nat
*****
eq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then ok_arities n s else error_proj n s (Init.Nat.add n i)) (ok_arities n s)
+++++
case_eq (n + s); intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le (S i) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S i)) (I Datatypes.O (S i))
i,n,s : nat
*****
eq (error_proj n s (Init.Nat.add n i)) (ok_arities n s)
+++++
contradict H2; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.

*****
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S i) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S i)) (I Datatypes.O (S i))
i,n,s : nat
*****
eq (if Nat.leb (Init.Nat.add n i) n0 then ok_arities n s else error_proj n s (Init.Nat.add n i)) (ok_arities n s)
+++++
case_eq (leb (n + i) n0); intros; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.

*****
H3 : eq (Nat.leb (Init.Nat.add n i) n0) false
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S i) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S i)) (I Datatypes.O (S i))
i,n,s : nat
*****
eq (error_proj n s (Init.Nat.add n i)) (ok_arities n s)
+++++
apply leb_complete_conv in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.

*****
H3 : lt n0 (Init.Nat.add n i)
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S i) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S i)) (I Datatypes.O (S i))
i,n,s : nat
*****
eq (error_proj n s (Init.Nat.add n i)) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
b : bool
*****
eq (if andb (aeq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) nil)) (ok_arities n s)
+++++
injection H1; intros; subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.

*****
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (if andb (aeq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) nil)) (ok_arities n s)
+++++
case_eq (n + s); intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (if andb (aeq (error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.

*****
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (if andb (aeq (if Nat.leb n n0 then ok_arities n s else error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (if Nat.leb n n0 then ok_arities n s else error_proj n s n) nil)) (ok_arities n s)
+++++
case_eq (leb n n0); intros; trivial; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.

*****
H3 : eq (Nat.leb n n0) true
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.

*****
H3 : eq (Nat.leb n n0) false
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
apply leb_complete_conv in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.

*****
H3 : lt n0 n
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
b : bool
*****
eq (error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
*****
eq (if andb (aeq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) nil)) (ok_arities n s)
+++++
injection H1; intros; subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.

*****
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (if andb (aeq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) nil)) (ok_arities n s)
+++++
case_eq (n + s); intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (if andb (aeq (error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.

*****
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (if andb (aeq (if Nat.leb n n0 then ok_arities n s else error_proj n s n) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (if Nat.leb n n0 then ok_arities n s else error_proj n s n) nil)) (ok_arities n s)
+++++
case_eq (leb n n0); intros; trivial; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.

*****
H3 : eq (Nat.leb n n0) true
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (ok_arities n s) nil)) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.

*****
H3 : eq (Nat.leb n n0) false
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
apply leb_complete_conv in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.

*****
H3 : lt n0 n
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S Datatypes.O)) (I Datatypes.O (S Datatypes.O))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S Datatypes.O)) nil (cons (error_proj n s n) nil)) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.

*****
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O))))) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
*****
eq (if andb (aeq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (ok_arities n s)) (andb (aeq (if match Init.Nat.add n s with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S n)) (ok_arities n s)) (andb (aeq (if match Init.Nat.add n s with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match Init.Nat.add n s with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (cons (if match Init.Nat.add n s with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S n)) (cons (if match Init.Nat.add n s with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match Init.Nat.add n s with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
injection H1; intros; subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (ok_arities n s)) (andb (aeq (if match Init.Nat.add n s with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S n)) (ok_arities n s)) (andb (aeq (if match Init.Nat.add n s with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match Init.Nat.add n s with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (if match Init.Nat.add n s with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s n) (cons (if match Init.Nat.add n s with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S n)) (cons (if match Init.Nat.add n s with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match Init.Nat.add n s with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
case_eq (n + s); intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.

*****
H2 : eq (Init.Nat.add n s) Datatypes.O
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (error_proj n s n) (ok_arities n s)) (andb (aeq (error_proj n s (S n)) (ok_arities n s)) (andb (aeq (error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (error_proj n s (S (S (S n)))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (error_proj n s n) (cons (error_proj n s (S n)) (cons (error_proj n s (S (S n))) (cons (error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.

*****
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if Nat.leb n n0 then ok_arities n s else error_proj n s n) (ok_arities n s)) (andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (ok_arities n s)) (andb (aeq (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (if Nat.leb n n0 then ok_arities n s else error_proj n s n) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
case_eq (leb n n0); intros; trivial; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.

*****
H3 : eq (Nat.leb n n0) true
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (ok_arities n s)) (andb (aeq (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true))) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
repeat rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.

*****
H3 : eq (Nat.leb n n0) true
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (ok_arities n s)) (andb (aeq (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true)) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
destruct n0; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.

*****
H3 : eq (Nat.leb n Datatypes.O) true
H2 : eq (Init.Nat.add n s) (S Datatypes.O)
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (error_proj n s (S n)) (cons (error_proj n s (S (S n))) (cons (error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.

*****
H3 : eq (Nat.leb n (S n0)) true
H2 : eq (Init.Nat.add n s) (S (S n0))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if Nat.leb n n0 then ok_arities n s else error_proj n s (S n)) (ok_arities n s)) (andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true)) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (if Nat.leb n n0 then ok_arities n s else error_proj n s (S n)) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
case_eq (leb n n0); intros; trivial; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.

*****
H4 : eq (Nat.leb n n0) true
H3 : eq (Nat.leb n (S n0)) true
H2 : eq (Init.Nat.add n s) (S (S n0))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true)) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
repeat rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.

*****
H4 : eq (Nat.leb n n0) true
H3 : eq (Nat.leb n (S n0)) true
H2 : eq (Init.Nat.add n s) (S (S n0))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
destruct n0; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.

*****
H4 : eq (Nat.leb n Datatypes.O) true
H3 : eq (Nat.leb n (S Datatypes.O)) true
H2 : eq (Init.Nat.add n s) (S (S Datatypes.O))
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_proj n s (S (S n))) (cons (error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.

*****
H4 : eq (Nat.leb n (S n0)) true
H3 : eq (Nat.leb n (S (S n0))) true
H2 : eq (Init.Nat.add n s) (S (S (S n0)))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if Nat.leb n n0 then ok_arities n s else error_proj n s (S (S n))) (ok_arities n s)) (andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (if Nat.leb n n0 then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
case_eq (leb n n0); intros; trivial; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.

*****
H5 : eq (Nat.leb n n0) true
H4 : eq (Nat.leb n (S n0)) true
H3 : eq (Nat.leb n (S (S n0))) true
H2 : eq (Init.Nat.add n s) (S (S (S n0)))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) (andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true) then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
repeat rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.

*****
H5 : eq (Nat.leb n n0) true
H4 : eq (Nat.leb n (S n0)) true
H3 : eq (Nat.leb n (S (S n0))) true
H2 : eq (Init.Nat.add n s) (S (S (S n0)))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
destruct n0; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.

*****
H5 : eq (Nat.leb n Datatypes.O) true
H4 : eq (Nat.leb n (S Datatypes.O)) true
H3 : eq (Nat.leb n (S (S Datatypes.O))) true
H2 : eq (Init.Nat.add n s) (S (S (S Datatypes.O)))
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.

*****
H5 : eq (Nat.leb n (S n0)) true
H4 : eq (Nat.leb n (S (S n0))) true
H3 : eq (Nat.leb n (S (S (S n0)))) true
H2 : eq (Init.Nat.add n s) (S (S (S (S n0))))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (aeq (if Nat.leb n n0 then ok_arities n s else error_proj n s (S (S (S n)))) (ok_arities n s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (if Nat.leb n n0 then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
case_eq (leb n n0); intros; trivial; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.

*****
H6 : eq (Nat.leb n n0) true
H5 : eq (Nat.leb n (S n0)) true
H4 : eq (Nat.leb n (S (S n0))) true
H3 : eq (Nat.leb n (S (S (S n0)))) true
H2 : eq (Init.Nat.add n s) (S (S (S (S n0))))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (if andb (andb (Nat.eqb n n) (Nat.eqb s s)) true then ok_arities n s else error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) nil))))) (ok_arities n s)
+++++
repeat rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.

*****
H6 : eq (Nat.leb n n0) false
H5 : eq (Nat.leb n (S n0)) true
H4 : eq (Nat.leb n (S (S n0))) true
H3 : eq (Nat.leb n (S (S (S n0)))) true
H2 : eq (Init.Nat.add n s) (S (S (S (S n0))))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
apply leb_complete_conv in H6.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.

*****
H6 : lt n0 n
H5 : eq (Nat.leb n (S n0)) true
H4 : eq (Nat.leb n (S (S n0))) true
H3 : eq (Nat.leb n (S (S (S n0)))) true
H2 : eq (Init.Nat.add n s) (S (S (S (S n0))))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.

*****
H5 : eq (Nat.leb n n0) false
H4 : eq (Nat.leb n (S n0)) true
H3 : eq (Nat.leb n (S (S n0))) true
H2 : eq (Init.Nat.add n s) (S (S (S n0)))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_proj n s (S (S n))) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
apply leb_complete_conv in H5.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.

*****
H5 : lt n0 n
H4 : eq (Nat.leb n (S n0)) true
H3 : eq (Nat.leb n (S (S n0))) true
H2 : eq (Init.Nat.add n s) (S (S (S n0)))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (ok_arities n s) (cons (error_proj n s (S (S n))) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.

*****
H4 : eq (Nat.leb n n0) false
H3 : eq (Nat.leb n (S n0)) true
H2 : eq (Init.Nat.add n s) (S (S n0))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (error_proj n s (S n)) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
apply leb_complete_conv in H4.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.

*****
H4 : lt n0 n
H3 : eq (Nat.leb n (S n0)) true
H2 : eq (Init.Nat.add n s) (S (S n0))
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (ok_arities n s) (cons (error_proj n s (S n)) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.

*****
H3 : eq (Nat.leb n n0) false
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (error_proj n s n) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
apply leb_complete_conv in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.

*****
H3 : lt n0 n
H2 : eq (Init.Nat.add n s) (S n0)
n0 : nat
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O)))))\n (I Datatypes.O (S (S (S (S Datatypes.O)))))
n,s : nat
*****
eq (error_comp (ok_arities Datatypes.O (S (S (S (S Datatypes.O))))) nil (cons (error_proj n s n) (cons (if match n0 with | Datatypes.O => false | S m' => Nat.leb n m' end then ok_arities n s else error_proj n s (S n)) (cons (if match n0 with | S (S m'0) => Nat.leb n m'0 | _ => false end then ok_arities n s else error_proj n s (S (S n))) (cons (if match n0 with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then ok_arities n s else error_proj n s (S (S (S n)))) nil))))) (ok_arities n s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.

*****
H1 : eq\n match inf e1 with\n | I gn gs =>\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S gn) (cons h0n (cons h1n nil))))\n (maxl\n (cons gs\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].

*****
He1 : eq (inf e1) (I n1 s1)
n1,s1 : nat
H1 : eq\n match inf e1 with\n | I gn gs =>\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S gn) (cons h0n (cons h1n nil))))\n (maxl\n (cons gs\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
2: rewrite H2 in H1; discriminate.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.

*****
He1 : eq (inf e1) (I n1 s1)
n1,s1 : nat
H1 : eq\n match inf e1 with\n | I gn gs =>\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S gn) (cons h0n (cons h1n nil))))\n (maxl\n (cons gs\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
rewrite He1 in H1.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.

*****
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n1) (cons h0n (cons h1n nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n1,s1 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].

*****
He2 : eq (inf e2) (I n2 s2)
n2,s2 : nat
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n1) (cons h0n (cons h1n nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n1,s1 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
2: rewrite H2 in H1; discriminate.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.

*****
He2 : eq (inf e2) (I n2 s2)
n2,s2 : nat
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n1) (cons h0n (cons h1n nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n1,s1 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
rewrite He2 in H1.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.

*****
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n1) (cons n2 (cons h1n nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n1,s1,n2,s2 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].

*****
He3 : eq (inf e3) (I n3 s3)
n3,s3 : nat
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n1) (cons n2 (cons h1n nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n1,s1,n2,s2 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
2: rewrite H2 in H1; discriminate.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.

*****
He3 : eq (inf e3) (I n3 s3)
n3,s3 : nat
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n1) (cons n2 (cons h1n nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n1,s1,n2,s2 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
rewrite He3 in H1.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.

*****
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
injection H1; intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.

*****
H3 : eq (maxl (cons (S n1) (cons n2 (cons n3 nil)))) n'
H2 : eq\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))) s'
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
apply maxl_eq_le3 in H2.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.

*****
H3 : eq (maxl (cons (S n1) (cons n2 (cons n3 nil)))) n'
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
apply maxl_eq_le3 in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv (Init.Nat.sub n (S Datatypes.O)) s e1) with | error_rec a a0 a1 => error_rec (error_rec a a0 a1) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (error_comp a l l0) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (error_proj n0 n1 n2) (arities (conv n (S s) e2)) (arities (conv n (S s) e3)) | ok_arities gn gs => match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities gn gs) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities gn gs) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n n0 n1 => error_rec (ok_arities gn gs) (ok_arities h0n h0s) (error_proj n n0 n1) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb gn m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb gs m' end) (Nat.eqb h0s h1s) then ok_arities h0n gs else error_rec (ok_arities gn gs) (ok_arities h0n h0s) (ok_arities h1n h1s) end end end (ok_arities n s)
+++++
erewrite IHe1;[ | | | eauto ]; try omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv n (S s) e2) with | error_rec a a0 a1 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (error_rec a a0 a1) (arities (conv n (S s) e3)) | error_comp a l l0 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (error_comp a l l0) (arities (conv n (S s) e3)) | error_proj n0 n1 n2 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (error_proj n0 n1 n2) (arities (conv n (S s) e3)) | ok_arities h0n h0s => match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities h0n h0s) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities h0n h0s) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities h0n h0s) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match h0n with | Datatypes.O => false | S m' => Nat.eqb (Init.Nat.sub n (S Datatypes.O)) m' end (Nat.eqb h0n h1n)) match h0s with | Datatypes.O => false | S m' => Nat.eqb s m' end) (Nat.eqb h0s h1s) then ok_arities h0n s else error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities h0n h0s) (ok_arities h1n h1s) end end (ok_arities n s)
+++++
erewrite IHe2;[ | | | eauto ]; try omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq match arities (conv n (S s) e3) with | error_rec a a0 a1 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities n (S s)) (error_rec a a0 a1) | error_comp a l l0 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities n (S s)) (error_comp a l l0) | error_proj n0 n1 n2 => error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities n (S s)) (error_proj n0 n1 n2) | ok_arities h1n h1s => if andb (andb (andb match n with | Datatypes.O => false | S m' => Nat.eqb (Init.Nat.sub n (S Datatypes.O)) m' end (Nat.eqb n h1n)) (Nat.eqb s s)) (Nat.eqb (S s) h1s) then ok_arities n s else error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities n (S s)) (ok_arities h1n h1s) end (ok_arities n s)
+++++
erewrite IHe3;[ | | | eauto ]; try omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq (if andb (andb (andb match n with | Datatypes.O => false | S m' => Nat.eqb (Init.Nat.sub n (S Datatypes.O)) m' end (Nat.eqb n n)) (Nat.eqb s s)) (Nat.eqb (S s) (S s)) then ok_arities n s else error_rec (ok_arities (Init.Nat.sub n (S Datatypes.O)) s) (ok_arities n (S s)) (ok_arities n (S s))) (ok_arities n s)
+++++
destruct n.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' Datatypes.O
s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq (if andb (andb (andb false (Nat.eqb Datatypes.O Datatypes.O)) (Nat.eqb s s)) (Nat.eqb (S s) (S s)) then ok_arities Datatypes.O s else error_rec (ok_arities (Init.Nat.sub Datatypes.O (S Datatypes.O)) s) (ok_arities Datatypes.O (S s)) (ok_arities Datatypes.O (S s))) (ok_arities Datatypes.O s)
+++++
elimtype False; omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' (S n)
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq (if andb (andb (andb (Nat.eqb (Init.Nat.sub (S n) (S Datatypes.O)) n) (Nat.eqb (S n) (S n))) (Nat.eqb s s)) (Nat.eqb (S s) (S s)) then ok_arities (S n) s else error_rec (ok_arities (Init.Nat.sub (S n) (S Datatypes.O)) s) (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (ok_arities (S n) s)
+++++
replace (S n - 1) with n.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' (S n)
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq (if andb (andb (andb (Nat.eqb n n) (Nat.eqb (S n) (S n))) (Nat.eqb s s)) (Nat.eqb (S s) (S s)) then ok_arities (S n) s else error_rec (ok_arities n s) (ok_arities (S n) (S s)) (ok_arities (S n) (S s))) (ok_arities (S n) s)
+++++
do 4 rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.

*****
H3 : and (le (S n1) n') (and (le n2 n') (le n3 n'))
H2 : and (le s1 s')\n (and (le (Init.Nat.sub s2 (S Datatypes.O)) s')\n (le (Init.Nat.sub s3 (S Datatypes.O)) s'))
He3 : eq (inf e3) (I n3 s3)
He2 : eq (inf e2) (I n2 s2)
He1 : eq (inf e1) (I n1 s1)
H1 : eq\n (I (maxl (cons (S n1) (cons n2 (cons n3 nil))))\n (maxl\n (cons s1\n (cons (Init.Nat.sub s2 (S Datatypes.O))\n (cons (Init.Nat.sub s3 (S Datatypes.O)) nil)))))\n (I n' s')
n1,s1,n2,s2,n3,s3 : nat
H0 : le s' s
H : le n' (S n)
n,s,n',s' : nat
IHe3 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e3) (I n' s')),\neq (arities (conv n s e3)) (ok_arities n s)
IHe2 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e2) (I n' s')),\neq (arities (conv n s e2)) (ok_arities n s)
IHe1 : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e1) (I n' s')),\neq (arities (conv n s e1)) (ok_arities n s)
e1,e2,e3 : BCI
*****
eq n (Init.Nat.sub (S n) (S Datatypes.O))
+++++
omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.

*****
H3 : eq\n match inf e with\n | I hn hs =>\n if andb (Nat.leb hn (length rl)) (Nat.leb hs (length tl))\n then\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n else E (Enat (S (S (S (S (S (S Datatypes.O)))))))\n | E e => E e\n end (I n' s')
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].

*****
H4 : eq (inf e) (I n0 n1)
H3 : eq\n (if andb (Nat.leb n0 (length rl)) (Nat.leb n1 (length tl))\n then\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n else E (Enat (S (S (S (S (S (S Datatypes.O)))))))) \n (I n' s')
n0,n1 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.

*****
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n (if andb true true\n then\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n else E (Enat (S (S (S (S (S (S Datatypes.O)))))))) \n (I n' s')
n0,n1 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
simpl in H3.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.

*****
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end (I n' s')
n0,n1 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].

*****
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb n3 Datatypes.O\n then I (Init.Nat.max n2 nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end (I n' s')
n0,n1,n2,n3 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].

*****
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n (if Nat.eqb n3 Datatypes.O\n then I (Init.Nat.max n2 n4) n5\n else E (Enat (S (S (S (S Datatypes.O)))))) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].

*****
H9 : eq (Nat.eqb n3 Datatypes.O) true
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
apply leb_complete in H5.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.

*****
H9 : eq (Nat.eqb n3 Datatypes.O) true
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
apply leb_complete in H6.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.

*****
H9 : eq (Nat.eqb n3 Datatypes.O) true
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
apply beq_nat_true in H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq match arities (conv (length rl) (length tl) e) with | error_rec a a0 a1 => error_comp (error_rec a a0 a1) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_comp a l l0 => error_comp (error_comp a l l0) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | error_proj n0 n1 n2 => error_comp (error_proj n0 n1 n2) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) | ok_arities hn hs => if andb (andb (andb (Nat.eqb hn (length (map (conv n Datatypes.O) rl))) (Nat.eqb hs (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities hn hs) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl)) end (ok_arities n s)
+++++
erewrite IHe; [ | | | eauto]; try omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb (andb (andb (Nat.eqb (length rl) (length (map (conv n Datatypes.O) rl))) (Nat.eqb (length tl) (length (map (conv n s) tl)))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
do 2 rewrite map_length.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb (andb (andb (Nat.eqb (length rl) (length rl)) (Nat.eqb (length tl) (length tl))) (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
do 2 rewrite <- beq_nat_refl; simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
injection H3; clear H3; intros; subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
assert (n2 <= max n2 n4 /\ n4 <= max n2 n4).
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
+++++
split.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le n2 (Init.Nat.max n2 n4)
+++++
apply Max.le_max_l.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le n4 (Init.Nat.max n2 n4)
+++++
apply Max.le_max_r.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl)) (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (if andb true true then ok_arities n s else error_comp (ok_arities (length rl) (length tl)) (map arities (map (conv n Datatypes.O) rl)) (map arities (map (conv n s) tl))) (ok_arities n s)
+++++
simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq true (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl))
+++++
symmetry.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) true
+++++
eapply forallb_forall.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
forall (x : BC) (_ : In x (map (conv n s) tl)), eq (aeq (arities x) (ok_arities n s)) true
+++++
intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.

*****
H9 : In x (map (conv n s) tl)
x : BC
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities x) (ok_arities n s)) true
+++++
apply in_map_iff in H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.

*****
H9 : ex (fun x0 : BCI => and (eq (conv n s x0) x) (In x0 tl))
x : BC
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities x) (ok_arities n s)) true
+++++
destruct H9 as (e' & H10 & H11).
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).

*****
H11 : In e' tl
H10 : eq (conv n s e') x
e' : BCI
x : BC
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities x) (ok_arities n s)) true
+++++
subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.

*****
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities (conv n s e')) (ok_arities n s)) true
+++++
destruct (inf_list_ex _ _ _ _ H11 H8).
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).

*****
H9 : ex\n (fun s'0 : nat =>\n and (le x n4) (and (le s'0 s') (eq (inf e') (I x s'0))))
x : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities (conv n s e')) (ok_arities n s)) true
+++++
destruct H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities (conv n s e')) (ok_arities n s)) true
+++++
erewrite H0.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (ok_arities n s) (ok_arities n s)) true
+++++
simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (andb (Nat.eqb n n) (Nat.eqb s s)) true
+++++
do 2 rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
In e' tl
+++++
trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le ?n' n
+++++
3: apply H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le x n
+++++
omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.

*****
H9 : and (le x n4) (and (le x0 s') (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' tl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le x0 s
+++++
omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq true (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl))
+++++
symmetry.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (forallb (fun ne : BC => aeq (arities ne) (ok_arities n Datatypes.O)) (map (conv n Datatypes.O) rl)) true
+++++
eapply forallb_forall.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.

*****
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
forall (x : BC) (_ : In x (map (conv n Datatypes.O) rl)), eq (aeq (arities x) (ok_arities n Datatypes.O)) true
+++++
intros.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.

*****
H9 : In x (map (conv n Datatypes.O) rl)
x : BC
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities x) (ok_arities n Datatypes.O)) true
+++++
apply in_map_iff in H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.

*****
H9 : ex (fun x0 : BCI => and (eq (conv n Datatypes.O x0) x) (In x0 rl))
x : BC
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities x) (ok_arities n Datatypes.O)) true
+++++
destruct H9 as (e' & H10 & H11).
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).

*****
H11 : In e' rl
H10 : eq (conv n Datatypes.O e') x
e' : BCI
x : BC
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities x) (ok_arities n Datatypes.O)) true
+++++
subst.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.

*****
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities (conv n Datatypes.O e')) (ok_arities n Datatypes.O)) true
+++++
destruct (inf_list_ex _ _ _ _ H11 H7).
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).

*****
H9 : ex\n (fun s' : nat =>\n and (le x n2) (and (le s' Datatypes.O) (eq (inf e') (I x s'))))
x : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities (conv n Datatypes.O e')) (ok_arities n Datatypes.O)) true
+++++
destruct H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (arities (conv n Datatypes.O e')) (ok_arities n Datatypes.O)) true
+++++
erewrite H.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (aeq (ok_arities n Datatypes.O) (ok_arities n Datatypes.O)) true
+++++
simpl.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.
simpl.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
eq (andb (Nat.eqb n n) true) true
+++++
rewrite <- beq_nat_refl; simpl; trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.
simpl.
rewrite <- beq_nat_refl; simpl; trivial.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
In e' rl
+++++
trivial.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.
simpl.
rewrite <- beq_nat_refl; simpl; trivial.
trivial.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le ?n' n
+++++
3: apply H9.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.
simpl.
rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le x n
+++++
omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.
simpl.
rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.

*****
H9 : and (le x n2) (and (le x0 Datatypes.O) (eq (inf e') (I x x0)))
x,x0 : nat
H11 : In e' rl
e' : BCI
H3 : and (le n2 (Init.Nat.max n2 n4)) (le n4 (Init.Nat.max n2 n4))
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
IHe : forall (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf e) (I n' s')),\neq (arities (conv n s e)) (ok_arities n s)
H0 : forall (s : BCI) (_ : In s tl) (n s0 n' s' : nat) \n (_ : le n' n) (_ : le s' s0) (_ : eq (inf s) (I n' s')),\neq (arities (conv n s0 s)) (ok_arities n s0)
H : forall (r : BCI) (_ : In r rl) (n s n' s' : nat) (_ : le n' n)\n (_ : le s' s) (_ : eq (inf r) (I n' s')),\neq (arities (conv n s r)) (ok_arities n s)
rl,tl : list BCI
e : BCI
*****
le x0 Datatypes.O
+++++
omega.
-----
Lemma inf_correct : forall (e : BCI) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> arities (conv n s e) = ok_arities n s.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb i n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
contradict H2; omega.
case_eq (leb (n + i) n0); intros; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H3.
elimtype False; omega.
injection H1; intros; subst.
case_eq (n + s); intros.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
destruct n0; simpl.
elimtype False; omega.
case_eq (leb n n0); intros; trivial; simpl.
repeat rewrite <- beq_nat_refl; simpl; trivial.
apply leb_complete_conv in H6.
elimtype False; omega.
apply leb_complete_conv in H5.
elimtype False; omega.
apply leb_complete_conv in H4.
elimtype False; omega.
apply leb_complete_conv in H3.
elimtype False; omega.
case_eq (inf e1); [ intros n1 s1 He1 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He1 in H1.
case_eq (inf e2); [ intros n2 s2 He2 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He2 in H1.
case_eq (inf e3); [ intros n3 s3 He3 | intros ].
2: rewrite H2 in H1; discriminate.
rewrite He3 in H1.
injection H1; intros.
apply maxl_eq_le3 in H2.
apply maxl_eq_le3 in H3.
erewrite IHe1;[ | | | eauto ]; try omega.
erewrite IHe2;[ | | | eauto ]; try omega.
erewrite IHe3;[ | | | eauto ]; try omega.
destruct n.
elimtype False; omega.
replace (S n - 1) with n.
do 4 rewrite <- beq_nat_refl; simpl; trivial.
omega.
case_eq (inf e); intros; rewrite H4 in H3; [ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
do 2 rewrite map_length.
do 2 rewrite <- beq_nat_refl; simpl.
injection H3; clear H3; intros; subst.
assert (n2 <= max n2 n4 /\\ n4 <= max n2 n4).
split.
apply Max.le_max_l.
apply Max.le_max_r.
replace (forallb (fun ne : BC => aeq (arities ne) (ok_arities n 0)) (map (conv n 0) rl)) with true.
replace ( forallb (fun se : BC => aeq (arities se) (ok_arities n s)) (map (conv n s) tl)) with true.
simpl; trivial.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H8).
destruct H9.
erewrite H0.
simpl.
do 2 rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.
symmetry.
eapply forallb_forall.
intros.
apply in_map_iff in H9.
destruct H9 as (e' & H10 & H11).
subst.
destruct (inf_list_ex _ _ _ _ H11 H7).
destruct H9.
erewrite H.
simpl.
rewrite <- beq_nat_refl; simpl; trivial.
trivial.
3: apply H9.
omega.
omega.

*****

*****

+++++
Qed.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) \n  n s n' s',\n  n' <= n ->\n  s' <= s ->\n  inf e = I n' s' ->\n  sem (conv n s e) vnl vsl = semI e vnl vsl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.

*****

*****
forall (e : BCI) (vnl vsl : list (list bool)) (n s n' s' : nat) (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')), eq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
+++++
Proof.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.

*****

*****
forall (e : BCI) (vnl vsl : list (list bool)) (n s n' s' : nat) (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')), eq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
+++++
induction e using BCI_ind2; simpl; intros; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.

*****
H1 : eq (I (S i) Datatypes.O) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (nth i vnl nil)
+++++
injection H1; clear H1; intros; subst.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.

*****
H0 : le Datatypes.O s
H : le (S i) n
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb i m' end then nth i vnl nil else nth (Init.Nat.sub i n) vsl nil) (nth i vnl nil)
+++++
destruct n.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.

*****
H0 : le Datatypes.O s
H : le (S i) Datatypes.O
s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.sub i Datatypes.O) vsl nil) (nth i vnl nil)
+++++
contradict H; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.

*****
H0 : le Datatypes.O s
H : le (S i) (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (if Nat.leb i n then nth i vnl nil else nth (Init.Nat.sub i (S n)) vsl nil) (nth i vnl nil)
+++++
case_eq (leb i n); intros; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.

*****
H1 : eq (Nat.leb i n) false
H0 : le Datatypes.O s
H : le (S i) (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth i vnl nil)
+++++
apply leb_complete_conv in H1.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.

*****
H1 : lt n i
H0 : le Datatypes.O s
H : le (S i) (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.sub i (S n)) vsl nil) (nth i vnl nil)
+++++
contradict H; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.

*****
H1 : eq (I Datatypes.O (S i)) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else nth (Init.Nat.sub (Init.Nat.add n i) n) vsl nil) (nth i vsl nil)
+++++
injection H1; clear H1; intros; subst.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.

*****
H0 : le (S i) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb (Init.Nat.add n i) m' end then nth (Init.Nat.add n i) vnl nil else nth (Init.Nat.sub (Init.Nat.add n i) n) vsl nil) (nth i vsl nil)
+++++
destruct n.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.

*****
H0 : le (S i) s
H : le Datatypes.O Datatypes.O
s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.sub (Init.Nat.add Datatypes.O i) Datatypes.O) vsl nil) (nth i vsl nil)
+++++
simpl; rewrite <- (minus_n_O i); trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.

*****
H0 : le (S i) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (if Nat.leb (Init.Nat.add (S n) i) n then nth (Init.Nat.add (S n) i) vnl nil else nth (Init.Nat.sub (Init.Nat.add (S n) i) (S n)) vsl nil) (nth i vsl nil)
+++++
case_eq (leb (S n + i) n); intros.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.

*****
H1 : eq (Nat.leb (Init.Nat.add (S n) i) n) true
H0 : le (S i) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.add (S n) i) vnl nil) (nth i vsl nil)
+++++
apply leb_complete in H1.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.

*****
H1 : le (Init.Nat.add (S n) i) n
H0 : le (S i) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.add (S n) i) vnl nil) (nth i vsl nil)
+++++
elimtype False; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.

*****
H1 : eq (Nat.leb (Init.Nat.add (S n) i) n) false
H0 : le (S i) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq (nth (Init.Nat.sub (Init.Nat.add (S n) i) (S n)) vsl nil) (nth i vsl nil)
+++++
replace (S n + i - S n) with i; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.

*****
H1 : eq (Nat.leb (Init.Nat.add (S n) i) n) false
H0 : le (S i) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
i : nat
*****
eq i (Init.Nat.sub (Init.Nat.add (S n) i) (S n))
+++++
omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (if match n with | Datatypes.O => false | S m' => Nat.leb n m' end then nth n vnl nil else nth (Init.Nat.sub n n) vsl nil)) (cons b (hd nil vsl))
+++++
injection H1; clear H1; intros; subst.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.

*****
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (if match n with | Datatypes.O => false | S m' => Nat.leb n m' end then nth n vnl nil else nth (Init.Nat.sub n n) vsl nil)) (cons b (hd nil vsl))
+++++
case_eq n; simpl; intros.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.

*****
H1 : eq n Datatypes.O
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (nth Datatypes.O vsl nil)) (cons b (hd nil vsl))
+++++
destruct vsl; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.

*****
H1 : eq n (S n0)
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (if match n0 with | Datatypes.O => false | S m' => Nat.leb n0 m' end then nth (S n0) vnl nil else nth (Init.Nat.sub n0 n0) vsl nil)) (cons b (hd nil vsl))
+++++
destruct n0.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.

*****
H1 : eq n (S Datatypes.O)
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (nth (Init.Nat.sub Datatypes.O Datatypes.O) vsl nil)) (cons b (hd nil vsl))
+++++
destruct vsl; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.

*****
H1 : eq n (S (S n0))
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (if Nat.leb (S n0) n0 then nth (S (S n0)) vnl nil else nth (Init.Nat.sub (S n0) (S n0)) vsl nil)) (cons b (hd nil vsl))
+++++
case_eq (leb (S n0) n0); intros.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.

*****
H2 : eq (Nat.leb (S n0) n0) true
H1 : eq n (S (S n0))
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (nth (S (S n0)) vnl nil)) (cons b (hd nil vsl))
+++++
apply leb_complete in H2.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.

*****
H2 : le (S n0) n0
H1 : eq n (S (S n0))
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (nth (S (S n0)) vnl nil)) (cons b (hd nil vsl))
+++++
elimtype False; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.

*****
H2 : eq (Nat.leb (S n0) n0) false
H1 : eq n (S (S n0))
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (nth (Init.Nat.sub (S n0) (S n0)) vsl nil)) (cons b (hd nil vsl))
+++++
rewrite minus_diag.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.

*****
H2 : eq (Nat.leb (S n0) n0) false
H1 : eq n (S (S n0))
n0 : nat
H0 : le (S Datatypes.O) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
b : bool
*****
eq (cons b (nth Datatypes.O vsl nil)) (cons b (hd nil vsl))
+++++
destruct vsl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq (tl (if match n with | Datatypes.O => false | S m' => Nat.leb n m' end then nth n vnl nil else nth (Init.Nat.sub n n) vsl nil)) (tl (hd nil vsl))
+++++
destruct n.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' Datatypes.O
s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq (tl (nth (Init.Nat.sub Datatypes.O Datatypes.O) vsl nil)) (tl (hd nil vsl))
+++++
simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' Datatypes.O
s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq (tl (nth Datatypes.O vsl nil)) (tl (hd nil vsl))
+++++
erewrite hd_nth_0; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' (S n)
n,s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq (tl (if Nat.leb (S n) n then nth (S n) vnl nil else nth (Init.Nat.sub (S n) (S n)) vsl nil)) (tl (hd nil vsl))
+++++
rewrite leb_correct_conv;[ | omega].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' (S n)
n,s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq (tl (nth (Init.Nat.sub (S n) (S n)) vsl nil)) (tl (hd nil vsl))
+++++
rewrite minus_diag; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.

*****
H1 : eq (I Datatypes.O (S Datatypes.O)) (I n' s')
H0 : le s' s
H : le n' (S n)
n,s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq (tl (nth Datatypes.O vsl nil)) (tl (hd nil vsl))
+++++
erewrite hd_nth_0; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.

*****
H1 : eq (I Datatypes.O (S (S (S (S Datatypes.O))))) (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
*****
eq match (if match n with | Datatypes.O => false | S m' => Nat.leb n m' end then nth n vnl nil else nth (Init.Nat.sub n n) vsl nil) with | nil => if match n with | S (S m'0) => Nat.leb n m'0 | _ => false end then nth (S n) vnl nil else nth match n with | Datatypes.O => S n | S l => Init.Nat.sub n l end vsl nil | cons true _ => if match n with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then nth (S (S n)) vnl nil else nth match n with | Datatypes.O => S (S n) | S Datatypes.O => S n | S (S l1) => Init.Nat.sub n l1 end vsl nil | cons false _ => if match n with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S Datatypes.O) => S n | S (S (S l2)) => Init.Nat.sub n l2 end vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
injection H1; clear H1; intros; subst.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O n
n,s : nat
vnl,vsl : list (list bool)
*****
eq match (if match n with | Datatypes.O => false | S m' => Nat.leb n m' end then nth n vnl nil else nth (Init.Nat.sub n n) vsl nil) with | nil => if match n with | S (S m'0) => Nat.leb n m'0 | _ => false end then nth (S n) vnl nil else nth match n with | Datatypes.O => S n | S l => Init.Nat.sub n l end vsl nil | cons true _ => if match n with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then nth (S (S n)) vnl nil else nth match n with | Datatypes.O => S (S n) | S Datatypes.O => S n | S (S l1) => Init.Nat.sub n l1 end vsl nil | cons false _ => if match n with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S Datatypes.O) => S n | S (S (S l2)) => Init.Nat.sub n l2 end vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct n.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
vnl,vsl : list (list bool)
*****
eq match nth (Init.Nat.sub Datatypes.O Datatypes.O) vsl nil with | nil => nth (S Datatypes.O) vsl nil | cons true _ => nth (S (S Datatypes.O)) vsl nil | cons false _ => nth (S (S (S Datatypes.O))) vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
vnl,vsl : list (list bool)
*****
eq match nth Datatypes.O vsl nil with | nil => nth (S Datatypes.O) vsl nil | cons true _ => nth (S (S Datatypes.O)) vsl nil | cons false _ => nth (S (S (S Datatypes.O))) vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match l with | nil => nth Datatypes.O vsl nil | cons true _ => nth (S Datatypes.O) vsl nil | cons false _ => nth (S (S Datatypes.O)) vsl nil end match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
l : list bool
vnl : list (list bool)
*****
eq match l with | nil | _ => nil end nil
+++++
destruct l; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
l : list bool
b : bool
vnl : list (list bool)
*****
eq (if b then nil else nil) nil
+++++
destruct b; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
vsl : list (list bool)
l,l0 : list bool
vnl : list (list bool)
*****
eq match l with | nil => l0 | cons true _ => nth Datatypes.O vsl nil | cons false _ => nth (S Datatypes.O) vsl nil end match vsl with | nil => match l with | nil => l0 | cons _ _ => nil end | cons c nil => match l with | nil => l0 | cons true _ => c | cons false _ => nil end | cons c (cons d _) => match l with | nil => l0 | cons true _ => c | cons false _ => d end end
+++++
destruct vsl; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
l,l0 : list bool
vnl : list (list bool)
*****
eq match l with | nil => l0 | _ => nil end match l with | nil => l0 | cons _ _ => nil end
+++++
destruct l; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
l,l0 : list bool
b : bool
vnl : list (list bool)
*****
eq (if b then nil else nil) nil
+++++
destruct b; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O Datatypes.O
s : nat
vsl : list (list bool)
l,l0,l1 : list bool
vnl : list (list bool)
*****
eq match l with | nil => l0 | cons true _ => l1 | cons false _ => nth Datatypes.O vsl nil end match vsl with | nil => match l with | nil => l0 | cons true _ => l1 | cons false _ => nil end | cons d _ => match l with | nil => l0 | cons true _ => l1 | cons false _ => d end end
+++++
destruct vsl; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
*****
eq match (if Nat.leb (S n) n then nth (S n) vnl nil else nth (Init.Nat.sub (S n) (S n)) vsl nil) with | nil => if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S n)) vnl nil else nth (Init.Nat.sub (S n) n) vsl nil | cons true _ => if match n with | S (S m'0) => Nat.leb (S n) m'0 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S n) | S l0 => Init.Nat.sub (S n) l0 end vsl nil | cons false _ => if match n with | S (S (S m'1)) => Nat.leb (S n) m'1 | _ => false end then nth (S (S (S (S n)))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S l1) => Init.Nat.sub (S n) l1 end vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
rewrite leb_correct_conv;[ | omega].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
*****
eq match nth (Init.Nat.sub (S n) (S n)) vsl nil with | nil => if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S n)) vnl nil else nth (Init.Nat.sub (S n) n) vsl nil | cons true _ => if match n with | S (S m'0) => Nat.leb (S n) m'0 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S n) | S l0 => Init.Nat.sub (S n) l0 end vsl nil | cons false _ => if match n with | S (S (S m'1)) => Nat.leb (S n) m'1 | _ => false end then nth (S (S (S (S n)))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S l1) => Init.Nat.sub (S n) l1 end vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
rewrite minus_diag.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
*****
eq match nth Datatypes.O vsl nil with | nil => if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S n)) vnl nil else nth (Init.Nat.sub (S n) n) vsl nil | cons true _ => if match n with | S (S m'0) => Nat.leb (S n) m'0 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S n) | S l0 => Init.Nat.sub (S n) l0 end vsl nil | cons false _ => if match n with | S (S (S m'1)) => Nat.leb (S n) m'1 | _ => false end then nth (S (S (S (S n)))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S l1) => Init.Nat.sub (S n) l1 end vsl nil end match vsl with | nil => nil | cons a nil => nil | cons a (cons b nil) => match a with | nil => b | cons _ _ => nil end | cons a (cons b (cons c nil)) => match a with | nil => b | cons true _ => c | cons false _ => nil end | cons a (cons b (cons c (cons d _))) => match a with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct vsl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vnl : list (list bool)
*****
eq match nth Datatypes.O nil nil with | nil => if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S n)) vnl nil else nth (Init.Nat.sub (S n) n) nil nil | cons true _ => if match n with | S (S m'0) => Nat.leb (S n) m'0 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S n) | S l0 => Init.Nat.sub (S n) l0 end nil nil | cons false _ => if match n with | S (S (S m'1)) => Nat.leb (S n) m'1 | _ => false end then nth (S (S (S (S n)))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S l1) => Init.Nat.sub (S n) l1 end nil nil end nil
+++++
simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vnl : list (list bool)
*****
eq (if match n with | S (S m'0) => Nat.leb n m'0 | _ => false end then nth (S (S n)) vnl nil else match match n with | Datatypes.O => S n | S l => Init.Nat.sub n l end with | Datatypes.O | _ => nil end) nil
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S n))
n,s : nat
vnl : list (list bool)
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S (S n))) vnl nil else match Init.Nat.sub (S n) n with | Datatypes.O | _ => nil end) nil
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vnl : list (list bool)
*****
eq (if Nat.leb (S (S n)) n then nth (S (S (S (S n)))) vnl nil else match Init.Nat.sub (S (S n)) (S n) with | Datatypes.O | _ => nil end) nil
+++++
rewrite leb_correct_conv;[ | omega].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vnl : list (list bool)
*****
eq match Init.Nat.sub (S (S n)) (S n) with | Datatypes.O | _ => nil end nil
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match nth Datatypes.O (cons l vsl) nil with | nil => if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S n)) vnl nil else nth (Init.Nat.sub (S n) n) (cons l vsl) nil | cons true _ => if match n with | S (S m'0) => Nat.leb (S n) m'0 | _ => false end then nth (S (S (S n))) vnl nil else nth match n with | Datatypes.O => S (S n) | S l => Init.Nat.sub (S n) l end (cons l vsl) nil | cons false _ => if match n with | S (S (S m'1)) => Nat.leb (S n) m'1 | _ => false end then nth (S (S (S (S n)))) vnl nil else nth match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S l1) => Init.Nat.sub (S n) l1 end (cons l vsl) nil end match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end
+++++
simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match l with | nil => if match n with | S (S m'0) => Nat.leb n m'0 | _ => false end then nth (S (S n)) vnl nil else match match n with | Datatypes.O => S n | S l => Init.Nat.sub n l end with | Datatypes.O => l | S m => nth m vsl nil end | cons true _ => if match n with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then nth (S (S (S n))) vnl nil else match match n with | Datatypes.O => S (S n) | S Datatypes.O => S n | S (S l1) => Init.Nat.sub n l1 end with | Datatypes.O => l | S m => nth m vsl nil end | cons false _ => if match n with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then nth (S (S (S (S n)))) vnl nil else match match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S Datatypes.O) => S n | S (S (S l2)) => Init.Nat.sub n l2 end with | Datatypes.O => l | S m => nth m vsl nil end end match vsl with | nil => nil | cons b nil => match l with | nil => b | cons _ _ => nil end | cons b (cons c nil) => match l with | nil => b | cons true _ => c | cons false _ => nil end | cons b (cons c (cons d _)) => match l with | nil => b | cons true _ => c | cons false _ => d end end
+++++
destruct l; simpl; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vnl,vsl : list (list bool)
*****
eq (if match n with | S (S m'0) => Nat.leb n m'0 | _ => false end then nth (S (S n)) vnl nil else match match n with | Datatypes.O => S n | S l => Init.Nat.sub n l end with | Datatypes.O => nil | S m => nth m vsl nil end) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S Datatypes.O)
s : nat
vnl,vsl : list (list bool)
*****
eq (nth Datatypes.O vsl nil) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S n))
n,s : nat
vnl,vsl : list (list bool)
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb (S n) m' end then nth (S (S (S n))) vnl nil else match Init.Nat.sub (S n) n with | Datatypes.O => nil | S m => nth m vsl nil end) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S Datatypes.O))
s : nat
vnl,vsl : list (list bool)
*****
eq match Init.Nat.sub (S Datatypes.O) Datatypes.O with | Datatypes.O => nil | S m => nth m vsl nil end match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S Datatypes.O))
s : nat
vnl,vsl : list (list bool)
*****
eq (nth Datatypes.O vsl nil) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vnl,vsl : list (list bool)
*****
eq (if Nat.leb (S (S n)) n then nth (S (S (S (S n)))) vnl nil else match Init.Nat.sub (S (S n)) (S n) with | Datatypes.O => nil | S m => nth m vsl nil end) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
rewrite leb_correct_conv;[ | omega].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vnl,vsl : list (list bool)
*****
eq match Init.Nat.sub (S (S n)) (S n) with | Datatypes.O => nil | S m => nth m vsl nil end match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vnl,vsl : list (list bool)
*****
eq (nth (Init.Nat.sub (S n) (S n)) vsl nil) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
rewrite minus_diag.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vnl,vsl : list (list bool)
*****
eq (nth Datatypes.O vsl nil) match vsl with | nil => nil | cons b nil | cons b (cons _ nil) | cons b (cons _ (cons _ _)) => b end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vsl : list (list bool)
l : list bool
b : bool
vnl : list (list bool)
*****
eq (if b then if match n with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then nth (S (S (S n))) vnl nil else match match n with | Datatypes.O => S (S n) | S Datatypes.O => S n | S (S l0) => Init.Nat.sub n l0 end with | Datatypes.O => cons b l | S m => nth m vsl nil end else if match n with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then nth (S (S (S (S n)))) vnl nil else match match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S Datatypes.O) => S n | S (S (S l1)) => Init.Nat.sub n l1 end with | Datatypes.O => cons b l | S m => nth m vsl nil end) match vsl with | cons _ (cons c nil) => if b then c else nil | cons _ (cons c (cons d _)) => if b then c else d | _ => nil end
+++++
destruct b.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | S (S (S m'1)) => Nat.leb n m'1 | _ => false end then nth (S (S (S n))) vnl nil else match match n with | Datatypes.O => S (S n) | S Datatypes.O => S n | S (S l0) => Init.Nat.sub n l0 end with | Datatypes.O => cons true l | S m => nth m vsl nil end) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S Datatypes.O)
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S Datatypes.O) vsl nil) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S n))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | S (S m'0) => Nat.leb (S n) m'0 | _ => false end then nth (S (S (S (S n)))) vnl nil else match match n with | Datatypes.O => S (S n) | S l => Init.Nat.sub (S n) l end with | Datatypes.O => cons true l | S m => nth m vsl nil end) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S Datatypes.O))
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S Datatypes.O) vsl nil) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb (S (S n)) m' end then nth (S (S (S (S (S n))))) vnl nil else match Init.Nat.sub (S (S n)) n with | Datatypes.O => cons true l | S m => nth m vsl nil end) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S Datatypes.O)))
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match Init.Nat.sub (S (S Datatypes.O)) Datatypes.O with | Datatypes.O => cons true l | S m => nth m vsl nil end match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S Datatypes.O)))
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S Datatypes.O) vsl nil) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if Nat.leb (S (S (S n))) n then nth (S (S (S (S (S (S n)))))) vnl nil else match Init.Nat.sub (S (S (S n))) (S n) with | Datatypes.O => cons true l | S m => nth m vsl nil end) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
rewrite leb_correct_conv;[ | omega].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match Init.Nat.sub (S (S (S n))) (S n) with | Datatypes.O => cons true l | S m => nth m vsl nil end match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (Init.Nat.sub (S (S n)) (S n)) vsl nil) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (Init.Nat.sub (S n) (S n))) vsl nil) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
rewrite minus_diag.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S Datatypes.O) vsl nil) match vsl with | cons _ (cons c nil) | cons _ (cons c (cons _ _)) => c | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
le (S n) (S (S n))
+++++
omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S n)
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | S (S (S (S m'2))) => Nat.leb n m'2 | _ => false end then nth (S (S (S (S n)))) vnl nil else match match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S Datatypes.O) => S n | S (S (S l1)) => Init.Nat.sub n l1 end with | Datatypes.O => cons false l | S m => nth m vsl nil end) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S Datatypes.O)
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (S Datatypes.O)) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S n))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | S (S (S m'1)) => Nat.leb (S n) m'1 | _ => false end then nth (S (S (S (S (S n))))) vnl nil else match match n with | Datatypes.O => S (S (S n)) | S Datatypes.O => S (S n) | S (S l0) => Init.Nat.sub (S n) l0 end with | Datatypes.O => cons false l | S m => nth m vsl nil end) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S Datatypes.O))
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (S Datatypes.O)) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S n)))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | S (S m'0) => Nat.leb (S (S n)) m'0 | _ => false end then nth (S (S (S (S (S (S n)))))) vnl nil else match match n with | Datatypes.O => S (S (S n)) | S l => Init.Nat.sub (S (S n)) l end with | Datatypes.O => cons false l | S m => nth m vsl nil end) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S Datatypes.O)))
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (S Datatypes.O)) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S n))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if match n with | Datatypes.O => false | S m' => Nat.leb (S (S (S n))) m' end then nth (S (S (S (S (S (S (S n))))))) vnl nil else match Init.Nat.sub (S (S (S n))) n with | Datatypes.O => cons false l | S m => nth m vsl nil end) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
destruct n; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S Datatypes.O))))
s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match Init.Nat.sub (S (S (S Datatypes.O))) Datatypes.O with | Datatypes.O => cons false l | S m => nth m vsl nil end match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (if Nat.leb (S (S (S (S n)))) n then nth (S (S (S (S (S (S (S (S n)))))))) vnl nil else match Init.Nat.sub (S (S (S (S n)))) (S n) with | Datatypes.O => cons false l | S m => nth m vsl nil end) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
rewrite leb_correct_conv;[ | omega].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq match Init.Nat.sub (S (S (S (S n)))) (S n) with | Datatypes.O => cons false l | S m => nth m vsl nil end match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (Init.Nat.sub (S (S (S n))) (S n)) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (Init.Nat.sub (S (S n)) (S n))) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
rewrite <- minus_Sn_m; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (S (Init.Nat.sub (S n) (S n)))) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
rewrite minus_diag.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
eq (nth (S (S Datatypes.O)) vsl nil) match vsl with | cons _ (cons _ (cons d _)) => d | _ => nil end
+++++
do 3 (destruct vsl; simpl; trivial).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
le (S n) (S (S n))
+++++
omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.

*****
H0 : le (S (S (S (S Datatypes.O)))) s
H : le Datatypes.O (S (S (S (S (S n)))))
n,s : nat
vsl : list (list bool)
l : list bool
vnl : list (list bool)
*****
le (S n) (S (S (S n)))
+++++
omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.

*****
H1 : eq\n match inf e1 with\n | I gn gs =>\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S gn) (cons h0n (cons h1n nil))))\n (maxl\n (cons gs\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].

*****
H2 : eq (inf e1) (I n0 n1)
H1 : eq\n match inf e2 with\n | I h0n h0s =>\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n0) (cons h0n (cons h1n nil))))\n (maxl\n (cons n1\n (cons (Init.Nat.sub h0s (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n0,n1 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].

*****
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H1 : eq\n match inf e3 with\n | I h1n h1s =>\n I (maxl (cons (S n0) (cons n2 (cons h1n nil))))\n (maxl\n (cons n1\n (cons (Init.Nat.sub n3 (S Datatypes.O))\n (cons (Init.Nat.sub h1s (S Datatypes.O)) nil))))\n | E _ => E (Enat (S Datatypes.O))\n end (I n' s')
n0,n1,n2,n3 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].

*****
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H1 : eq\n (I (maxl (cons (S n0) (cons n2 (cons n4 nil))))\n (maxl\n (cons n1\n (cons (Init.Nat.sub n3 (S Datatypes.O))\n (cons (Init.Nat.sub n5 (S Datatypes.O)) nil)))))\n (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H0 : le s' s
H : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
injection H1; clear H1; intros; subst.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.

*****
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : le\n (maxl\n (cons n1\n (cons (Init.Nat.sub n3 (S Datatypes.O))\n (cons (Init.Nat.sub n5 (S Datatypes.O)) nil)))) s
n1,n3,n5 : nat
H : le (maxl (cons (S n0) (cons n2 (cons n4 nil)))) n
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
apply maxl_le3 in H.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.

*****
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : le\n (maxl\n (cons n1\n (cons (Init.Nat.sub n3 (S Datatypes.O))\n (cons (Init.Nat.sub n5 (S Datatypes.O)) nil)))) s
n1,n3,n5 : nat
H : and (le (S n0) n) (and (le n2 n) (le n4 n))
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
apply maxl_le3 in H0.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.

*****
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : and (le n1 s)\n (and (le (Init.Nat.sub n3 (S Datatypes.O)) s)\n (le (Init.Nat.sub n5 (S Datatypes.O)) s))
n1,n3,n5 : nat
H : and (le (S n0) n) (and (le n2 n) (le n4 n))
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) (hd nil vnl) (tl vnl) vsl) (sem_rec (semI e1) (semI e2) (semI e3) (hd nil vnl) (tl vnl) vsl)
+++++
induction (hd nil vnl); simpl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.

*****
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : and (le n1 s)\n (and (le (Init.Nat.sub n3 (S Datatypes.O)) s)\n (le (Init.Nat.sub n5 (S Datatypes.O)) s))
n1,n3,n5 : nat
H : and (le (S n0) n) (and (le n2 n) (le n4 n))
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1) (tl vnl) vsl) (semI e1 (tl vnl) vsl)
+++++
eapply IHe1; [ | | eauto ]; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.

*****
IHl : eq\n (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1))\n (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) l \n (tl vnl) vsl)\n (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl)
l : list bool
a : bool
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : and (le n1 s)\n (and (le (Init.Nat.sub n3 (S Datatypes.O)) s)\n (le (Init.Nat.sub n5 (S Datatypes.O)) s))
n1,n3,n5 : nat
H : and (le (S n0) n) (and (le n2 n) (le n4 n))
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (if a then sem (conv n (S s) e3) (cons l (tl vnl)) (cons (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) l (tl vnl) vsl) vsl) else sem (conv n (S s) e2) (cons l (tl vnl)) (cons (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1)) (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) l (tl vnl) vsl) vsl)) (if a then semI e3 (cons l (tl vnl)) (cons (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl) vsl) else semI e2 (cons l (tl vnl)) (cons (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl) vsl))
+++++
case a; rewrite IHl.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.

*****
IHl : eq\n (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1))\n (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) l \n (tl vnl) vsl)\n (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl)
l : list bool
a : bool
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : and (le n1 s)\n (and (le (Init.Nat.sub n3 (S Datatypes.O)) s)\n (le (Init.Nat.sub n5 (S Datatypes.O)) s))
n1,n3,n5 : nat
H : and (le (S n0) n) (and (le n2 n) (le n4 n))
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem (conv n (S s) e3) (cons l (tl vnl)) (cons (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl) vsl)) (semI e3 (cons l (tl vnl)) (cons (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl) vsl))
+++++
eapply IHe3; [ | | eauto ]; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.

*****
IHl : eq\n (sem_rec (sem (conv (Init.Nat.sub n (S Datatypes.O)) s e1))\n (sem (conv n (S s) e2)) (sem (conv n (S s) e3)) l \n (tl vnl) vsl)\n (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl)
l : list bool
a : bool
H4 : eq (inf e3) (I n4 n5)
H3 : eq (inf e2) (I n2 n3)
H2 : eq (inf e1) (I n0 n1)
H0 : and (le n1 s)\n (and (le (Init.Nat.sub n3 (S Datatypes.O)) s)\n (le (Init.Nat.sub n5 (S Datatypes.O)) s))
n1,n3,n5 : nat
H : and (le (S n0) n) (and (le n2 n) (le n4 n))
n,s,n0,n2,n4 : nat
vnl,vsl : list (list bool)
IHe3 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e3) (I n' s')),\neq (sem (conv n s e3) vnl vsl) (semI e3 vnl vsl)
IHe2 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e2) (I n' s')),\neq (sem (conv n s e2) vnl vsl) (semI e2 vnl vsl)
IHe1 : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e1) (I n' s')),\neq (sem (conv n s e1) vnl vsl) (semI e1 vnl vsl)
e1,e2,e3 : BCI
*****
eq (sem (conv n (S s) e2) (cons l (tl vnl)) (cons (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl) vsl)) (semI e2 (cons l (tl vnl)) (cons (sem_rec (semI e1) (semI e2) (semI e3) l (tl vnl) vsl) vsl))
+++++
eapply IHe2; [ | | eauto ]; omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.

*****
H3 : eq\n match inf e with\n | I hn hs =>\n if andb (Nat.leb hn (length rl)) (Nat.leb hs (length tl))\n then\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n else E (Enat (S (S (S (S (S (S Datatypes.O)))))))\n | E e => E e\n end (I n' s')
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].

*****
H4 : eq (inf e) (I n0 n1)
H3 : eq\n (if andb (Nat.leb n0 (length rl)) (Nat.leb n1 (length tl))\n then\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n else E (Enat (S (S (S (S (S (S Datatypes.O)))))))) \n (I n' s')
n0,n1 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.

*****
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n (if andb true true\n then\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n else E (Enat (S (S (S (S (S (S Datatypes.O)))))))) \n (I n' s')
n0,n1 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
simpl in H3.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.

*****
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n match inf_list (map inf rl) with\n | I nnl snl =>\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb snl Datatypes.O\n then I (Init.Nat.max nnl nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end (I n' s')
n0,n1 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].

*****
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n match inf_list (map inf tl) with\n | I nsl ssl =>\n if Nat.eqb n3 Datatypes.O\n then I (Init.Nat.max n2 nsl) ssl\n else E (Enat (S (S (S (S Datatypes.O)))))\n | E _ => E (Enat (S (S (S (S (S Datatypes.O))))))\n end (I n' s')
n0,n1,n2,n3 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].

*****
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq\n (if Nat.eqb n3 Datatypes.O\n then I (Init.Nat.max n2 n4) n5\n else E (Enat (S (S (S (S Datatypes.O)))))) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].

*****
H9 : eq (Nat.eqb n3 Datatypes.O) true
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : eq (Nat.leb n0 (length rl)) true
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
apply leb_complete in H5.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.

*****
H9 : eq (Nat.eqb n3 Datatypes.O) true
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : eq (Nat.leb n1 (length tl)) true
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
apply leb_complete in H6.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.

*****
H9 : eq (Nat.eqb n3 Datatypes.O) true
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
apply beq_nat_true in H9.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv (length rl) (length tl) e) (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
erewrite IHe; [ | | | eauto]; try omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
IHe : forall (vnl vsl : list (list bool)) (n s n' s' : nat) \n (_ : le n' n) (_ : le s' s) (_ : eq (inf e) (I n' s')),\neq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (semI e (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
clear IHe.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.

*****
H9 : eq n3 Datatypes.O
H8 : eq (inf_list (map inf tl)) (I n4 n5)
H7 : eq (inf_list (map inf rl)) (I n2 n3)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
H3 : eq (I (Init.Nat.max n2 n4) n5) (I n' s')
n0,n1,n2,n3,n4,n5 : nat
H2 : le s' s
H1 : le n' n
n,s,n',s' : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (semI e (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
injection H3; clear H3; intros; subst.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (semI e (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl))) (semI e (map (fun ne : BCI => semI ne vnl nil) rl) (map (fun se : BCI => semI se vnl vsl) tl))
+++++
f_equal.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (map (fun ne : BC => sem ne vnl nil) (map (conv n Datatypes.O) rl)) (map (fun ne : BCI => semI ne vnl nil) rl)
+++++
rewrite map_map.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (map (fun x : BCI => sem (conv n Datatypes.O x) vnl nil) rl) (map (fun ne : BCI => semI ne vnl nil) rl)
+++++
apply map_ext2.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
forall (a : BCI) (_ : In a rl), eq (sem (conv n Datatypes.O a) vnl nil) (semI a vnl nil)
+++++
intros.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.

*****
H3 : In a rl
a : BCI
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv n Datatypes.O a) vnl nil) (semI a vnl nil)
+++++
eapply (inf_list_ex _ a) in H7; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.

*****
H3 : In a rl
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : ex\n (fun n' : nat =>\n ex\n (fun s' : nat =>\n and (le n' n2) (and (le s' Datatypes.O) (eq (inf a) (I n' s')))))
a : BCI
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv n Datatypes.O a) vnl nil) (semI a vnl nil)
+++++
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).

*****
H3 : In a rl
H8 : eq (inf_list (map inf tl)) (I n4 s')
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa Datatypes.O
Ha1 : le na n2
na,sa : nat
a : BCI
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv n Datatypes.O a) vnl nil) (semI a vnl nil)
+++++
eapply H;[ trivial | | | apply Ha3 ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].

*****
H3 : In a rl
H8 : eq (inf_list (map inf tl)) (I n4 s')
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa Datatypes.O
Ha1 : le na n2
na,sa : nat
a : BCI
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le na n
+++++
apply le_trans with (2 := H1).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).

*****
H3 : In a rl
H8 : eq (inf_list (map inf tl)) (I n4 s')
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa Datatypes.O
Ha1 : le na n2
na,sa : nat
a : BCI
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le na (Init.Nat.max n2 n4)
+++++
apply le_trans with (1 := Ha1).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).

*****
H3 : In a rl
H8 : eq (inf_list (map inf tl)) (I n4 s')
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa Datatypes.O
Ha1 : le na n2
na,sa : nat
a : BCI
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le n2 (Init.Nat.max n2 n4)
+++++
auto with arith.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.

*****
H3 : In a rl
H8 : eq (inf_list (map inf tl)) (I n4 s')
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa Datatypes.O
Ha1 : le na n2
na,sa : nat
a : BCI
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le sa Datatypes.O
+++++
trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (map (fun se : BC => sem se vnl vsl) (map (conv n s) tl)) (map (fun se : BCI => semI se vnl vsl) tl)
+++++
rewrite map_map.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (map (fun x : BCI => sem (conv n s x) vnl vsl) tl) (map (fun se : BCI => semI se vnl vsl) tl)
+++++
apply map_ext2.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.

*****
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
forall (a : BCI) (_ : In a tl), eq (sem (conv n s a) vnl vsl) (semI a vnl vsl)
+++++
intros.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.

*****
H3 : In a tl
a : BCI
H8 : eq (inf_list (map inf tl)) (I n4 s')
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv n s a) vnl vsl) (semI a vnl vsl)
+++++
eapply (inf_list_ex _ a) in H8; trivial.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.

*****
H3 : In a tl
H8 : ex\n (fun n' : nat =>\n ex\n (fun s'0 : nat =>\n and (le n' n4) (and (le s'0 s') (eq (inf a) (I n' s'0)))))
a : BCI
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv n s a) vnl vsl) (semI a vnl vsl)
+++++
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).

*****
H3 : In a tl
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa s'
Ha1 : le na n4
na,sa : nat
a : BCI
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
eq (sem (conv n s a) vnl vsl) (semI a vnl vsl)
+++++
eapply H0;[ trivial | | | apply Ha3 ].
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H0;[ trivial | | | apply Ha3 ].

*****
H3 : In a tl
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa s'
Ha1 : le na n4
na,sa : nat
a : BCI
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le na n
+++++
apply le_trans with (2 := H1).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H0;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).

*****
H3 : In a tl
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa s'
Ha1 : le na n4
na,sa : nat
a : BCI
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le na (Init.Nat.max n2 n4)
+++++
apply le_trans with (1 := Ha1).
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H0;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).

*****
H3 : In a tl
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa s'
Ha1 : le na n4
na,sa : nat
a : BCI
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le n4 (Init.Nat.max n2 n4)
+++++
auto with arith.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H0;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.

*****
H3 : In a tl
Ha3 : eq (inf a) (I na sa)
Ha2 : le sa s'
Ha1 : le na n4
na,sa : nat
a : BCI
H7 : eq (inf_list (map inf rl)) (I n2 Datatypes.O)
H6 : le n1 (length tl)
H5 : le n0 (length rl)
H4 : eq (inf e) (I n0 n1)
n0,n1 : nat
H2 : le s' s
H1 : le (Init.Nat.max n2 n4) n
n,s,s',n2,n4 : nat
vnl,vsl : list (list bool)
H0 : forall (s : BCI) (_ : In s tl) (vnl vsl : list (list bool))\n (n s0 n' s' : nat) (_ : le n' n) (_ : le s' s0)\n (_ : eq (inf s) (I n' s')),\neq (sem (conv n s0 s) vnl vsl) (semI s vnl vsl)
H : forall (r : BCI) (_ : In r rl) (vnl vsl : list (list bool))\n (n s n' s' : nat) (_ : le n' n) (_ : le s' s)\n (_ : eq (inf r) (I n' s')),\neq (sem (conv n s r) vnl vsl) (semI r vnl vsl)
rl,tl : list BCI
e : BCI
*****
le sa s
+++++
omega.
-----
Lemma conv_correct : forall (e : BCI) (vnl vsl : list bs) n s n' s', n' <= n -> s' <= s -> inf e = I n' s' -> sem (conv n s e) vnl vsl = semI e vnl vsl.
Proof.
induction e using BCI_ind2; simpl; intros; trivial.
injection H1; clear H1; intros; subst.
destruct n.
contradict H; omega.
case_eq (leb i n); intros; trivial.
apply leb_complete_conv in H1.
contradict H; omega.
injection H1; clear H1; intros; subst.
destruct n.
simpl; rewrite <- (minus_n_O i); trivial.
case_eq (leb (S n + i) n); intros.
apply leb_complete in H1.
elimtype False; omega.
replace (S n + i - S n) with i; trivial.
omega.
injection H1; clear H1; intros; subst.
case_eq n; simpl; intros.
destruct vsl; simpl; trivial.
destruct n0.
destruct vsl; simpl; trivial.
case_eq (leb (S n0) n0); intros.
apply leb_complete in H2.
elimtype False; omega.
rewrite minus_diag.
destruct vsl; trivial.
destruct n.
simpl.
erewrite hd_nth_0; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag; trivial.
erewrite hd_nth_0; trivial.
injection H1; clear H1; intros; subst.
destruct n.
simpl.
destruct vsl; simpl; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
destruct l; simpl; trivial.
destruct b; trivial.
destruct vsl; simpl; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite minus_diag.
destruct vsl; trivial.
simpl.
destruct n; trivial.
destruct n; trivial.
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
simpl.
destruct l; simpl; trivial.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
destruct b.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
simpl.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
destruct n; trivial.
do 3 (destruct vsl; simpl; trivial).
rewrite leb_correct_conv;[ | omega].
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite <- minus_Sn_m; trivial.
rewrite minus_diag.
do 3 (destruct vsl; simpl; trivial).
omega.
omega.
case_eq (inf e1); intros; rewrite H2 in H1;[ | discriminate ].
case_eq (inf e2); intros; rewrite H3 in H1;[ | discriminate ].
case_eq (inf e3); intros; rewrite H4 in H1;[ | discriminate ].
injection H1; clear H1; intros; subst.
apply maxl_le3 in H.
apply maxl_le3 in H0.
induction (hd nil vnl); simpl.
eapply IHe1; [ | | eauto ]; omega.
case a; rewrite IHl.
eapply IHe3; [ | | eauto ]; omega.
eapply IHe2; [ | | eauto ]; omega.
case_eq (inf e); intros; rewrite H4 in H3;[ | discriminate ].
case_eq (leb n0 (length rl)); intros; case_eq (leb n1 (length tl)); intros; rewrite H5, H6 in H3; try discriminate.
simpl in H3.
case_eq (inf_list (map inf rl)); intros; rewrite H7 in H3; [ | discriminate ].
case_eq (inf_list (map inf tl)); intros; rewrite H8 in H3; [ | discriminate ].
case_eq (beq_nat n3 0); intros; rewrite H9 in H3; [ | discriminate ].
apply leb_complete in H5.
apply leb_complete in H6.
apply beq_nat_true in H9.
erewrite IHe; [ | | | eauto]; try omega.
clear IHe.
injection H3; clear H3; intros; subst.
f_equal.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H7; trivial.
destruct H7 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
trivial.
rewrite map_map.
apply map_ext2.
intros.
eapply (inf_list_ex _ a) in H8; trivial.
destruct H8 as (na & sa & Ha1 & Ha2 & Ha3).
eapply H0;[ trivial | | | apply Ha3 ].
apply le_trans with (2 := H1).
apply le_trans with (1 := Ha1).
auto with arith.
omega.

*****

*****

+++++
Qed.
-----
Definition conv_bci_to_bc (e : BCI) : option BC :=\n  match inf e with\n  | I n s => Some (conv n s e)\n  | _ => None\nend.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs),\n  conv_bci_to_bc e = Some e' ->\n  sem e' vnl vsl = semI e vnl vsl.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.

*****

*****
forall (e : BCI) (e' : BC) (vnl vsl : list (list bool)) (_ : eq (conv_bci_to_bc e) (Some e')), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
Proof.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.

*****

*****
forall (e : BCI) (e' : BC) (vnl vsl : list (list bool)) (_ : eq (conv_bci_to_bc e) (Some e')), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
unfold conv_bci_to_bc.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.

*****

*****
forall (e : BCI) (e' : BC) (vnl vsl : list (list bool)) (_ : eq match inf e with | I n s => Some (conv n s e) | E _ => None end (Some e')), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
intros e e' vnl vsl.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.

*****
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
forall _ : eq match inf e with | I n s => Some (conv n s e) | E _ => None end (Some e'), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
case_eq (inf e).
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).

*****
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
forall (n n0 : nat) (_ : eq (inf e) (I n n0)) (_ : eq (Some (conv n n0 e)) (Some e')), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
idtac.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.

*****
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
forall (n n0 : nat) (_ : eq (inf e) (I n n0)) (_ : eq (Some (conv n n0 e)) (Some e')), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
intros n s Hinf H.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.

*****
H : eq (Some (conv n s e)) (Some e')
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
injection H.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.

*****
H : eq (Some (conv n s e)) (Some e')
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
forall _ : eq (conv n s e) e', eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
clear H.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.
clear H.

*****
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
forall _ : eq (conv n s e) e', eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
intro H.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.
clear H.
intro H.

*****
H : eq (conv n s e) e'
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
rewrite <- H.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.
clear H.
intro H.
rewrite <- H.

*****
H : eq (conv n s e) e'
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
eq (sem (conv n s e) vnl vsl) (semI e vnl vsl)
+++++
apply conv_correct with n s.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.
clear H.
intro H.
rewrite <- H.
apply conv_correct with n s.

*****
H : eq (conv n s e) e'
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
le n n
+++++
auto.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.
clear H.
intro H.
rewrite <- H.
apply conv_correct with n s.

*****
H : eq (conv n s e) e'
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
le s s
+++++
auto.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).
idtac.
intros n s Hinf H.
injection H.
clear H.
intro H.
rewrite <- H.
apply conv_correct with n s.

*****
H : eq (conv n s e) e'
Hinf : eq (inf e) (I n s)
n,s : nat
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
eq (inf e) (I n s)
+++++
auto.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).

*****
vnl,vsl : list (list bool)
e' : BC
e : BCI
*****
forall (e0 : ErrorI) (_ : eq (inf e) (E e0)) (_ : eq None (Some e')), eq (sem e' vnl vsl) (semI e vnl vsl)
+++++
discriminate.
-----
Lemma conv_bci_to_bc_correct : forall (e : BCI) (e' : BC) (vnl vsl : list bs), conv_bci_to_bc e = Some e' -> sem e' vnl vsl = semI e vnl vsl.
Proof.
unfold conv_bci_to_bc.
intros e e' vnl vsl.
case_eq (inf e).

*****

*****

+++++
Qed.
-----
