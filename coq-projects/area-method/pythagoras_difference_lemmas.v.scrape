Require Export euclidean_constructions.
-----
Require Export area_elimination_lemmas.
-----
Require Export ratios_elimination_lemmas.
-----
Lemma l_24_a : forall A B P D,\nCol A D B -> perp A B P D ->\nA<>B -> B<>D ->\n A**D / D**B = Py P A B / Py P B A.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.

*****

*****
forall (A B P D : Point) (_ : Col A D B) (_ : perp A B P D) (_ : not (eq A B)) (_ : not (eq B D)), eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Py P A B) (Py P B A))
+++++
Proof.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.

*****

*****
forall (A B P D : Point) (_ : Col A D B) (_ : perp A B P D) (_ : not (eq A B)) (_ : not (eq B D)), eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Py P A B) (Py P B A))
+++++
intros.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Py P A B) (Py P B A))
+++++
unfold Py.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
unfold perp in *.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : eq (Py4 A P B D) F0
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
unfold Py4 in *.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : eq (Fminus (Py A P D) (Py B P D)) F0
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
unfold Py in *.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg D B)) (Fdiv (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
uniformize_dir_seg.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) (Fminus (Fplus (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))))
+++++
basic_simpl.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg A P) (DSeg A P))))
+++++
IsoleVar (A ** P * A ** P) H0.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.

*****
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fplus F0\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg A P) (DSeg A P))))
+++++
rewrite H0.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.

*****
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fplus F0\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fplus F0 (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D)))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fplus F0 (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D)))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
basic_simpl.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.

*****
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
assert (A**D+D**B = A**B).
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).

*****
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fplus (DSeg A D) (DSeg D B)) (DSeg A B)
+++++
eapply chasles.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
eapply chasles.

*****
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
Col A D B
+++++
auto.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).

*****
H3 : eq (Fplus (DSeg A D) (DSeg D B)) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).

*****
H3 : eq (Fplus (DSeg A D) (DSeg D B)) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fmult (DSeg A B) (DSeg A B)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg D B)))
+++++
rewrite <- H3.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
rewrite <- H3.

*****
H3 : eq (Fplus (DSeg A D) (DSeg D B)) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fmult (Fplus (DSeg A D) (DSeg D B)) (Fplus (DSeg A D) (DSeg D B))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg D B)))
+++++
uniformize_dir_seg.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
rewrite <- H3.
uniformize_dir_seg.

*****
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fmult (Fplus (DSeg A D) (Fopp (DSeg B D))) (Fplus (DSeg A D) (Fopp (DSeg B D)))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
+++++
basic_simpl.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
rewrite <- H3.
uniformize_dir_seg.
basic_simpl.

*****
H3 : eq (Fminus (DSeg A D) (DSeg B D)) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fmult (Fminus (DSeg A D) (DSeg B D)) (Fminus (DSeg A D) (DSeg B D))) (Fminus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B D)))
+++++
ring.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg D B)))
H3 : eq (Fplus (DSeg A D) (DSeg D B)) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
uniformize_dir_seg.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
rewrite H4.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
forall _ : eq (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B)), eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
intro Ha.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.

*****
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
rewrite Ha.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.

*****
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).

*****
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
forall _ : eq (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))) (Fmult (Fmult (Fplus F1 F1) (DSeg D B)) (DSeg A B)), eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
intro Hb.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (DSeg D B)) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))))
+++++
rewrite Hb.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.
rewrite Hb.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (DSeg D B)) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg D B)) (DSeg A B)))
+++++
uniformize_dir_seg.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.
rewrite Hb.
uniformize_dir_seg.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (Fopp (DSeg B D))) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (DSeg A B)))
+++++
field.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.
rewrite Hb.
uniformize_dir_seg.
field.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
and (not (eq (DSeg A B) F0)) (and (not (eq (Fopp (DSeg B D)) F0)) (not (eq (Fplus F1 F1) F0)))
+++++
repeat split.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.
rewrite Hb.
uniformize_dir_seg.
field.
repeat split.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.
rewrite Hb.
uniformize_dir_seg.
field.
repeat split.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fopp (DSeg B D)) F0)
+++++
auto with Geom.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
intro Hb.
rewrite Hb.
uniformize_dir_seg.
field.
repeat split.

*****
Hb : eq\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))))\n (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (DSeg A B))
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).

*****
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))) (Fmult (Fmult (Fplus F1 F1) (DSeg D B)) (DSeg A B))
+++++
rewrite <- H3.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
rewrite <- H3.

*****
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))) (Fmult (Fmult (Fplus F1 F1) (DSeg D B)) (Fplus (DSeg A D) (Fopp (DSeg B D))))
+++++
uniformize_dir_seg.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
intro Ha.
rewrite Ha.
cut ((B ** P * B ** P + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D) = 2 * D**B * A**B)).
rewrite <- H3.
uniformize_dir_seg.

*****
Ha : eq\n (Fminus\n (Fplus\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D))\n (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D)))))\n (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D)))) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg B D))) (Fplus (DSeg A D) (Fopp (DSeg B D))))
+++++
ring.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A B))
+++++
rewrite <- H3.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
rewrite <- H3.

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fplus (DSeg A D) (Fopp (DSeg B D))))
+++++
uniformize_dir_seg.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).
assert (A**B * A**B = A**D * A**D + B**D* B**D + 2 * A**D*D**B).
uniformize_dir_seg.
rewrite H4.
cut (B ** P * B ** P + P ** D * P ** D - B ** D * B ** D + A ** D * A ** D - P ** D * P ** D + (A ** D * A ** D + B ** D * B ** D + 2 * A ** D * - B ** D) - B ** P * B ** P = 2* A**D * A**B).
rewrite <- H3.
uniformize_dir_seg.

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus\n (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))
H3 : eq (Fplus (DSeg A D) (Fopp (DSeg B D))) (DSeg A B)
H0 : eq (Fmult (DSeg A P) (DSeg A P))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D)))\n (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fmult (DSeg P D) (DSeg P D)))
H2 : not (eq B D)
H1 : not (eq A B)
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg P D) (DSeg P D))) (Fplus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg B D) (DSeg B D))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg B D))))) (Fmult (DSeg B P) (DSeg B P))) (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fplus (DSeg A D) (Fopp (DSeg B D))))
+++++
ring.
-----
Lemma l_24_a : forall A B P D, Col A D B -> perp A B P D -> A<>B -> B<>D -> A**D / D**B = Py P A B / Py P B A.
Proof.
intros.
unfold Py.
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** P * A ** P) H0.
rewrite H0.
basic_simpl.
assert (A**D+D**B = A**B).

*****

*****

+++++
Qed.
-----
Lemma perp4_perp : forall A B P, \nperp A B P A -> Py P A B = 0.
-----
Lemma perp4_perp : forall A B P, perp A B P A -> Py P A B = 0.

*****

*****
forall (A B P : Point) (_ : perp A B P A), eq (Py P A B) F0
+++++
Proof.
-----
Lemma perp4_perp : forall A B P, perp A B P A -> Py P A B = 0.
Proof.

*****

*****
forall (A B P : Point) (_ : perp A B P A), eq (Py P A B) F0
+++++
intros.
-----
Lemma perp4_perp : forall A B P, perp A B P A -> Py P A B = 0.
Proof.
intros.

*****
H : perp A B P A
A,B,P : Point
*****
eq (Py P A B) F0
+++++
unfold perp in H.
-----
Lemma perp4_perp : forall A B P, perp A B P A -> Py P A B = 0.
Proof.
intros.
unfold perp in H.

*****
H : eq (Py4 A P B A) F0
A,B,P : Point
*****
eq (Py P A B) F0
+++++
rewrite py4_simpl_6 in H.
-----
Lemma perp4_perp : forall A B P, perp A B P A -> Py P A B = 0.
Proof.
intros.
unfold perp in H.
rewrite py4_simpl_6 in H.

*****
H : eq (Py P A B) F0
A,B,P : Point
*****
eq (Py P A B) F0
+++++
assumption.
-----
Lemma perp4_perp : forall A B P, perp A B P A -> Py P A B = 0.
Proof.
intros.
unfold perp in H.
rewrite py4_simpl_6 in H.
assumption.

*****

*****

+++++
Qed.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D ->\nCol A D B ->\n A <> B ->  B <> D -> A <> D -> \nPy P A B <> 0.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.

*****

*****
forall (A B P D : Point) (_ : perp A B P D) (_ : Col A D B) (_ : not (eq A B)) (_ : not (eq B D)) (_ : not (eq A D)), not (eq (Py P A B) F0)
+++++
Proof.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.

*****

*****
forall (A B P D : Point) (_ : perp A B P D) (_ : Col A D B) (_ : not (eq A B)) (_ : not (eq B D)) (_ : not (eq A D)), not (eq (Py P A B) F0)
+++++
intros.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
not (eq (Py P A B) F0)
+++++
unfold not.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
forall _ : eq (Py P A B) F0, False
+++++
intro.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.

*****
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
False
+++++
assert (perp A B P A).
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).

*****
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
perp A B P A
+++++
unfold perp.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.

*****
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Py4 A P B A) F0
+++++
unfold Py4.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.
unfold Py4.

*****
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Fminus (Py A P A) (Py B P A)) F0
+++++
unfold Py in *.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.
unfold Py4.
unfold Py in *.

*****
H4 : eq\n (Fminus\n (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (DSeg P B) (DSeg P B))) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Fminus (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg A A) (DSeg A A))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg B A) (DSeg B A)))) F0
+++++
uniformize_dir_seg.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.
unfold Py4.
unfold Py in *.
uniformize_dir_seg.

*****
H4 : eq\n (Fminus\n (Fplus (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))\n (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Fminus (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))) (Fmult (DSeg A A) (DSeg A A))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B))))) F0
+++++
basic_simpl.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.
unfold Py4.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.

*****
H4 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (DSeg B P) (DSeg B P))) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B)))) F0
+++++
IsoleVar (A ** B * A ** B) H4.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.
unfold Py4.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** B * A ** B) H4.

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus (Fplus F0 (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (DSeg A P) (DSeg A P)))
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B)))) F0
+++++
rewrite H4.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp.
unfold Py4.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** B * A ** B) H4.
rewrite H4.

*****
H4 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus (Fplus F0 (Fmult (DSeg B P) (DSeg B P)))\n (Fmult (DSeg A P) (DSeg A P)))
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P))) (Fminus (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg A P) (DSeg A P))) (Fminus (Fplus F0 (Fmult (DSeg B P) (DSeg B P))) (Fmult (DSeg A P) (DSeg A P))))) F0
+++++
ring.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).

*****
H5 : perp A B P A
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : perp A B P D
A,B,P,D : Point
*****
False
+++++
unfold perp in *.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.

*****
H5 : eq (Py4 A P B A) F0
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq (Py4 A P B D) F0
A,B,P,D : Point
*****
False
+++++
unfold Py4 in *.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.

*****
H5 : eq (Fminus (Py A P A) (Py B P A)) F0
H4 : eq (Py P A B) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq (Fminus (Py A P D) (Py B P D)) F0
A,B,P,D : Point
*****
False
+++++
unfold Py in *.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.

*****
H5 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg A A) (DSeg A A)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg B A) (DSeg B A))))\n F0
H4 : eq\n (Fminus\n (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (DSeg P B) (DSeg P B))) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
A,B,P,D : Point
*****
False
+++++
uniformize_dir_seg.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.

*****
H5 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P))))\n (Fmult (DSeg A A) (DSeg A A)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P))))\n (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B))))) F0
H4 : eq\n (Fminus\n (Fplus (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))\n (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
A,B,P,D : Point
*****
False
+++++
basic_simpl.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.

*****
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H4 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (DSeg B P) (DSeg B P))) F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
A,B,P,D : Point
*****
False
+++++
IsoleVar (B ** P * B ** P) H4.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
A,B,P,D : Point
*****
False
+++++
rewrite H4 in H.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg A D) (DSeg A D)))\n (Fminus\n (Fplus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg A B) (DSeg A B))) F0)\n (Fmult (DSeg P D) (DSeg P D))) (Fmult (DSeg B D) (DSeg B D))))\n F0
A,B,P,D : Point
*****
False
+++++
ring_simplify in H.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fplus\n (Fminus (Fmult (Fopp (DSeg A D)) (DSeg A D))\n (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B D) (DSeg B D)))\n F0
A,B,P,D : Point
*****
False
+++++
replace (A ** B) with (A**D + D**B) in H.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fplus\n (Fminus (Fmult (Fopp (DSeg A D)) (DSeg A D))\n (Fmult (Fplus (DSeg A D) (DSeg D B))\n (Fplus (DSeg A D) (DSeg D B))))\n (Fmult (DSeg B D) (DSeg B D))) F0
A,B,P,D : Point
*****
False
+++++
uniformize_dir_seg.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fplus\n (Fminus (Fmult (Fopp (DSeg A D)) (DSeg A D))\n (Fmult (Fplus (DSeg A D) (Fopp (DSeg B D)))\n (Fplus (DSeg A D) (Fopp (DSeg B D)))))\n (Fmult (DSeg B D) (DSeg B D))) F0
A,B,P,D : Point
*****
False
+++++
ring_simplify in H.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fplus (Fmult (Fmult (Fopp (Fplus F1 F1)) (DSeg A D)) (DSeg A D))\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B D))) F0
A,B,P,D : Point
*****
False
+++++
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
False
+++++
assert ((2* A**D * B**A) <> 0).
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
+++++
repeat (apply nonzeromult).
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
repeat (apply nonzeromult).

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
repeat (apply nonzeromult).

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
not (eq (DSeg A D) F0)
+++++
auto with Geom.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
repeat (apply nonzeromult).

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
not (eq (DSeg B A) F0)
+++++
auto with Geom.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
False
+++++
replace (B ** D - A ** D) with (B**D + D**A) in H.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
replace (B ** D - A ** D) with (B**D + D**A) in H.

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fplus (DSeg B D) (DSeg D A)))\n F0
A,B,P,D : Point
*****
False
+++++
replace (B ** D + D ** A) with (B**A) in H.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
replace (B ** D - A ** D) with (B**D + D**A) in H.
replace (B ** D + D ** A) with (B**A) in H.

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0
A,B,P,D : Point
*****
False
+++++
intuition.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
replace (B ** D - A ** D) with (B**D + D**A) in H.
replace (B ** D + D ** A) with (B**A) in H.

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fplus (DSeg B D) (DSeg D A)))\n F0
A,B,P,D : Point
*****
eq (DSeg B A) (Fplus (DSeg B D) (DSeg D A))
+++++
symmetry.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
replace (B ** D - A ** D) with (B**D + D**A) in H.
replace (B ** D + D ** A) with (B**A) in H.
symmetry.

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fplus (DSeg B D) (DSeg D A)))\n F0
A,B,P,D : Point
*****
eq (Fplus (DSeg B D) (DSeg D A)) (DSeg B A)
+++++
auto with Geom.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
replace (B ** D - A ** D) with (B**D + D**A) in H.

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg B A)) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
eq (Fplus (DSeg B D) (DSeg D A)) (Fminus (DSeg B D) (DSeg A D))
+++++
uniformize_dir_seg.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.
uniformize_dir_seg.
ring_simplify in H.
replace (- (2) * A ** D * A ** D + 2 * A ** D * B ** D ) with (2* A**D * (B**D - A**D)) in H by ring.
assert ((2* A**D * B**A) <> 0).
replace (B ** D - A ** D) with (B**D + D**A) in H.
uniformize_dir_seg.

*****
H6 : not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (Fopp (DSeg A B))) F0)
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fmult (Fmult (Fplus F1 F1) (DSeg A D))\n (Fminus (DSeg B D) (DSeg A D))) F0
A,B,P,D : Point
*****
eq (Fplus (DSeg B D) (Fopp (DSeg A D))) (Fminus (DSeg B D) (DSeg A D))
+++++
ring.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).
unfold perp in *.
unfold Py4 in *.
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
IsoleVar (B ** P * B ** P) H4.
rewrite H4 in H.
ring_simplify in H.
replace (A ** B) with (A**D + D**B) in H.

*****
H4 : eq (Fmult (DSeg B P) (DSeg B P))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A B) (DSeg A B)))\n F0)
H5 : eq\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (DSeg A P) (DSeg A P)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg A P) (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))))\n F0
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : Col A D B
H : eq\n (Fplus\n (Fminus (Fmult (Fopp (DSeg A D)) (DSeg A D))\n (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B D) (DSeg B D)))\n F0
A,B,P,D : Point
*****
eq (Fplus (DSeg A D) (DSeg D B)) (DSeg A B)
+++++
auto with Geom.
-----
Lemma perp_not_eq_not_perp : forall A B P D, perp A B P D -> Col A D B -> A <> B -> B <> D -> A <> D -> Py P A B <> 0.
Proof.
intros.
unfold not.
intro.
assert (perp A B P A).

*****

*****

+++++
Qed.
-----
Lemma l_24_b : forall A B P D,\nCol A D B -> perp A B P D ->\nA<>B -> \n A**D / A**B = Py P A B / (2 * A**B * A**B).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).

*****

*****
forall (A B P D : Point) (_ : Col A D B) (_ : perp A B P D) (_ : not (eq A B)), eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
Proof.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.

*****

*****
forall (A B P D : Point) (_ : Col A D B) (_ : perp A B P D) (_ : not (eq A B)), eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
intros.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.

*****
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
cases_equality B D.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.

*****
H2 : eq B D
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
subst D.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.

*****
H1 : not (eq A B)
H : Col A B B
H0 : perp A B P B
A,B,P : Point
*****
eq (Fdiv (DSeg A B) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
unfold Py.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.

*****
H1 : not (eq A B)
H : Col A B B
H0 : perp A B P B
A,B,P : Point
*****
eq (Fdiv (DSeg A B) (DSeg A B)) (Fdiv (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
field_simplify_eq.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.

*****
H1 : not (eq A B)
H : Col A B B
H0 : perp A B P B
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg P B) (DSeg P B)))
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.

*****
H1 : not (eq A B)
H : Col A B B
H0 : perp A B P B
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg P B) (DSeg P B)))
+++++
unfold perp in H0.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.

*****
H1 : not (eq A B)
H : Col A B B
H0 : eq (Py4 A P B B) F0
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg P B) (DSeg P B)))
+++++
unfold Py4 in H0.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.

*****
H1 : not (eq A B)
H : Col A B B
H0 : eq (Fminus (Py A P B) (Py B P B)) F0
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg P B) (DSeg P B)))
+++++
unfold Py in H0.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.
unfold Py in H0.

*****
H1 : not (eq A B)
H : Col A B B
H0 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P B) (DSeg P B))) (Fmult (DSeg A B) (DSeg A B)))\n (Fminus\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (DSeg P B) (DSeg P B))) (Fmult (DSeg B B) (DSeg B B))))\n F0
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg P B) (DSeg P B)))
+++++
basic_simpl.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.
unfold Py in H0.
basic_simpl.

*****
H1 : not (eq A B)
H : Col A B B
H0 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (DSeg P B) (DSeg P B))) (Fmult (DSeg A B) (DSeg A B)))\n (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (DSeg P B) (DSeg P B))))\n F0
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg P A) (DSeg P A))) (Fmult (DSeg P B) (DSeg P B)))
+++++
uniformize_dir_seg.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.
unfold Py in H0.
basic_simpl.
uniformize_dir_seg.

*****
H1 : not (eq A B)
H : Col A B B
H0 : eq\n (Fminus\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))\n (Fmult (DSeg A B) (DSeg A B)))\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))) F0
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))
+++++
IsoleVar (A ** B * A ** B) H0.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.
unfold Py in H0.
basic_simpl.
uniformize_dir_seg.
IsoleVar (A ** B * A ** B) H0.

*****
H0 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))\n (Fplus F0\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))))
H1 : not (eq A B)
H : Col A B B
A,B,P : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))
+++++
replace (2 * A ** B * A ** B) with (2* (A ** B * A ** B)) by ring.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.
unfold Py in H0.
basic_simpl.
uniformize_dir_seg.
IsoleVar (A ** B * A ** B) H0.
replace (2 * A ** B * A ** B) with (2* (A ** B * A ** B)) by ring.

*****
H0 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))\n (Fplus F0\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))))
H1 : not (eq A B)
H : Col A B B
A,B,P : Point
*****
eq (Fmult (Fplus F1 F1) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))
+++++
rewrite H0.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.
auto with Geom.
unfold perp in H0.
unfold Py4 in H0.
unfold Py in H0.
basic_simpl.
uniformize_dir_seg.
IsoleVar (A ** B * A ** B) H0.
replace (2 * A ** B * A ** B) with (2* (A ** B * A ** B)) by ring.
rewrite H0.

*****
H0 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A P) (DSeg A P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))\n (Fplus F0\n (Fplus (Fmult (DSeg B P) (DSeg B P))\n (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))))
H1 : not (eq A B)
H : Col A B B
A,B,P : Point
*****
eq (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) (Fplus F0 (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg A P) (DSeg A P)) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) (Fplus F0 (Fplus (Fmult (DSeg B P) (DSeg B P)) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))))) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))))
+++++
ring.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
subst D.
unfold Py.
field_simplify_eq.

*****
H1 : not (eq A B)
H : Col A B B
H0 : perp A B P B
A,B,P : Point
*****
and (not (eq (DSeg A B) F0)) (not (eq (Fplus F1 F1) F0))
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.

*****
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
cases_equality A D.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.

*****
H3 : eq A D
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
subst D.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
eq (Fdiv (DSeg A A) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
basic_simpl.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
eq (Fdiv F0 (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
rewrite perp4_perp.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.
rewrite perp4_perp.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
eq (Fdiv F0 (DSeg A B)) (Fdiv F0 (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
idtac.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.
rewrite perp4_perp.
idtac.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
eq (Fdiv F0 (DSeg A B)) (Fdiv F0 (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
field.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.
rewrite perp4_perp.
idtac.
field.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
and (not (eq (DSeg A B) F0)) (not (eq (Fplus F1 F1) F0))
+++++
split.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.
rewrite perp4_perp.
idtac.
field.
split.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.
rewrite perp4_perp.
idtac.
field.
split.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
subst D.
basic_simpl.
rewrite perp4_perp.

*****
H2 : not (eq B A)
H1 : not (eq A B)
H : Col A A B
H0 : perp A B P A
A,B,P : Point
*****
perp A B P A
+++++
auto .
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
assert (Py P A B <> 0).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Py P A B) F0)
+++++
eapply perp_not_eq_not_perp.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
eapply perp_not_eq_not_perp.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
perp A B P ?D
+++++
eauto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
eapply perp_not_eq_not_perp.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
Col A D B
+++++
eauto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
eapply perp_not_eq_not_perp.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq A B)
+++++
eauto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
eapply perp_not_eq_not_perp.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq B D)
+++++
eauto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
eapply perp_not_eq_not_perp.

*****
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq A D)
+++++
eauto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
assert (Py P B A <> 0).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Py P B A) F0)
+++++
apply (perp_not_eq_not_perp B A P D).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
apply (perp_not_eq_not_perp B A P D).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
perp B A P D
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
apply (perp_not_eq_not_perp B A P D).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
Col B D A
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
apply (perp_not_eq_not_perp B A P D).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq B A)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
apply (perp_not_eq_not_perp B A P D).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq A D)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
apply (perp_not_eq_not_perp B A P D).

*****
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq B D)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg A D) (DSeg A B)) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fdiv (DSeg A B) (DSeg A D))) (Fdiv (Py P A B) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fdiv (DSeg A B) (DSeg A D))) (Fdiv (Py P A B) (Py A B A))
+++++
replace (A**B) with (A**D + D**B) by auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fdiv (Fplus (DSeg A D) (DSeg D B)) (DSeg A D))) (Fdiv (Py P A B) (Py A B A))
+++++
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fplus F1 (Fdiv (DSeg D B) (DSeg A D)))) (Fdiv (Py P A B) (Py A B A))
+++++
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fplus F1 (Fdiv F1 (Fdiv (DSeg A D) (DSeg D B))))) (Fdiv (Py P A B) (Py A B A))
+++++
rewrite (l_24_a A B P D).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fplus F1 (Fdiv F1 (Fdiv (Py P A B) (Py P B A))))) (Fdiv (Py P A B) (Py A B A))
+++++
idtac.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv F1 (Fplus F1 (Fdiv F1 (Fdiv (Py P A B) (Py P B A))))) (Fdiv (Py P A B) (Py A B A))
+++++
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (Py P A B) (Fplus (Py P A B) (Py P B A))) (Fdiv (Py P A B) (Py A B A))
+++++
replace (Py P A B + Py P B A) with (Py A B A).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
replace (Py P A B + Py P B A) with (Py A B A).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (Py P A B) (Py A B A)) (Fdiv (Py P A B) (Py A B A))
+++++
auto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
replace (Py P A B + Py P B A) with (Py A B A).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Py A B A) (Fplus (Py P A B) (Py P B A))
+++++
unfold Py.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg A A) (DSeg A A))) (Fplus (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
basic_simpl.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
basic_simpl.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fplus (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
uniformize_dir_seg.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
basic_simpl.
uniformize_dir_seg.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fplus (Fminus (Fplus (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) (Fminus (Fplus (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))))
+++++
ring.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (Py P A B) (Fplus (Py P A B) (Py P B A))) (Fdiv F1 (Fplus F1 (Fdiv F1 (Fdiv (Py P A B) (Py P B A)))))
+++++
field.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
and (not (eq (Py P B A) F0)) (and (not (eq (Py P A B) F0)) (not (eq (Fplus (Py P A B) (Py P B A)) F0)))
+++++
repeat split.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Py P B A) F0)
+++++
auto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Py P A B) F0)
+++++
auto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fplus (Py P A B) (Py P B A)) F0)
+++++
auto.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fplus (Py P A B) (Py P B A)) F0)
+++++
replace (Py P A B + Py P B A) with (Py A B A).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Py A B A) F0)
+++++
unfold Py.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg A A) (DSeg A A))) F0)
+++++
uniformize_dir_seg.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
uniformize_dir_seg.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fmult (DSeg A A) (DSeg A A))) F0)
+++++
basic_simpl.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A B) (DSeg A B))) F0)
+++++
replace (A ** B * A ** B + A ** B * A ** B) with (2* A ** B * A ** B) by ring.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2* A ** B * A ** B) by ring.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) F0)
+++++
repeat (apply nonzeromult).
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2* A ** B * A ** B) by ring.
repeat (apply nonzeromult).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2* A ** B * A ** B) by ring.
repeat (apply nonzeromult).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2* A ** B * A ** B) by ring.
repeat (apply nonzeromult).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Py A B A) (Fplus (Py P A B) (Py P B A))
+++++
unfold Py.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg A A) (DSeg A A))) (Fplus (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
basic_simpl.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
basic_simpl.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fplus (Fminus (Fplus (Fmult (DSeg P A) (DSeg P A)) (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg P B) (DSeg P B))) (Fminus (Fplus (Fmult (DSeg P B) (DSeg P B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg P A) (DSeg P A))))
+++++
uniformize_dir_seg.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).
idtac.
replace (1 / (1 + 1 / (Py P A B / Py P B A))) with ((Py P A B / (Py P A B + Py P B A))).
field.
repeat split.
auto.
replace (Py P A B + Py P B A) with (Py A B A).
unfold Py.
basic_simpl.
uniformize_dir_seg.

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fplus (Fminus (Fplus (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P))) (Fmult (DSeg A B) (DSeg A B))) (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P)))) (Fminus (Fplus (Fmult (Fopp (DSeg B P)) (Fopp (DSeg B P))) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fmult (Fopp (DSeg A P)) (Fopp (DSeg A P)))))
+++++
ring.
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
Col A D B
+++++
auto .
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
perp A B P D
+++++
auto .
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq A B)
+++++
auto .
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.
cases_equality A D.
assert (Py P A B <> 0).
assert (Py P B A <> 0).
replace (A**D / A**B) with (1/ (A**B / A**D)) by (field;auto with Geom).
replace (2 * A ** B * A ** B) with (Py A B A) by (unfold Py;uniformize_dir_seg;basic_simpl;ring).
replace (A**B) with (A**D + D**B) by auto with Geom.
replace ((A ** D + D ** B) / A ** D) with (1 + D ** B / A ** D) by (field;auto with Geom).
replace (D ** B / A ** D) with (1/ (A**D / D**B)) by (field; auto with Geom).
rewrite (l_24_a A B P D).

*****
H5 : not (eq (Py P B A) F0)
H4 : not (eq (Py P A B) F0)
H3 : not (eq A D)
H2 : not (eq B D)
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq B D)
+++++
auto .
-----
Lemma l_24_b : forall A B P D, Col A D B -> perp A B P D -> A<>B -> A**D / A**B = Py P A B / (2 * A**B * A**B).
Proof.
intros.
cases_equality B D.

*****

*****

+++++
Qed.
-----
Lemma l_24_c : forall A B P D,\nCol A D B -> perp A B P D ->\nA<>B -> \n D**B / A**B = Py P B A / (2 * A**B * A**B).
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).

*****

*****
forall (A B P D : Point) (_ : Col A D B) (_ : perp A B P D) (_ : not (eq A B)), eq (Fdiv (DSeg D B) (DSeg A B)) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
Proof.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.

*****

*****
forall (A B P D : Point) (_ : Col A D B) (_ : perp A B P D) (_ : not (eq A B)), eq (Fdiv (DSeg D B) (DSeg A B)) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
intros.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.

*****
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg D B) (DSeg A B)) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).

*****
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg B D) (DSeg B A)) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A)))
+++++
apply l_24_b.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
apply l_24_b.

*****
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
Col B D A
+++++
auto with Geom.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
apply l_24_b.

*****
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
perp B A P D
+++++
auto with Geom.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
apply l_24_b.

*****
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
not (eq B A)
+++++
auto with Geom.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).

*****
H2 : eq (Fdiv (DSeg B D) (DSeg B A))\n (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A)))
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg D B) (DSeg A B)) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
replace (D ** B / A ** B) with (B ** D / B ** A) by auto with Geom.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
replace (D ** B / A ** B) with (B ** D / B ** A) by auto with Geom.

*****
H2 : eq (Fdiv (DSeg B D) (DSeg B A))\n (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A)))
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (DSeg B D) (DSeg B A)) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
rewrite H2.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
replace (D ** B / A ** B) with (B ** D / B ** A) by auto with Geom.
rewrite H2.

*****
H2 : eq (Fdiv (DSeg B D) (DSeg B A))\n (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A)))
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A))) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
replace (2*B ** A * B ** A) with (2*A ** B * A ** B).
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
replace (D ** B / A ** B) with (B ** D / B ** A) by auto with Geom.
rewrite H2.
replace (2*B ** A * B ** A) with (2*A ** B * A ** B).

*****
H2 : eq (Fdiv (DSeg B D) (DSeg B A))\n (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A)))
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))) (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)))
+++++
auto.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
replace (D ** B / A ** B) with (B ** D / B ** A) by auto with Geom.
rewrite H2.
replace (2*B ** A * B ** A) with (2*A ** B * A ** B).

*****
H2 : eq (Fdiv (DSeg B D) (DSeg B A))\n (Fdiv (Py P B A) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A)))
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B A))
+++++
uniformize_dir_seg.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).
replace (D ** B / A ** B) with (B ** D / B ** A) by auto with Geom.
rewrite H2.
replace (2*B ** A * B ** A) with (2*A ** B * A ** B).
uniformize_dir_seg.

*****
H2 : eq (Fdiv (DSeg B D) (Fopp (DSeg A B)))\n (Fdiv (Py P B A)\n (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg A B))) (Fopp (DSeg A B))))
H1 : not (eq A B)
H0 : perp A B P D
H : Col A D B
A,B,P,D : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg A B))) (Fopp (DSeg A B)))
+++++
ring.
-----
Lemma l_24_c : forall A B P D, Col A D B -> perp A B P D -> A<>B -> D**B / A**B = Py P B A / (2 * A**B * A**B).
Proof.
intros.
assert (B ** D / B ** A = Py P B A / (2 * B ** A * B ** A)).

*****

*****

+++++
Qed.
-----
Lemma l_24_c_on_foot : forall P U V Y,\non_foot Y P U V ->\nU**Y / U**V = Py P U V / Py U V U.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.

*****

*****
forall (P U V Y : Point) (_ : on_foot Y P U V), eq (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (Py P U V) (Py U V U))
+++++
Proof.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.

*****

*****
forall (P U V Y : Point) (_ : on_foot Y P U V), eq (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (Py P U V) (Py U V U))
+++++
intros.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.

*****
H : on_foot Y P U V
P,U,V,Y : Point
*****
eq (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (Py P U V) (Py U V U))
+++++
unfold on_foot in H.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.

*****
H : and (perp Y P U V) (and (Col Y U V) (not (eq U V)))
P,U,V,Y : Point
*****
eq (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (Py P U V) (Py U V U))
+++++
use H.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (Py P U V) (Py U V U))
+++++
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fdiv (DSeg Y U) (DSeg V U)) (Fdiv (Py P U V) (Py U V U))
+++++
rewrite (l_24_c V U P).
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fdiv (Py P U V) (Fmult (Fmult (Fplus F1 F1) (DSeg V U)) (DSeg V U))) (Fdiv (Py P U V) (Py U V U))
+++++
idtac.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).
idtac.

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fdiv (Py P U V) (Fmult (Fmult (Fplus F1 F1) (DSeg V U)) (DSeg V U))) (Fdiv (Py P U V) (Py U V U))
+++++
replace (2 * V ** U * V ** U) with (Py U V U).
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).
idtac.
replace (2 * V ** U * V ** U) with (Py U V U).

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fdiv (Py P U V) (Py U V U)) (Fdiv (Py P U V) (Py U V U))
+++++
auto.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).
idtac.
replace (2 * V ** U * V ** U) with (Py U V U).

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Py U V U) (Fmult (Fmult (Fplus F1 F1) (DSeg V U)) (DSeg V U))
+++++
unfold Py.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).
idtac.
replace (2 * V ** U * V ** U) with (Py U V U).
unfold Py.

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg V U) (DSeg V U))) (Fmult (DSeg U U) (DSeg U U))) (Fmult (Fmult (Fplus F1 F1) (DSeg V U)) (DSeg V U))
+++++
basic_simpl.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).
idtac.
replace (2 * V ** U * V ** U) with (Py U V U).
unfold Py.
basic_simpl.

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg V U) (DSeg V U))) (Fmult (Fmult (Fplus F1 F1) (DSeg V U)) (DSeg V U))
+++++
uniformize_dir_seg.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).
idtac.
replace (2 * V ** U * V ** U) with (Py U V U).
unfold Py.
basic_simpl.
uniformize_dir_seg.

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
eq (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (Fopp (DSeg U V)) (Fopp (DSeg U V)))) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg U V))) (Fopp (DSeg U V)))
+++++
ring.
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
Col V Y U
+++++
auto with Geom .
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
perp V U P Y
+++++
auto with Geom .
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).

*****
H3 : not (eq U V)
H2 : Col Y U V
H0 : perp Y P U V
P,U,V,Y : Point
*****
not (eq V U)
+++++
auto with Geom .
-----
Lemma l_24_c_on_foot : forall P U V Y, on_foot Y P U V -> U**Y / U**V = Py P U V / Py U V U.
Proof.
intros.
unfold on_foot in H.
use H.
replace (U ** Y / U ** V) with (Y**U/ V**U) by auto with Geom.
rewrite (l_24_c V U P).

*****

*****

+++++
Qed.
-----
Lemma per_area: forall A B C,\n  per A B C -> \n  2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.

*****

*****
forall (A B C : Point) (_ : per A B C), eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A B C)) (S A B C)) (Fmult (Fmult (Fmult (DSeg A B) (DSeg A B)) (DSeg B C)) (DSeg B C))
+++++
Proof.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.

*****

*****
forall (A B C : Point) (_ : per A B C), eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A B C)) (S A B C)) (Fmult (Fmult (Fmult (DSeg A B) (DSeg A B)) (DSeg B C)) (DSeg B C))
+++++
intros.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.

*****
H : per A B C
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A B C)) (S A B C)) (Fmult (Fmult (Fmult (DSeg A B) (DSeg A B)) (DSeg B C)) (DSeg B C))
+++++
cases_equality B C.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.

*****
H0 : eq B C
H : per A B C
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A B C)) (S A B C)) (Fmult (Fmult (Fmult (DSeg A B) (DSeg A B)) (DSeg B C)) (DSeg B C))
+++++
subst.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
subst.

*****
H : per A C C
A,C : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A C C)) (S A C C)) (Fmult (Fmult (Fmult (DSeg A C) (DSeg A C)) (DSeg C C)) (DSeg C C))
+++++
basic_simpl.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.

*****
H : per A C C
A,C : Point
*****
eq F0 F0
+++++
auto.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A B C)) (S A B C)) (Fmult (Fmult (Fmult (DSeg A B) (DSeg A B)) (DSeg B C)) (DSeg B C))
+++++
assert (on_foot B A B C).
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
on_foot B A B C
+++++
unfold on_foot.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
and (perp B A B C) (and (Col B B C) (not (eq B C)))
+++++
repeat split.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
perp B A B C
+++++
cut (perp B C B A).
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
forall _ : perp B C B A, perp B A B C
+++++
auto with Geom.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
perp B C B A
+++++
unfold perp.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).
unfold perp.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Py4 B B C A) F0
+++++
unfold Py4.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).
unfold perp.
unfold Py4.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Fminus (Py B B A) (Py C B A)) F0
+++++
basic_simpl.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).
unfold perp.
unfold Py4.
basic_simpl.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Fminus F0 (Py C B A)) F0
+++++
replace (Py C B A) with (Py A B C) by auto with Geom.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).
unfold perp.
unfold Py4.
basic_simpl.
replace (Py C B A) with (Py A B C) by auto with Geom.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Fminus F0 (Py A B C)) F0
+++++
rewrite H.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.
cut (perp B C B A).
unfold perp.
unfold Py4.
basic_simpl.
replace (Py C B A) with (Py A B C) by auto with Geom.
rewrite H.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Fminus F0 F0) F0
+++++
ring.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
Col B B C
+++++
auto with Geom.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
unfold on_foot.
repeat split.

*****
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
not (eq B C)
+++++
auto.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).

*****
H1 : on_foot B A B C
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A B C)) (S A B C)) (Fmult (Fmult (Fmult (DSeg A B) (DSeg A B)) (DSeg B C)) (DSeg B C))
+++++
apply on_foot_area.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.
assert (on_foot B A B C).
apply on_foot_area.

*****
H1 : on_foot B A B C
H0 : not (eq B C)
H : per A B C
A,B,C : Point
*****
on_foot B A B C
+++++
auto.
-----
Lemma per_area: forall A B C, per A B C -> 2 * 2 * S A B C * S A B C = A**B * A**B * B**C * B**C.
Proof.
intros.
cases_equality B C.

*****

*****

+++++
Qed.
-----
Lemma per_col_eq : forall A B C,\n per A B C -> Col A B C -> A = B \/ B = C.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.

*****

*****
forall (A B C : Point) (_ : per A B C) (_ : Col A B C), or (eq A B) (eq B C)
+++++
Proof.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.

*****

*****
forall (A B C : Point) (_ : per A B C) (_ : Col A B C), or (eq A B) (eq B C)
+++++
intros.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.

*****
H0 : Col A B C
H : per A B C
A,B,C : Point
*****
or (eq A B) (eq B C)
+++++
unfold per in H.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.

*****
H0 : Col A B C
H : eq (Py A B C) F0
A,B,C : Point
*****
or (eq A B) (eq B C)
+++++
rewrite col_pyth in H.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.

*****
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
or (eq A B) (eq B C)
+++++
idtac.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.

*****
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
or (eq A B) (eq B C)
+++++
cases_equality A B.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.

*****
H1 : eq A B
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
or (eq A B) (eq B C)
+++++
left.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.
left.

*****
H1 : eq A B
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
eq A B
+++++
auto.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.

*****
H1 : not (eq A B)
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
or (eq A B) (eq B C)
+++++
right.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.
right.

*****
H1 : not (eq A B)
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
eq B C
+++++
IsoleVar (B**C) H.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.
right.
IsoleVar (B**C) H.

*****
H : eq (DSeg B C) (Fdiv F0 (Fmult (Fplus F1 F1) (DSeg B A)))
H2 : not (eq (Fmult (Fplus F1 F1) (DSeg B A)) F0)
H1 : not (eq A B)
H0 : Col A B C
A,B,C : Point
*****
eq B C
+++++
replace (0 / (2 * B ** A)) with 0 in H by (field;solve_conds;auto with Geom).
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.
right.
IsoleVar (B**C) H.
replace (0 / (2 * B ** A)) with 0 in H by (field;solve_conds;auto with Geom).

*****
H : eq (DSeg B C) F0
H2 : not (eq (Fmult (Fplus F1 F1) (DSeg B A)) F0)
H1 : not (eq A B)
H0 : Col A B C
A,B,C : Point
*****
eq B C
+++++
auto with Geom.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.
right.
IsoleVar (B**C) H.

*****
H1 : not (eq A B)
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
not (eq (Fmult (Fplus F1 F1) (DSeg B A)) F0)
+++++
solve_conds.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.
idtac.
cases_equality A B.
right.
IsoleVar (B**C) H.
solve_conds.

*****
H1 : not (eq A B)
H0 : Col A B C
H : eq (Fmult (Fmult (Fplus F1 F1) (DSeg B A)) (DSeg B C)) F0
A,B,C : Point
*****
not (eq (DSeg B A) F0)
+++++
auto with Geom.
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.

*****
H0 : Col A B C
H : eq (Py A B C) F0
A,B,C : Point
*****
Col A B C
+++++
assumption .
-----
Lemma per_col_eq : forall A B C, per A B C -> Col A B C -> A = B \\/ B = C.
Proof.
intros.
unfold per in H.
rewrite col_pyth in H.

*****

*****

+++++
Qed.
-----
Lemma perp_col_perp : forall P Q B C,\n Q<>B ->\n per P Q B -> Col Q B C -> per P Q C.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.

*****

*****
forall (P Q B C : Point) (_ : not (eq Q B)) (_ : per P Q B) (_ : Col Q B C), per P Q C
+++++
Proof.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.

*****

*****
forall (P Q B C : Point) (_ : not (eq Q B)) (_ : per P Q B) (_ : Col Q B C), per P Q C
+++++
intros.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.

*****
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
per P Q C
+++++
cut (perp P Q Q C).
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).

*****
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
forall _ : perp P Q Q C, per P Q C
+++++
auto with Geom.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).

*****
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
perp P Q Q C
+++++
assert (perp P Q Q B).
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).

*****
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
perp P Q Q B
+++++
auto with Geom.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
perp P Q Q C
+++++
idtac.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).
idtac.

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
perp P Q Q C
+++++
cut (perp Q C P Q).
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).
idtac.
cut (perp Q C P Q).

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
forall _ : perp Q C P Q, perp P Q Q C
+++++
auto with Geom.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).
idtac.
cut (perp Q C P Q).

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
perp Q C P Q
+++++
apply (perp_para_perp Q B P Q Q C).
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).
idtac.
cut (perp Q C P Q).
apply (perp_para_perp Q B P Q Q C).

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
not (eq Q B)
+++++
auto with Geom.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).
idtac.
cut (perp Q C P Q).
apply (perp_para_perp Q B P Q Q C).

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
perp Q B P Q
+++++
auto with Geom.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).
assert (perp P Q Q B).
idtac.
cut (perp Q C P Q).
apply (perp_para_perp Q B P Q Q C).

*****
H2 : perp P Q Q B
H1 : Col Q B C
H0 : per P Q B
H : not (eq Q B)
P,Q,B,C : Point
*****
parallel Q B Q C
+++++
auto with Geom.
-----
Lemma perp_col_perp : forall P Q B C, Q<>B -> per P Q B -> Col Q B C -> per P Q C.
Proof.
intros.
cut (perp P Q Q C).

*****

*****

+++++
Qed.
-----
Lemma l_3_4 : forall A B C P,\n Col A B C -> Py P A C <> 0 ->\n Py P A B / Py P A C = A**B/ A**C.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.

*****

*****
forall (A B C P : Point) (_ : Col A B C) (_ : not (eq (Py P A C) F0)), eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
Proof.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.

*****

*****
forall (A B C P : Point) (_ : Col A B C) (_ : not (eq (Py P A C) F0)), eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
intros.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.

*****
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
cases_equality A B.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.

*****
H1 : eq A B
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
subst.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.

*****
H : Col B B C
H0 : not (eq (Py P B C) F0)
B,C,P : Point
*****
eq (Fdiv (Py P B B) (Py P B C)) (Fdiv (DSeg B B) (DSeg B C))
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.
basic_simpl.

*****
H : Col B B C
H0 : not (eq (Py P B C) F0)
B,C,P : Point
*****
eq F0 (Fdiv F0 (DSeg B C))
+++++
field.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.
basic_simpl.
field.

*****
H : Col B B C
H0 : not (eq (Py P B C) F0)
B,C,P : Point
*****
not (eq (DSeg B C) F0)
+++++
cases_equality B C.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.
basic_simpl.
field.
cases_equality B C.

*****
H1 : eq B C
H : Col B B C
H0 : not (eq (Py P B C) F0)
B,C,P : Point
*****
not (eq (DSeg B C) F0)
+++++
subst.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.
basic_simpl.
field.
cases_equality B C.
subst.

*****
H0 : not (eq (Py P C C) F0)
H : Col C C C
C,P : Point
*****
not (eq (DSeg C C) F0)
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.
basic_simpl.
field.
cases_equality B C.
subst.
basic_simpl.

*****
H0 : not (eq F0 F0)
H : Col C C C
C,P : Point
*****
not (eq F0 F0)
+++++
auto.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
subst.
basic_simpl.
field.
cases_equality B C.

*****
H1 : not (eq B C)
H : Col B B C
H0 : not (eq (Py P B C) F0)
B,C,P : Point
*****
not (eq (DSeg B C) F0)
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.

*****
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
assert (A<>C).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).

*****
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
not (eq A C)
+++++
intro.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
intro.

*****
H2 : eq A C
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
False
+++++
subst.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
intro.
subst.

*****
H : Col C B C
H0 : not (eq (Py P C C) F0)
H1 : not (eq C B)
B,C,P : Point
*****
False
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
intro.
subst.
basic_simpl.

*****
H : Col C B C
H0 : not (eq F0 F0)
H1 : not (eq C B)
B,C,P : Point
*****
False
+++++
intuition.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).

*****
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
elim (proj_ex P A B H1).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).

*****
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
forall (x : Point) (_ : on_foot x P A B), eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
intros Q HQ.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.

*****
HQ : on_foot Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
unfold on_foot in *.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.

*****
HQ : and (perp Q P A B) (and (Col Q A B) (not (eq A B)))
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
use HQ.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.

*****
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
cases_equality A Q.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.

*****
H4 : eq A Q
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
subst.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.

*****
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H3 : perp Q P Q B
H5 : Col Q Q B
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
clear H5.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.

*****
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H3 : perp Q P Q B
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
unfold perp in H3.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.
unfold perp in H3.

*****
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H3 : eq (Py4 Q Q P B) F0
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
unfold Py4 in H3.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.
unfold perp in H3.
unfold Py4 in H3.

*****
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H3 : eq (Fminus (Py Q Q B) (Py P Q B)) F0
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.
unfold perp in H3.
unfold Py4 in H3.
basic_simpl.

*****
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H3 : eq (Fminus F0 (Py P Q B)) F0
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
IsoleVar (Py P Q B) H3.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.
unfold perp in H3.
unfold Py4 in H3.
basic_simpl.
IsoleVar (Py P Q B) H3.

*****
H3 : eq (Py P Q B) (Fminus F0 F0)
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.
unfold perp in H3.
unfold Py4 in H3.
basic_simpl.
IsoleVar (Py P Q B) H3.
basic_simpl.

*****
H3 : eq (Py P Q B) F0
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
assert (T:=perp_col_perp P Q B C H6 H3 H).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
subst.
clear H5.
unfold perp in H3.
unfold Py4 in H3.
basic_simpl.
IsoleVar (Py P Q B) H3.
basic_simpl.
assert (T:=perp_col_perp P Q B C H6 H3 H).

*****
T : per P Q C
H3 : eq (Py P Q B) F0
H : Col Q B C
H0 : not (eq (Py P Q C) F0)
H1 : not (eq Q B)
H2 : not (eq Q C)
H6 : not (eq Q B)
B,C,P,Q : Point
*****
eq (Fdiv (Py P Q B) (Py P Q C)) (Fdiv (DSeg Q B) (DSeg Q C))
+++++
intuition.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.

*****
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
assert (perp A C Q P).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).

*****
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
perp A C Q P
+++++
apply (perp_para_perp A B Q P A C).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
apply (perp_para_perp A B Q P A C).

*****
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
not (eq A B)
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
apply (perp_para_perp A B Q P A C).

*****
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
perp A B Q P
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
apply (perp_para_perp A B Q P A C).

*****
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
parallel A B A C
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).

*****
H7 : perp A C Q P
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
unfold parallel.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.

*****
H7 : perp A C Q P
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.

*****
H7 : perp A C Q P
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.

*****
H7 : perp A C Q P
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
assert (perp Q P A C)by auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.

*****
H8 : perp Q P A C
H7 : perp A C Q P
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : perp Q P A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
unfold perp in *.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.

*****
H8 : eq (Py4 Q A P C) F0
H7 : eq (Py4 A Q C P) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : eq (Py4 Q A P B) F0
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
unfold Py4 in *.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.

*****
H8 : eq (Fminus (Py Q A C) (Py P A C)) F0
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
H3 : eq (Fminus (Py Q A B) (Py P A B)) F0
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
IsoleVar (Py P A B) H3.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.

*****
H3 : eq (Py P A B) (Fminus (Py Q A B) F0)
H8 : eq (Fminus (Py Q A C) (Py P A C)) F0
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
IsoleVar (Py P A C) H8.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.

*****
H8 : eq (Py P A C) (Fminus (Py Q A C) F0)
H3 : eq (Py P A B) (Fminus (Py Q A B) F0)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
basic_simpl.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
rewrite H3.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py Q A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
rewrite H8.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Py Q A B) (Py Q A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
rewrite (col_pyth Q A B).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A Q)) (DSeg A B)) (Py Q A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
idtac.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A Q)) (DSeg A B)) (Py Q A C)) (Fdiv (DSeg A B) (DSeg A C))
+++++
rewrite (col_pyth Q A C).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
eq (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A Q)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg A Q)) (DSeg A C))) (Fdiv (DSeg A B) (DSeg A C))
+++++
field.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
field.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
and (not (eq (DSeg A C) F0)) (and (not (eq (DSeg A Q) F0)) (not (eq (Fplus F1 F1) F0)))
+++++
repeat split.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
field.
repeat split.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
not (eq (DSeg A C) F0)
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
field.
repeat split.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
not (eq (DSeg A Q) F0)
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
field.
repeat split.

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
Col Q A C
+++++
assert (Col A Q C).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
assert (Col A Q C).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
Col A Q C
+++++
apply (col_trans_1 A B Q C H1).
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
assert (Col A Q C).
apply (col_trans_1 A B Q C H1).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
Col A B Q
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
assert (Col A Q C).
apply (col_trans_1 A B Q C H1).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
Col A B C
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).
idtac.
rewrite (col_pyth Q A C).
assert (Col A Q C).

*****
H9 : Col A Q C
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
Col Q A C
+++++
auto with Geom.
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.
assert (A<>C).
elim (proj_ex P A B H1).
intros Q HQ.
unfold on_foot in *.
use HQ.
cases_equality A Q.
assert (perp A C Q P).
unfold parallel.
basic_simpl.
auto with Geom.
assert (perp Q P A C)by auto with Geom.
unfold perp in *.
unfold Py4 in *.
IsoleVar (Py P A B) H3.
IsoleVar (Py P A C) H8.
basic_simpl.
rewrite H3.
rewrite H8.
rewrite (col_pyth Q A B).

*****
H8 : eq (Py P A C) (Py Q A C)
H3 : eq (Py P A B) (Py Q A B)
H7 : eq (Fminus (Py A Q P) (Py C Q P)) F0
H4 : not (eq A Q)
H6 : not (eq A B)
H5 : Col Q A B
Q : Point
H2 : not (eq A C)
H1 : not (eq A B)
H0 : not (eq (Py P A C) F0)
H : Col A B C
A,B,C,P : Point
*****
Col Q A B
+++++
assumption .
-----
Lemma l_3_4 : forall A B C P, Col A B C -> Py P A C <> 0 -> Py P A B / Py P A C = A**B/ A**C.
Proof.
intros.
cases_equality A B.

*****

*****

+++++
Qed.
-----
From Coq Require Export Classical.
-----
Lemma per_dec : forall A B C,\n per A B C \/ ~ per A B C.
-----
Lemma per_dec : forall A B C, per A B C \\/ ~ per A B C.

*****

*****
forall A B C : Point, or (per A B C) (not (per A B C))
+++++
Proof.
-----
Lemma per_dec : forall A B C, per A B C \\/ ~ per A B C.
Proof.

*****

*****
forall A B C : Point, or (per A B C) (not (per A B C))
+++++
intros.
-----
Lemma per_dec : forall A B C, per A B C \\/ ~ per A B C.
Proof.
intros.

*****
A,B,C : Point
*****
or (per A B C) (not (per A B C))
+++++
elim (classic (Py A B C = 0)).
-----
Lemma per_dec : forall A B C, per A B C \\/ ~ per A B C.
Proof.
intros.
elim (classic (Py A B C = 0)).

*****
A,B,C : Point
*****
forall _ : eq (Py A B C) F0, or (per A B C) (not (per A B C))
+++++
intuition.
-----
Lemma per_dec : forall A B C, per A B C \\/ ~ per A B C.
Proof.
intros.
elim (classic (Py A B C = 0)).

*****
A,B,C : Point
*****
forall _ : not (eq (Py A B C) F0), or (per A B C) (not (per A B C))
+++++
intuition.
-----
Lemma per_dec : forall A B C, per A B C \\/ ~ per A B C.
Proof.
intros.
elim (classic (Py A B C = 0)).

*****

*****

+++++
Qed.
-----
Ltac cases_per A B C := elim (per_dec A B C);intros.
-----
Lemma l_3_4_b : forall A B C P,\n Col A B C ->\n Py P A B * A**C =  Py P A C * A**B.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.

*****

*****
forall (A B C P : Point) (_ : Col A B C), eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
Proof.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.

*****

*****
forall (A B C P : Point) (_ : Col A B C), eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
intros.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.

*****
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
cases_per P A C.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.

*****
H0 : per P A C
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
unfold per in H0.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.

*****
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
rewrite H0.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.

*****
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult F0 (DSeg A B))
+++++
cases_equality A C.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.

*****
H1 : eq A C
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult F0 (DSeg A B))
+++++
subst.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
subst.

*****
H : Col C B C
H0 : eq (Py P C C) F0
B,C,P : Point
*****
eq (Fmult (Py P C B) (DSeg C C)) (Fmult F0 (DSeg C B))
+++++
basic_simpl.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
subst.
basic_simpl.

*****
H : Col C B C
H0 : eq F0 F0
B,C,P : Point
*****
eq F0 F0
+++++
auto.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.

*****
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult F0 (DSeg A B))
+++++
assert (Py P A B = 0).
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
assert (Py P A B = 0).

*****
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Py P A B) F0
+++++
apply (perp_col_perp P A C B H1).
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
assert (Py P A B = 0).
apply (perp_col_perp P A C B H1).

*****
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
per P A C
+++++
auto with Geom.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
assert (Py P A B = 0).
apply (perp_col_perp P A C B H1).

*****
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
Col A C B
+++++
auto with Geom.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
assert (Py P A B = 0).

*****
H2 : eq (Py P A B) F0
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult F0 (DSeg A B))
+++++
rewrite H2.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
assert (Py P A B = 0).
rewrite H2.

*****
H2 : eq (Py P A B) F0
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult F0 (DSeg A C)) (Fmult F0 (DSeg A B))
+++++
basic_simpl.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
unfold per in H0.
rewrite H0.
cases_equality A C.
assert (Py P A B = 0).
rewrite H2.
basic_simpl.

*****
H2 : eq (Py P A B) F0
H1 : not (eq A C)
H0 : eq (Py P A C) F0
H : Col A B C
A,B,C,P : Point
*****
eq F0 F0
+++++
auto.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.

*****
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
assert (T:=l_3_4 A B C P H H0).
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).

*****
T : eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
IsoleVar (Py P A B) T.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.

*****
T : eq (Py P A B) (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C)))
H1 : not (eq (Py P A C) F0)
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Py P A B) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
rewrite T.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.

*****
T : eq (Py P A B) (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C)))
H1 : not (eq (Py P A C) F0)
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
eq (Fmult (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C))) (DSeg A C)) (Fmult (Py P A C) (DSeg A B))
+++++
field.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.
field.

*****
T : eq (Py P A B) (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C)))
H1 : not (eq (Py P A C) F0)
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
not (eq (DSeg A C) F0)
+++++
intro.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.
field.
intro.

*****
H2 : eq (DSeg A C) F0
T : eq (Py P A B) (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C)))
H1 : not (eq (Py P A C) F0)
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
False
+++++
assert (A=C).
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.
field.
intro.
assert (A=C).

*****
H2 : eq (DSeg A C) F0
T : eq (Py P A B) (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C)))
H1 : not (eq (Py P A C) F0)
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
eq A C
+++++
auto with Geom.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.
field.
intro.
assert (A=C).

*****
H3 : eq A C
H2 : eq (DSeg A C) F0
T : eq (Py P A B) (Fmult (Py P A C) (Fdiv (DSeg A B) (DSeg A C)))
H1 : not (eq (Py P A C) F0)
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
False
+++++
subst.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.
field.
intro.
assert (A=C).
subst.

*****
H : Col C B C
H0 : not (per P C C)
H1 : not (eq (Py P C C) F0)
T : eq (Py P C B) (Fmult (Py P C C) (Fdiv (DSeg C B) (DSeg C C)))
H2 : eq (DSeg C C) F0
B,C,P : Point
*****
False
+++++
basic_simpl.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.
rewrite T.
field.
intro.
assert (A=C).
subst.
basic_simpl.

*****
H : Col C B C
H0 : not (per P C C)
H1 : not (eq F0 F0)
T : eq (Py P C B) F0
H2 : eq F0 F0
B,C,P : Point
*****
False
+++++
auto.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.
assert (T:=l_3_4 A B C P H H0).
IsoleVar (Py P A B) T.

*****
T : eq (Fdiv (Py P A B) (Py P A C)) (Fdiv (DSeg A B) (DSeg A C))
H0 : not (per P A C)
H : Col A B C
A,B,C,P : Point
*****
not (eq (Py P A C) F0)
+++++
auto.
-----
Lemma l_3_4_b : forall A B C P, Col A B C -> Py P A B * A**C = Py P A C * A**B.
Proof.
intros.
cases_per P A C.

*****

*****

+++++
Qed.
-----
Lemma l_28_b : forall A B U V Y,\nU <> V ->\nCol Y U V -> \nPy A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.

*****

*****
forall (A B U V Y : Point) (_ : not (eq U V)) (_ : Col Y U V), eq (Py A B Y) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A B U)))
+++++
Proof.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.

*****

*****
forall (A B U V Y : Point) (_ : not (eq U V)) (_ : Col Y U V), eq (Py A B Y) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A B U)))
+++++
intros.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.

*****
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A B Y) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A B U)))
+++++
set (r1 := U ** Y / U ** V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).

*****
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A B U)))
+++++
set (r2 := Y ** V / U ** V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult r2 (Py A B U)))
+++++
assert (r2 = 1 -r1).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq r2 (Fminus F1 r1)
+++++
unfold r1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq r2 (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
unfold r2.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fdiv (DSeg Y V) (DSeg U V)) (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
rewrite <- (chasles Y U V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fdiv (Fplus (DSeg Y U) (DSeg U V)) (DSeg U V)) (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
uniformize_dir_seg.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).
uniformize_dir_seg.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fdiv (Fplus (Fopp (DSeg U Y)) (DSeg U V)) (DSeg U V)) (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
field.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).
uniformize_dir_seg.
field.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
Col Y U V
+++++
assumption.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult r2 (Py A B U)))
+++++
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))), eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult r2 (Py A B U)))
+++++
intro Ha.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult r2 (Py A B U)))
+++++
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))), eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult r2 (Py A B U)))
+++++
intro Hb.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A B Y) (Fplus (Fmult r1 (Py A B V)) (Fmult r2 (Py A B U)))
+++++
unfold Py.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B Y) (DSeg B Y))) (Fmult (DSeg A Y) (DSeg A Y))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
rewrite Ha.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fmult (DSeg A Y) (DSeg A Y))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
rewrite Hb.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
uniformize_dir_seg.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (Fopp (DSeg A U))) (Fopp (DSeg A U)))\n (Fmult (Fmult r1 (Fopp (DSeg A V))) (Fopp (DSeg A V))))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (Fopp (DSeg B U))) (Fopp (DSeg B U)))\n (Fmult (Fmult r1 (Fopp (DSeg B V))) (Fopp (DSeg B V))))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fminus (Fplus (Fmult (Fmult r2 (Fopp (DSeg B U))) (Fopp (DSeg B U))) (Fmult (Fmult r1 (Fopp (DSeg B V))) (Fopp (DSeg B V)))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fminus (Fplus (Fmult (Fmult r2 (Fopp (DSeg A U))) (Fopp (DSeg A U))) (Fmult (Fmult r1 (Fopp (DSeg A V))) (Fopp (DSeg A V)))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
basic_simpl.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.
basic_simpl.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U)) (Fmult (Fmult r1 (DSeg B V)) (DSeg B V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U)) (Fmult (Fmult r1 (DSeg A V)) (DSeg A V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
assert ( (A ** B * A ** B) = (r1 + r2) * (A ** B * A ** B)).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.
basic_simpl.
assert ( (A ** B * A ** B) = (r1 + r2) * (A ** B * A ** B)).

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fplus r1 r2) (Fmult (DSeg A B) (DSeg A B)))
+++++
rewrite H1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.
basic_simpl.
assert ( (A ** B * A ** B) = (r1 + r2) * (A ** B * A ** B)).
rewrite H1.

*****
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fplus r1 (Fminus F1 r1)) (Fmult (DSeg A B) (DSeg A B)))
+++++
ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.
basic_simpl.
assert ( (A ** B * A ** B) = (r1 + r2) * (A ** B * A ** B)).

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fmult (Fplus r1 r2) (Fmult (DSeg A B) (DSeg A B)))
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U)) (Fmult (Fmult r1 (DSeg B V)) (DSeg B V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U)) (Fmult (Fmult r1 (DSeg A V)) (DSeg A V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
idtac.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.
basic_simpl.
assert ( (A ** B * A ** B) = (r1 + r2) * (A ** B * A ** B)).
idtac.

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fmult (Fplus r1 r2) (Fmult (DSeg A B) (DSeg A B)))
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U)) (Fmult (Fmult r1 (DSeg B V)) (DSeg B V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U)) (Fmult (Fmult r1 (DSeg A V)) (DSeg A V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
rewrite H2 at 1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Hb.
unfold Py.
rewrite Ha.
rewrite Hb.
uniformize_dir_seg.
basic_simpl.
assert ( (A ** B * A ** B) = (r1 + r2) * (A ** B * A ** B)).
idtac.
rewrite H2 at 1.

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fmult (Fplus r1 r2) (Fmult (DSeg A B) (DSeg A B)))
Hb : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (Fplus r1 r2) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U)) (Fmult (Fmult r1 (DSeg B V)) (DSeg B V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U)) (Fmult (Fmult r1 (DSeg A V)) (DSeg A V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A V) (DSeg A V)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A U) (DSeg A U)))))
+++++
field.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
+++++
rewrite H1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fmult (Fminus F1 r1) (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 (Fminus F1 r1)) (DSeg U V)) (DSeg U V)))
+++++
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fplus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult r1 (Fminus (Fminus (Fmult (DSeg V A) (DSeg V A)) (Fmult (DSeg U A) (DSeg U A))) (Fmult (DSeg U V) (DSeg U V))))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)))
+++++
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py A U V)))
+++++
cut (r1 * Py A U V = Py A U Y).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (Py A U V)) (Py A U Y), eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py A U V)))
+++++
intro Hab.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py A U V)))
+++++
rewrite Hab.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Py A U Y))
+++++
unfold Py.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
uniformize_dir_seg.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (Fopp (DSeg B U))) (Fopp (DSeg B U)))\n (Fmult (Fmult r1 (Fopp (DSeg B V))) (Fopp (DSeg B V))))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fopp (DSeg A U)) (Fopp (DSeg A U))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
basic_simpl.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
cut (r1 * U**V = U**Y).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (DSeg U V)) (DSeg U Y), eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
intro Hb.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (DSeg U Y) (DSeg U Y))
+++++
rewrite <- Hb.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
rewrite <- Hb.

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (Fmult r1 (DSeg U V)) (Fmult r1 (DSeg U V)))
+++++
ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
idtac.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
rewrite H2.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.
rewrite H2.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (DSeg U V)) (DSeg U Y)
+++++
unfold r1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (DSeg U V)) (DSeg U Y)
+++++
field.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.
field.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
assert (Py A U V * U ** Y = Py A U Y * U ** V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
+++++
apply (l_3_4_b U V Y A).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
apply (l_3_4_b U V Y A).

*****
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
Col U V Y
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).

*****
H2 : eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
rename H2 into T.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.

*****
T : eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
IsoleVar (Py A U Y) T.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
rewrite T.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.
rewrite T.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
+++++
unfold r1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.
rewrite T.
unfold r1.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A U V)) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
+++++
field.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.
rewrite T.
unfold r1.
field.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Ha.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.

*****
T : eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
Ha : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
+++++
rewrite H1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fmult (Fminus F1 r1) (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 (Fminus F1 r1)) (DSeg U V)) (DSeg U V)))
+++++
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fplus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult r1 (Fminus (Fminus (Fmult (DSeg V B) (DSeg V B)) (Fmult (DSeg U B) (DSeg U B))) (Fmult (DSeg U V) (DSeg U V))))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)))
+++++
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py B U V)))
+++++
cut (r1 * Py B U V = Py B U Y).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (Py B U V)) (Py B U Y), eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py B U V)))
+++++
intro Hab.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py B U V)))
+++++
rewrite Hab.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Py B U Y))
+++++
unfold Py.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
uniformize_dir_seg.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fopp (DSeg B U)) (Fopp (DSeg B U))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
basic_simpl.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
cut (r1 * U**V = U**Y).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (DSeg U V)) (DSeg U Y), eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
intro Hb.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (DSeg U Y) (DSeg U Y))
+++++
rewrite <- Hb.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
rewrite <- Hb.

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (Fmult r1 (DSeg U V)) (Fmult r1 (DSeg U V)))
+++++
ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
idtac.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
rewrite H2.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.
rewrite H2.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
ring.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (DSeg U V)) (DSeg U Y)
+++++
unfold r1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (DSeg U V)) (DSeg U Y)
+++++
field.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.
field.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
assert (Py B U V * U ** Y = Py B U Y * U ** V).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
+++++
apply (l_3_4_b U V Y B).
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
apply (l_3_4_b U V Y B).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
Col U V Y
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).

*****
H2 : eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
rename H2 into T.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.

*****
T : eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
IsoleVar (Py B U Y) T.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
rewrite T.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.
rewrite T.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
+++++
unfold r1.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.
rewrite T.
unfold r1.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py B U V)) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
+++++
field.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.
rewrite T.
unfold r1.
field.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.

*****
T : eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l_28_b : forall A B U V Y, U <> V -> Col Y U V -> Py A B Y = U**Y/U**V * Py A B V + Y**V/U**V * Py A B U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).

*****

*****

+++++
Qed.
-----
Lemma l3_5_py : forall A B U V Y,\n  U <> V ->\n  Col Y U V ->  \n  Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B \n  - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.

*****

*****
forall (A B U V Y : Point) (_ : not (eq U V)) (_ : Col Y U V), eq (Py A Y B) (Fminus (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A V B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A U B))) (Fmult (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (DSeg Y V) (DSeg U V))) (Py U V U)))
+++++
Proof.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.

*****

*****
forall (A B U V Y : Point) (_ : not (eq U V)) (_ : Col Y U V), eq (Py A Y B) (Fminus (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A V B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A U B))) (Fmult (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (DSeg Y V) (DSeg U V))) (Py U V U)))
+++++
intros.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.

*****
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A Y B) (Fminus (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A V B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A U B))) (Fmult (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Fdiv (DSeg Y V) (DSeg U V))) (Py U V U)))
+++++
set (r1 := U ** Y / U ** V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).

*****
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (Py A U B))) (Fmult (Fmult r1 (Fdiv (DSeg Y V) (DSeg U V))) (Py U V U)))
+++++
set (r2 := Y ** V / U ** V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult r2 (Py A U B))) (Fmult (Fmult r1 r2) (Py U V U)))
+++++
assert (r2 = 1 -r1).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq r2 (Fminus F1 r1)
+++++
unfold r1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq r2 (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
unfold r2.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fdiv (DSeg Y V) (DSeg U V)) (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
rewrite <- (chasles Y U V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fdiv (Fplus (DSeg Y U) (DSeg U V)) (DSeg U V)) (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
uniformize_dir_seg.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).
uniformize_dir_seg.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fdiv (Fplus (Fopp (DSeg U Y)) (DSeg U V)) (DSeg U V)) (Fminus F1 (Fdiv (DSeg U Y) (DSeg U V)))
+++++
field.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).
uniformize_dir_seg.
field.

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
unfold r1.
unfold r2.
rewrite <- (chasles Y U V).

*****
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
Col Y U V
+++++
assumption.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult r2 (Py A U B))) (Fmult (Fmult r1 r2) (Py U V U)))
+++++
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))), eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult r2 (Py A U B))) (Fmult (Fmult r1 r2) (Py U V U)))
+++++
intro Hb.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult r2 (Py A U B))) (Fmult (Fmult r1 r2) (Py U V U)))
+++++
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))), eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult r2 (Py A U B))) (Fmult (Fmult r1 r2) (Py U V U)))
+++++
intro Ha.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Py A Y B) (Fminus (Fplus (Fmult r1 (Py A V B)) (Fmult r2 (Py A U B))) (Fmult (Fmult r1 r2) (Py U V U)))
+++++
unfold Py.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A Y) (DSeg A Y)) (Fmult (DSeg Y B) (DSeg Y B))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (DSeg V B) (DSeg V B))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U B) (DSeg U B))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 r2) (Fminus (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg V U) (DSeg V U))) (Fmult (DSeg U U) (DSeg U U)))))
+++++
rewrite Ha.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.
rewrite Ha.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))) (Fmult (DSeg Y B) (DSeg Y B))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (DSeg V B) (DSeg V B))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U B) (DSeg U B))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 r2) (Fminus (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg V U) (DSeg V U))) (Fmult (DSeg U U) (DSeg U U)))))
+++++
replace (Y ** B * Y ** B) with (B ** Y * B ** Y) by (uniformize_dir_seg;field).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.
rewrite Ha.
replace (Y ** B * Y ** B) with (B ** Y * B ** Y) by (uniformize_dir_seg;field).

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))) (Fmult (DSeg B Y) (DSeg B Y))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (DSeg V B) (DSeg V B))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U B) (DSeg U B))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 r2) (Fminus (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg V U) (DSeg V U))) (Fmult (DSeg U U) (DSeg U U)))))
+++++
rewrite Hb.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.
rewrite Ha.
replace (Y ** B * Y ** B) with (B ** Y * B ** Y) by (uniformize_dir_seg;field).
rewrite Hb.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A))\n (Fmult (Fmult r1 (DSeg V A)) (DSeg V A)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (DSeg V B) (DSeg V B))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U B) (DSeg U B))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 r2) (Fminus (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg V U) (DSeg V U))) (Fmult (DSeg U U) (DSeg U U)))))
+++++
uniformize_dir_seg.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.
rewrite Ha.
replace (Y ** B * Y ** B) with (B ** Y * B ** Y) by (uniformize_dir_seg;field).
rewrite Hb.
uniformize_dir_seg.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (Fopp (DSeg A U))) (Fopp (DSeg A U)))\n (Fmult (Fmult r1 (Fopp (DSeg A V))) (Fopp (DSeg A V))))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (Fopp (DSeg B U))) (Fopp (DSeg B U)))\n (Fmult (Fmult r1 (Fopp (DSeg B V))) (Fopp (DSeg B V))))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fmult (Fmult r2 (Fopp (DSeg A U))) (Fopp (DSeg A U))) (Fmult (Fmult r1 (Fopp (DSeg A V))) (Fopp (DSeg A V)))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (Fmult r2 (Fopp (DSeg B U))) (Fopp (DSeg B U))) (Fmult (Fmult r1 (Fopp (DSeg B V))) (Fopp (DSeg B V)))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (Fopp (DSeg B V)) (Fopp (DSeg B V)))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fopp (DSeg B U)) (Fopp (DSeg B U)))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 r2) (Fminus (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (Fopp (DSeg U V)) (Fopp (DSeg U V)))) (Fmult (DSeg U U) (DSeg U U)))))
+++++
basic_simpl.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.
rewrite Ha.
replace (Y ** B * Y ** B) with (B ** Y * B ** Y) by (uniformize_dir_seg;field).
rewrite Hb.
uniformize_dir_seg.
basic_simpl.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U)) (Fmult (Fmult r1 (DSeg A V)) (DSeg A V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U)) (Fmult (Fmult r1 (DSeg B V)) (DSeg B V))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult r2 (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 r2) (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg U V) (DSeg U V)))))
+++++
rewrite H1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
intro Ha.
unfold Py.
rewrite Ha.
replace (Y ** B * Y ** B) with (B ** Y * B ** Y) by (uniformize_dir_seg;field).
rewrite Hb.
uniformize_dir_seg.
basic_simpl.
rewrite H1.

*****
Ha : eq (Fmult (DSeg A Y) (DSeg A Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg A U)) (DSeg A U))\n (Fmult (Fmult r1 (DSeg A V)) (DSeg A V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fminus (Fplus (Fminus (Fplus (Fmult (Fmult (Fminus F1 r1) (DSeg A U)) (DSeg A U)) (Fmult (Fmult r1 (DSeg A V)) (DSeg A V))) (Fmult (Fmult (Fmult r1 (Fminus F1 r1)) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (Fmult (Fminus F1 r1) (DSeg B U)) (DSeg B U)) (Fmult (Fmult r1 (DSeg B V)) (DSeg B V))) (Fmult (Fmult (Fmult r1 (Fminus F1 r1)) (DSeg U V)) (DSeg U V)))) (Fmult (DSeg A B) (DSeg A B))) (Fminus (Fplus (Fmult r1 (Fminus (Fplus (Fmult (DSeg A V) (DSeg A V)) (Fmult (DSeg B V) (DSeg B V))) (Fmult (DSeg A B) (DSeg A B)))) (Fmult (Fminus F1 r1) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg B U) (DSeg B U))) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult r1 (Fminus F1 r1)) (Fplus (Fmult (DSeg U V) (DSeg U V)) (Fmult (DSeg U V) (DSeg U V)))))
+++++
ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
+++++
rewrite H1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fmult (Fminus F1 r1) (DSeg U A)) (DSeg U A)) (Fmult (Fmult r1 (DSeg V A)) (DSeg V A))) (Fmult (Fmult (Fmult r1 (Fminus F1 r1)) (DSeg U V)) (DSeg U V)))
+++++
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fplus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult r1 (Fminus (Fminus (Fmult (DSeg V A) (DSeg V A)) (Fmult (DSeg U A) (DSeg U A))) (Fmult (DSeg U V) (DSeg U V))))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)))
+++++
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py A U V)))
+++++
cut (r1 * Py A U V = Py A U Y).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (Py A U V)) (Py A U Y), eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py A U V)))
+++++
intro Hab.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py A U V)))
+++++
rewrite Hab.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Py A U Y))
+++++
unfold Py.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg U A) (DSeg U A)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
uniformize_dir_seg.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (Fopp (DSeg B U))) (Fopp (DSeg B U)))\n (Fmult (Fmult r1 (Fopp (DSeg B V))) (Fopp (DSeg B V))))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (Fopp (DSeg A U)) (Fopp (DSeg A U))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
basic_simpl.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
cut (r1 * U**V = U**Y).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (DSeg U V)) (DSeg U Y), eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
intro Hbb.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hbb.

*****
Hbb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hbb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
Hbb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (DSeg U Y) (DSeg U Y))
+++++
rewrite <- Hbb.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hbb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
rewrite <- Hbb.

*****
Hbb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (Fmult r1 (DSeg U V)) (Fmult r1 (DSeg U V)))
+++++
ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hbb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hbb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
idtac.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hbb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hbb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
rewrite H2.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hbb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.
rewrite H2.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hbb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg A Y) (DSeg A Y)) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fminus (Fplus (Fmult (DSeg A U) (DSeg A U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg A Y) (DSeg A Y))))
+++++
ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (DSeg U V)) (DSeg U Y)
+++++
unfold r1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (DSeg U V)) (DSeg U Y)
+++++
field.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.
field.

*****
Hab : eq (Fmult r1 (Py A U V)) (Py A U Y)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg B U)) (DSeg B U))\n (Fmult (Fmult r1 (DSeg B V)) (DSeg B V)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
assert (Py A U V * U ** Y = Py A U Y * U ** V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
+++++
apply (l_3_4_b U V Y A).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
apply (l_3_4_b U V Y A).

*****
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
Col U V Y
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).

*****
H2 : eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
rename H2 into T.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.

*****
T : eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
IsoleVar (Py A U Y) T.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Py A U Y)
+++++
rewrite T.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.
rewrite T.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py A U V)) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
+++++
unfold r1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.
rewrite T.
unfold r1.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py A U V)) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
+++++
field.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.
rewrite T.
unfold r1.
field.

*****
T : eq (Py A U Y) (Fdiv (Fmult (Py A U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
intro Hb.
cut (A**Y * A**Y = r2 * U**A * U**A + r1 * V**A * V**A - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** A * U ** A + r1 * V ** A * V ** A - r1 * (1 - r1) * U ** V * U ** V) with (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** A * U ** A + r1 * (V ** A * V ** A - U ** A * U ** A - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** A * U ** A + r1 * r1 * U**V * U**V - r1 * Py A U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py A U V = Py A U Y).
assert (Py A U V * U ** Y = Py A U Y * U ** V).
rename H2 into T.
IsoleVar (Py A U Y) T.

*****
T : eq (Fmult (Py A U V) (DSeg U Y)) (Fmult (Py A U Y) (DSeg U V))
Hb : eq (Fmult (DSeg B Y) (DSeg B Y))\n (Fminus\n (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B))\n (Fmult (Fmult r1 (DSeg V B)) (DSeg V B)))\n (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fmult r2 (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 r2) (DSeg U V)) (DSeg U V)))
+++++
rewrite H1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fmult (Fminus F1 r1) (DSeg U B)) (DSeg U B)) (Fmult (Fmult r1 (DSeg V B)) (DSeg V B))) (Fmult (Fmult (Fmult r1 (Fminus F1 r1)) (DSeg U V)) (DSeg U V)))
+++++
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fplus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult r1 (Fminus (Fminus (Fmult (DSeg V B) (DSeg V B)) (Fmult (DSeg U B) (DSeg U B))) (Fmult (DSeg U V) (DSeg U V))))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)))
+++++
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py B U V)))
+++++
cut (r1 * Py B U V = Py B U Y).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (Py B U V)) (Py B U Y), eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py B U V)))
+++++
intro Hab.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fmult r1 (Py B U V)))
+++++
rewrite Hab.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Py B U Y))
+++++
unfold Py.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg U B) (DSeg U B)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
uniformize_dir_seg.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (Fopp (DSeg B U)) (Fopp (DSeg B U))) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
basic_simpl.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
cut (r1 * U**V = U**Y).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
forall _ : eq (Fmult r1 (DSeg U V)) (DSeg U Y), eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
intro Hb.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (DSeg U Y) (DSeg U Y))
+++++
rewrite <- Hb.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
rewrite <- Hb.

*****
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V)) (Fmult (Fmult r1 (DSeg U V)) (Fmult r1 (DSeg U V)))
+++++
ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
idtac.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
rewrite H2.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
intro Hb.
assert (r1 * r1 * U ** V * U ** V = U**Y * U**Y).
idtac.
rewrite H2.

*****
H2 : eq (Fmult (Fmult (Fmult r1 r1) (DSeg U V)) (DSeg U V))\n (Fmult (DSeg U Y) (DSeg U Y))
Hb : eq (Fmult r1 (DSeg U V)) (DSeg U Y)
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (DSeg B Y) (DSeg B Y)) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fminus (Fplus (Fmult (DSeg B U) (DSeg B U)) (Fmult (DSeg U Y) (DSeg U Y))) (Fmult (DSeg B Y) (DSeg B Y))))
+++++
ring.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (DSeg U V)) (DSeg U Y)
+++++
unfold r1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (DSeg U V)) (DSeg U Y)
+++++
field.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
intro Hab.
rewrite Hab.
unfold Py.
uniformize_dir_seg.
basic_simpl.
cut (r1 * U**V = U**Y).
unfold r1.
field.

*****
Hab : eq (Fmult r1 (Py B U V)) (Py B U Y)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
assert (Py B U V * U ** Y = Py B U Y * U ** V).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
+++++
apply (l_3_4_b U V Y B).
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
apply (l_3_4_b U V Y B).

*****
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
Col U V Y
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).

*****
H2 : eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
rename H2 into T.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.

*****
T : eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
IsoleVar (Py B U Y) T.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Py B U Y)
+++++
rewrite T.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.
rewrite T.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult r1 (Py B U V)) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
+++++
unfold r1.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.
rewrite T.
unfold r1.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
eq (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (Py B U V)) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
+++++
field.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.
rewrite T.
unfold r1.
field.

*****
T : eq (Py B U Y) (Fdiv (Fmult (Py B U V) (DSeg U Y)) (DSeg U V))
H2 : not (eq (DSeg U V) F0)
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).
cut (B**Y * B**Y = r2 * U**B * U**B + r1 * V**B * V**B - r1 * r2 * U**V * U**V).
rewrite H1.
replace ((1 - r1) * U ** B * U ** B + r1 * V ** B * V ** B - r1 * (1 - r1) * U ** V * U ** V) with (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 *r1 * U ** V * U ** V) by ring.
replace (U ** B * U ** B + r1 * (V ** B * V ** B - U ** B * U ** B - U ** V * U ** V) + r1 * r1 * U ** V * U ** V) with (U ** B * U ** B + r1 * r1 * U**V * U**V - r1 * Py B U V) by (unfold Py; uniformize_dir_seg; ring).
cut (r1 * Py B U V = Py B U Y).
assert (Py B U V * U ** Y = Py B U Y * U ** V).
rename H2 into T.
IsoleVar (Py B U Y) T.

*****
T : eq (Fmult (Py B U V) (DSeg U Y)) (Fmult (Py B U Y) (DSeg U V))
H1 : eq r2 (Fminus F1 r1)
r2 : F
r1 : F
H0 : Col Y U V
H : not (eq U V)
A,B,U,V,Y : Point
*****
not (eq (DSeg U V) F0)
+++++
auto with Geom.
-----
Lemma l3_5_py : forall A B U V Y, U <> V -> Col Y U V -> Py A Y B = U**Y / U**V * Py A V B + Y**V/ U**V * Py A U B - (U**Y/ U**V) * (Y**V / U**V) * Py U V U.
Proof.
intros.
set (r1 := U ** Y / U ** V).
set (r2 := Y ** V / U ** V).
assert (r2 = 1 -r1).

*****

*****

+++++
Qed.
-----
Lemma midpoint_ratio_1 : forall O B D,\nmid_point O B D ->  B<>D -> B ** O / B ** D = 1/2.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.

*****

*****
forall (O B D : Point) (_ : mid_point O B D) (_ : not (eq B D)), eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
Proof.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.

*****

*****
forall (O B D : Point) (_ : mid_point O B D) (_ : not (eq B D)), eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
intros.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.

*****
H0 : not (eq B D)
H : mid_point O B D
O,B,D : Point
*****
eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
unfold mid_point in *.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.

*****
H0 : not (eq B D)
H : and (Col B D O) (eq (DSeg B O) (DSeg O D))
O,B,D : Point
*****
eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
use H.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
assert (B**D = B**O + O**D).
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
+++++
symmetry.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
symmetry.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fplus (DSeg B O) (DSeg O D)) (DSeg B D)
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
rewrite H.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fdiv (DSeg B O) (Fplus (DSeg B O) (DSeg O D))) (Fdiv F1 (Fplus F1 F1))
+++++
rewrite H2.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fdiv (DSeg O D) (Fplus (DSeg O D) (DSeg O D))) (Fdiv F1 (Fplus F1 F1))
+++++
field.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
and (not (eq (Fplus F1 F1) F0)) (not (eq (Fplus (DSeg O D) (DSeg O D)) F0))
+++++
split.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq (Fplus (DSeg O D) (DSeg O D)) F0)
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq (Fplus (DSeg O D) (DSeg O D)) F0)
+++++
replace (O ** D + O ** D) with (2*O**D) by ring.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq (Fmult (Fplus F1 F1) (DSeg O D)) F0)
+++++
apply nonzeromult.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.

*****
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq (DSeg O D) F0)
+++++
intro.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.

*****
H3 : eq (DSeg O D) F0
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
False
+++++
assert (O=D).
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).

*****
H3 : eq (DSeg O D) F0
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq O D
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).

*****
H4 : eq O D
H3 : eq (DSeg O D) F0
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
False
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).
auto with Geom.

*****
H4 : eq O D
H3 : eq (DSeg O D) F0
H : eq (DSeg B D) (Fplus (DSeg B O) (DSeg O D))
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
False
+++++
subst O.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).
auto with Geom.
subst O.

*****
H1 : Col B D D
H2 : eq (DSeg B D) (DSeg D D)
H : eq (DSeg B D) (Fplus (DSeg B D) (DSeg D D))
H3 : eq (DSeg D D) F0
H0 : not (eq B D)
B,D : Point
*****
False
+++++
basic_simpl.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).
auto with Geom.
subst O.
basic_simpl.

*****
H1 : Col B D D
H2 : eq (DSeg B D) F0
H : eq (DSeg B D) (DSeg B D)
H3 : eq F0 F0
H0 : not (eq B D)
B,D : Point
*****
False
+++++
assert (B=D).
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).
auto with Geom.
subst O.
basic_simpl.
assert (B=D).

*****
H1 : Col B D D
H2 : eq (DSeg B D) F0
H : eq (DSeg B D) (DSeg B D)
H3 : eq F0 F0
H0 : not (eq B D)
B,D : Point
*****
eq B D
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).
rewrite H.
rewrite H2.
field.
split.
auto with Geom.
replace (O ** D + O ** D) with (2*O**D) by ring.
apply nonzeromult.
intro.
assert (O=D).
auto with Geom.
subst O.
basic_simpl.
assert (B=D).

*****
H4 : eq B D
H1 : Col B D D
H2 : eq (DSeg B D) F0
H : eq (DSeg B D) (DSeg B D)
H3 : eq F0 F0
H0 : not (eq B D)
B,D : Point
*****
False
+++++
auto with Geom.
-----
Lemma midpoint_ratio_1 : forall O B D, mid_point O B D -> B<>D -> B ** O / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
assert (B**D = B**O + O**D).

*****

*****

+++++
Qed.
-----
Lemma midpoint_ratio_2 : forall O B D,\nmid_point O B D ->  B<>D -> O ** D / B ** D = 1/2.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.

*****

*****
forall (O B D : Point) (_ : mid_point O B D) (_ : not (eq B D)), eq (Fdiv (DSeg O D) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
Proof.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.

*****

*****
forall (O B D : Point) (_ : mid_point O B D) (_ : not (eq B D)), eq (Fdiv (DSeg O D) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
intros.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.

*****
H0 : not (eq B D)
H : mid_point O B D
O,B,D : Point
*****
eq (Fdiv (DSeg O D) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
unfold mid_point in *.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.

*****
H0 : not (eq B D)
H : and (Col B D O) (eq (DSeg B O) (DSeg O D))
O,B,D : Point
*****
eq (Fdiv (DSeg O D) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
use H.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fdiv (DSeg O D) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
rewrite <- H2.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
rewrite <- H2.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
eq (Fdiv (DSeg B O) (DSeg B D)) (Fdiv F1 (Fplus F1 F1))
+++++
apply midpoint_ratio_1.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
rewrite <- H2.
apply midpoint_ratio_1.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
mid_point O B D
+++++
unfold mid_point.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
rewrite <- H2.
apply midpoint_ratio_1.
unfold mid_point.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
and (Col B D O) (eq (DSeg B O) (DSeg O D))
+++++
auto.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
rewrite <- H2.
apply midpoint_ratio_1.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : not (eq B D)
O,B,D : Point
*****
not (eq B D)
+++++
auto.
-----
Lemma midpoint_ratio_2 : forall O B D, mid_point O B D -> B<>D -> O ** D / B ** D = 1/2.
Proof.
intros.
unfold mid_point in *.
use H.
rewrite <- H2.
apply midpoint_ratio_1.

*****

*****

+++++
Qed.
-----
Lemma l_28_midpoint : forall O A B P Q,\n mid_point O A B ->\n 2 * Py O P Q = Py A P Q + Py B P Q.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.

*****

*****
forall (O A B P Q : Point) (_ : mid_point O A B), eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
Proof.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.

*****

*****
forall (O A B P Q : Point) (_ : mid_point O A B), eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
intros.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.

*****
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
cases_equality A B.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.

*****
H0 : eq A B
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
subst A.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
subst A.

*****
H : mid_point O B B
O,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py B P Q) (Py B P Q))
+++++
assert (O=B).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
subst A.
assert (O=B).

*****
H : mid_point O B B
O,B,P,Q : Point
*****
eq O B
+++++
auto with Geom.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
subst A.
assert (O=B).

*****
H0 : eq O B
H : mid_point O B B
O,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py B P Q) (Py B P Q))
+++++
subst O.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
subst A.
assert (O=B).
subst O.

*****
H : mid_point B B B
B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py B P Q)) (Fplus (Py B P Q) (Py B P Q))
+++++
ring.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
assert (Col O A B).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
Col O A B
+++++
unfold mid_point in *.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
unfold mid_point in *.

*****
H0 : not (eq A B)
H : and (Col A B O) (eq (DSeg A O) (DSeg O B))
O,A,B,P,Q : Point
*****
Col O A B
+++++
use H.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
unfold mid_point in *.
use H.

*****
H2 : eq (DSeg A O) (DSeg O B)
H1 : Col A B O
H0 : not (eq A B)
O,A,B,P,Q : Point
*****
Col O A B
+++++
auto with Geom.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).

*****
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
assert (T:=l_28_b Q P A B O H0 H1).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py Q P B))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py Q P A)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py B P Q))
+++++
replace (Py O P Q) with (Py Q P O) by auto with Geom.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py Q P B))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py Q P A)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py Q P O)) (Fplus (Py A P Q) (Py B P Q))
+++++
rewrite T.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py Q P B))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py Q P A)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py Q P B)) (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py Q P A)))) (Fplus (Py A P Q) (Py B P Q))
+++++
uniformize_pys.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q)) (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))) (Fplus (Py A P Q) (Py B P Q))
+++++
replace (A ** O / A ** B) with (1/2).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B P Q)) (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))) (Fplus (Py A P Q) (Py B P Q))
+++++
replace (O ** B / A ** B) with (1/2).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
replace (O ** B / A ** B) with (1/2).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B P Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A P Q)))) (Fplus (Py A P Q) (Py B P Q))
+++++
field.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
replace (O ** B / A ** B) with (1/2).
field.

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
replace (O ** B / A ** B) with (1/2).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fdiv F1 (Fplus F1 F1)) (Fdiv (DSeg O B) (DSeg A B))
+++++
symmetry.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
replace (O ** B / A ** B) with (1/2).
symmetry.

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fdiv (DSeg O B) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
+++++
apply (midpoint_ratio_2).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
replace (O ** B / A ** B) with (1/2).
symmetry.
apply (midpoint_ratio_2).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
mid_point O A B
+++++
auto.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
replace (O ** B / A ** B) with (1/2).
symmetry.
apply (midpoint_ratio_2).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
not (eq A B)
+++++
auto.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fdiv F1 (Fplus F1 F1)) (Fdiv (DSeg A O) (DSeg A B))
+++++
symmetry.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
symmetry.

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fdiv (DSeg A O) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
+++++
apply (midpoint_ratio_1).
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
symmetry.
apply (midpoint_ratio_1).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
mid_point O A B
+++++
auto.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.
assert (Col O A B).
assert (T:=l_28_b Q P A B O H0 H1).
replace (Py O P Q) with (Py Q P O) by auto with Geom.
rewrite T.
uniformize_pys.
replace (A ** O / A ** B) with (1/2).
symmetry.
apply (midpoint_ratio_1).

*****
T : eq (Py Q P O)\n (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py B P Q))\n (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py A P Q)))
H1 : Col O A B
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
not (eq A B)
+++++
auto.
-----
Lemma l_28_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py O P Q = Py A P Q + Py B P Q.
Proof.
intros.
cases_equality A B.

*****

*****

+++++
Qed.
-----
Lemma l_28_b_midpoint : forall O A B P Q,\n mid_point O A B ->\n 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.

*****

*****
forall (O A B P Q : Point) (_ : mid_point O A B), eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
Proof.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.

*****

*****
forall (O A B P Q : Point) (_ : mid_point O A B), eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
intros.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.

*****
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
cases_equality A B.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.

*****
H0 : eq A B
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
subst A.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
subst A.

*****
H : mid_point O B B
O,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fminus (Fplus (Py P B Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B B B)))
+++++
basic_simpl.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
subst A.
basic_simpl.

*****
H : mid_point O B B
O,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fplus (Py P B Q) (Py P B Q))
+++++
assert (O=B).
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
subst A.
basic_simpl.
assert (O=B).

*****
H : mid_point O B B
O,B,P,Q : Point
*****
eq O B
+++++
auto with Geom.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
subst A.
basic_simpl.
assert (O=B).

*****
H0 : eq O B
H : mid_point O B B
O,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fplus (Py P B Q) (Py P B Q))
+++++
idtac.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
subst A.
basic_simpl.
assert (O=B).
idtac.

*****
H0 : eq O B
H : mid_point O B B
O,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fplus (Py P B Q) (Py P B Q))
+++++
subst O.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
subst A.
basic_simpl.
assert (O=B).
idtac.
subst O.

*****
H : mid_point B B B
B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P B Q)) (Fplus (Py P B Q) (Py P B Q))
+++++
ring.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py P O Q)) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
rewrite ( l3_5_py P Q A B O).
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py P B Q)) (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py P A Q))) (Fmult (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Fdiv (DSeg O B) (DSeg A B))) (Py A B A)))) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
idtac.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).
idtac.

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Py P B Q)) (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py P A Q))) (Fmult (Fmult (Fdiv (DSeg A O) (DSeg A B)) (Fdiv (DSeg O B) (DSeg A B))) (Py A B A)))) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
replace (A ** O / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_1);auto).
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).
idtac.
replace (A ** O / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_1);auto).

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py P B Q)) (Fmult (Fdiv (DSeg O B) (DSeg A B)) (Py P A Q))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv (DSeg O B) (DSeg A B))) (Py A B A)))) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
replace (O ** B / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_2);auto).
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).
idtac.
replace (A ** O / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_1);auto).
replace (O ** B / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_2);auto).

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py P A Q))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1))) (Py A B A)))) (Fminus (Fplus (Py P A Q) (Py P B Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))
+++++
field.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).
idtac.
replace (A ** O / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_1);auto).
replace (O ** B / A ** B) with (1/2) by (symmetry;apply (midpoint_ratio_2);auto).
field.

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
not (eq A B)
+++++
unfold mid_point in *.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).
unfold mid_point in *.

*****
H0 : not (eq A B)
H : and (Col A B O) (eq (DSeg A O) (DSeg O B))
O,A,B,P,Q : Point
*****
not (eq A B)
+++++
intuition.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).

*****
H0 : not (eq A B)
H : mid_point O A B
O,A,B,P,Q : Point
*****
Col O A B
+++++
unfold mid_point in *.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.
rewrite ( l3_5_py P Q A B O).
unfold mid_point in *.

*****
H0 : not (eq A B)
H : and (Col A B O) (eq (DSeg A O) (DSeg O B))
O,A,B,P,Q : Point
*****
Col O A B
+++++
intuition.
-----
Lemma l_28_b_midpoint : forall O A B P Q, mid_point O A B -> 2 * Py P O Q = Py P A Q + Py P B Q - 1/ 2 * Py A B A.
Proof.
intros.
cases_equality A B.

*****

*****

+++++
Qed.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D ->\nPy A P Q + Py C P Q = Py B P Q + Py D P Q.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.

*****

*****
forall (A B C D P Q : Point) (_ : weak_3_parallelogram A B C D), eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
Proof.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.

*****

*****
forall (A B C D P Q : Point) (_ : weak_3_parallelogram A B C D), eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
intros.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
unfold weak_3_parallelogram in H.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.

*****
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
elim H.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.

*****
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D,P,Q : Point
*****
forall (x : Point) (_ : and (mid_point x A C) (mid_point x B D)), eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
intros O HO.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.

*****
HO : and (mid_point O A C) (mid_point O B D)
O : Point
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
clear H.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.

*****
HO : and (mid_point O A C) (mid_point O B D)
A,B,C,D,P,Q,O : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
use HO.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.

*****
H0 : mid_point O B D
H : mid_point O A C
A,B,C,D,P,Q,O : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
assert (T:= l_28_midpoint O A C P Q H).
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_midpoint O A C P Q H).

*****
T : eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py C P Q))
H0 : mid_point O B D
H : mid_point O A C
A,B,C,D,P,Q,O : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
assert (U:= l_28_midpoint O B D P Q H0).
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_midpoint O A C P Q H).
assert (U:= l_28_midpoint O B D P Q H0).

*****
U : eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py B P Q) (Py D P Q))
T : eq (Fmult (Fplus F1 F1) (Py O P Q)) (Fplus (Py A P Q) (Py C P Q))
H0 : mid_point O B D
H : mid_point O A C
A,B,C,D,P,Q,O : Point
*****
eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
+++++
congruence.
-----
Lemma l_27_a : forall A B C D P Q, weak_3_parallelogram A B C D -> Py A P Q + Py C P Q = Py B P Q + Py D P Q.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_midpoint O A C P Q H).
assert (U:= l_28_midpoint O B D P Q H0).
congruence.

*****

*****

+++++
Qed.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D ->\nPy4 A P B Q = Py4 D P C Q.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.

*****

*****
forall (A B C D P Q : Point) (_ : weak_3_parallelogram A B C D), eq (Py4 A P B Q) (Py4 D P C Q)
+++++
Proof.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.

*****

*****
forall (A B C D P Q : Point) (_ : weak_3_parallelogram A B C D), eq (Py4 A P B Q) (Py4 D P C Q)
+++++
intros.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Py4 A P B Q) (Py4 D P C Q)
+++++
unfold Py4.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.
intros.
unfold Py4.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fminus (Py A P Q) (Py B P Q)) (Fminus (Py D P Q) (Py C P Q))
+++++
apply (l_27_a A B C D P Q) in H.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.
intros.
unfold Py4.
apply (l_27_a A B C D P Q) in H.

*****
H : eq (Fplus (Py A P Q) (Py C P Q)) (Fplus (Py B P Q) (Py D P Q))
A,B,C,D,P,Q : Point
*****
eq (Fminus (Py A P Q) (Py B P Q)) (Fminus (Py D P Q) (Py C P Q))
+++++
IsoleVar (Py A P Q) H.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.
intros.
unfold Py4.
apply (l_27_a A B C D P Q) in H.
IsoleVar (Py A P Q) H.

*****
H : eq (Py A P Q) (Fminus (Fplus (Py B P Q) (Py D P Q)) (Py C P Q))
A,B,C,D,P,Q : Point
*****
eq (Fminus (Py A P Q) (Py B P Q)) (Fminus (Py D P Q) (Py C P Q))
+++++
rewrite H.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.
intros.
unfold Py4.
apply (l_27_a A B C D P Q) in H.
IsoleVar (Py A P Q) H.
rewrite H.

*****
H : eq (Py A P Q) (Fminus (Fplus (Py B P Q) (Py D P Q)) (Py C P Q))
A,B,C,D,P,Q : Point
*****
eq (Fminus (Fminus (Fplus (Py B P Q) (Py D P Q)) (Py C P Q)) (Py B P Q)) (Fminus (Py D P Q) (Py C P Q))
+++++
ring.
-----
Lemma l_27_b : forall A B C D P Q, weak_3_parallelogram A B C D -> Py4 A P B Q = Py4 D P C Q.
Proof.
intros.
unfold Py4.
apply (l_27_a A B C D P Q) in H.
IsoleVar (Py A P Q) H.
rewrite H.
ring.

*****

*****

+++++
Qed.
-----
Lemma midpoint_is_midpoint: forall I A B, \n mid_point I A B -> A<>B -> is_midpoint I A B.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.

*****

*****
forall (I A B : Point) (_ : mid_point I A B) (_ : not (eq A B)), is_midpoint I A B
+++++
Proof.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.

*****

*****
forall (I A B : Point) (_ : mid_point I A B) (_ : not (eq A B)), is_midpoint I A B
+++++
intros.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.

*****
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
is_midpoint I A B
+++++
assert (A ** I / A ** B = 1 / 2).
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).

*****
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
+++++
apply (midpoint_ratio_1 I A B).
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
apply (midpoint_ratio_1 I A B).

*****
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
mid_point I A B
+++++
auto.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
apply (midpoint_ratio_1 I A B).

*****
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
not (eq A B)
+++++
auto.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).

*****
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
is_midpoint I A B
+++++
idtac.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.

*****
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
is_midpoint I A B
+++++
unfold is_midpoint.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.

*****
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
on_line_d I A B (Fdiv F1 (Fplus F1 F1))
+++++
unfold on_line_d.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.

*****
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
and (Col I A B) (and (not (eq A B)) (eq (DSeg A I) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))))
+++++
unfold mid_point in *.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.

*****
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
H : and (Col A B I) (eq (DSeg A I) (DSeg I B))
I,A,B : Point
*****
and (Col I A B) (and (not (eq A B)) (eq (DSeg A I) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))))
+++++
use H.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.

*****
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
I,A,B : Point
*****
and (Col I A B) (and (not (eq A B)) (eq (DSeg A I) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))))
+++++
repeat split.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.

*****
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
I,A,B : Point
*****
Col I A B
+++++
auto with Geom.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.

*****
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
I,A,B : Point
*****
not (eq A B)
+++++
auto with Geom.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.

*****
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg A I) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
+++++
auto with Geom.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.
auto with Geom.

*****
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg A I) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
+++++
IsoleVar (A**I) H1.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.
auto with Geom.
IsoleVar (A**I) H1.

*****
H1 : eq (DSeg A I) (Fmult (DSeg A B) (Fdiv F1 (Fplus F1 F1)))
H : not (eq (DSeg A B) F0)
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg A I) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
+++++
rewrite H1.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.
auto with Geom.
IsoleVar (A**I) H1.
rewrite H1.

*****
H1 : eq (DSeg A I) (Fmult (DSeg A B) (Fdiv F1 (Fplus F1 F1)))
H : not (eq (DSeg A B) F0)
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
eq (Fmult (DSeg A B) (Fdiv F1 (Fplus F1 F1))) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A B))
+++++
field.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.
auto with Geom.
IsoleVar (A**I) H1.
rewrite H1.
field.

*****
H1 : eq (DSeg A I) (Fmult (DSeg A B) (Fdiv F1 (Fplus F1 F1)))
H : not (eq (DSeg A B) F0)
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).
idtac.
unfold is_midpoint.
unfold on_line_d.
unfold mid_point in *.
use H.
repeat split.
auto with Geom.
IsoleVar (A**I) H1.

*****
H3 : eq (DSeg A I) (DSeg I B)
H2 : Col A B I
H1 : eq (Fdiv (DSeg A I) (DSeg A B)) (Fdiv F1 (Fplus F1 F1))
H0 : not (eq A B)
I,A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma midpoint_is_midpoint: forall I A B, mid_point I A B -> A<>B -> is_midpoint I A B.
Proof.
intros.
assert (A ** I / A ** B = 1 / 2).

*****

*****

+++++
Qed.
-----
Lemma midpoint_on_line_d: forall I A B, \n mid_point I A B -> A<>B -> on_line_d A I B (0-1).
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).

*****

*****
forall (I A B : Point) (_ : mid_point I A B) (_ : not (eq A B)), on_line_d A I B (Fminus F0 F1)
+++++
Proof.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.

*****

*****
forall (I A B : Point) (_ : mid_point I A B) (_ : not (eq A B)), on_line_d A I B (Fminus F0 F1)
+++++
intros.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.

*****
H0 : not (eq A B)
H : mid_point I A B
I,A,B : Point
*****
on_line_d A I B (Fminus F0 F1)
+++++
unfold mid_point in *.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.

*****
H0 : not (eq A B)
H : and (Col A B I) (eq (DSeg A I) (DSeg I B))
I,A,B : Point
*****
on_line_d A I B (Fminus F0 F1)
+++++
unfold on_line_d.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.

*****
H0 : not (eq A B)
H : and (Col A B I) (eq (DSeg A I) (DSeg I B))
I,A,B : Point
*****
and (Col A I B) (and (not (eq I B)) (eq (DSeg I A) (Fmult (Fminus F0 F1) (DSeg I B))))
+++++
use H.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
and (Col A I B) (and (not (eq I B)) (eq (DSeg I A) (Fmult (Fminus F0 F1) (DSeg I B))))
+++++
repeat split.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
Col A I B
+++++
auto with Geom.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
not (eq I B)
+++++
auto with Geom.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
not (eq I B)
+++++
intro.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
intro.

*****
H : eq I B
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
False
+++++
subst.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
intro.
subst.

*****
H1 : Col A B B
H2 : eq (DSeg A B) (DSeg B B)
H0 : not (eq A B)
A,B : Point
*****
False
+++++
basic_simpl.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
intro.
subst.
basic_simpl.

*****
H1 : Col A B B
H2 : eq (DSeg A B) F0
H0 : not (eq A B)
A,B : Point
*****
False
+++++
assert (A=B).
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
intro.
subst.
basic_simpl.
assert (A=B).

*****
H1 : Col A B B
H2 : eq (DSeg A B) F0
H0 : not (eq A B)
A,B : Point
*****
eq A B
+++++
auto with Geom.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
intro.
subst.
basic_simpl.
assert (A=B).

*****
H : eq A B
H1 : Col A B B
H2 : eq (DSeg A B) F0
H0 : not (eq A B)
A,B : Point
*****
False
+++++
auto with Geom.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg I A) (Fmult (Fminus F0 F1) (DSeg I B))
+++++
auto with Geom.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg I A) (Fmult (Fminus F0 F1) (DSeg I B))
+++++
rewrite <- H2.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
rewrite <- H2.

*****
H2 : eq (DSeg A I) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg I A) (Fmult (Fminus F0 F1) (DSeg A I))
+++++
uniformize_dir_seg.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.
auto with Geom.
rewrite <- H2.
uniformize_dir_seg.

*****
H2 : eq (Fopp (DSeg I A)) (DSeg I B)
H1 : Col A B I
H0 : not (eq A B)
I,A,B : Point
*****
eq (DSeg I A) (Fmult (Fminus F0 F1) (Fopp (DSeg I A)))
+++++
ring.
-----
Lemma midpoint_on_line_d: forall I A B, mid_point I A B -> A<>B -> on_line_d A I B (0-1).
Proof.
intros.
unfold mid_point in *.
unfold on_line_d.
use H.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma symmetric_point_unicity : forall O B C D, \n mid_point O B D ->\n mid_point O D C ->\n B=C.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.

*****

*****
forall (O B C D : Point) (_ : mid_point O B D) (_ : mid_point O D C), eq B C
+++++
Proof.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.

*****

*****
forall (O B C D : Point) (_ : mid_point O B D) (_ : mid_point O D C), eq B C
+++++
intros.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.

*****
H0 : mid_point O D C
H : mid_point O B D
O,B,C,D : Point
*****
eq B C
+++++
unfold mid_point in *.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.

*****
H0 : and (Col D C O) (eq (DSeg D O) (DSeg O C))
H : and (Col B D O) (eq (DSeg B O) (DSeg O D))
O,B,C,D : Point
*****
eq B C
+++++
use H.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.

*****
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
H0 : and (Col D C O) (eq (DSeg D O) (DSeg O C))
O,B,C,D : Point
*****
eq B C
+++++
use H0.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.

*****
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
cases_equality D O.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.

*****
H0 : eq D O
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
subst.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
subst.

*****
H1 : Col B O O
H2 : eq (DSeg B O) (DSeg O O)
H : Col O C O
H3 : eq (DSeg O O) (DSeg O C)
O,B,C : Point
*****
eq B C
+++++
basic_simpl.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
subst.
basic_simpl.

*****
H1 : Col B O O
H2 : eq (DSeg B O) F0
H : Col O C O
H3 : eq F0 (DSeg O C)
O,B,C : Point
*****
eq B C
+++++
assert (O=C).
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
subst.
basic_simpl.
assert (O=C).

*****
H1 : Col B O O
H2 : eq (DSeg B O) F0
H : Col O C O
H3 : eq F0 (DSeg O C)
O,B,C : Point
*****
eq O C
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
subst.
basic_simpl.
assert (O=C).

*****
H0 : eq O C
H1 : Col B O O
H2 : eq (DSeg B O) F0
H : Col O C O
H3 : eq F0 (DSeg O C)
O,B,C : Point
*****
eq B C
+++++
subst.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
subst.
basic_simpl.
assert (O=C).
subst.

*****
H3 : eq F0 (DSeg C C)
H : Col C C C
H2 : eq (DSeg B C) F0
H1 : Col B C C
B,C : Point
*****
eq B C
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.

*****
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
assert (Col O B C).
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).

*****
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
Col O B C
+++++
apply (col_trans_1 O D B C).
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
apply (col_trans_1 O D B C).

*****
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
not (eq O D)
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
apply (col_trans_1 O D B C).

*****
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
Col O D B
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
apply (col_trans_1 O D B C).

*****
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
Col O D C
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).

*****
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
idtac.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.

*****
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
assert (O**B=O**C).
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).

*****
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (DSeg O C)
+++++
uniformize_dir_seg.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
uniformize_dir_seg.

*****
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (Fopp (DSeg O D)) (DSeg O C)
H : Col D C O
H2 : eq (Fopp (DSeg O B)) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (DSeg O C)
+++++
rewrite <- H3.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
uniformize_dir_seg.
rewrite <- H3.

*****
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (Fopp (DSeg O D)) (DSeg O C)
H : Col D C O
H2 : eq (Fopp (DSeg O B)) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (Fopp (DSeg O D))
+++++
rewrite <- H2.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
uniformize_dir_seg.
rewrite <- H3.
rewrite <- H2.

*****
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (Fopp (DSeg O D)) (DSeg O C)
H : Col D C O
H2 : eq (Fopp (DSeg O B)) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (Fopp (Fopp (DSeg O B)))
+++++
ring.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).

*****
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
cases_equality O B.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.

*****
H6 : eq O B
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
subst.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
subst.

*****
H1 : Col B D B
H2 : eq (DSeg B B) (DSeg B D)
H : Col D C B
H3 : eq (DSeg D B) (DSeg B C)
H0 : not (eq D B)
H4 : Col B B C
H5 : eq (DSeg B B) (DSeg B C)
B,C,D : Point
*****
eq B C
+++++
basic_simpl.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
subst.
basic_simpl.

*****
H1 : Col B D B
H2 : eq F0 (DSeg B D)
H : Col D C B
H3 : eq (DSeg D B) (DSeg B C)
H0 : not (eq D B)
H4 : Col B B C
H5 : eq F0 (DSeg B C)
B,C,D : Point
*****
eq B C
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq B C
+++++
symmetry.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq C B
+++++
apply (A2b O B C B 1).
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
not (eq O B)
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
Col O B C
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O C) (Fmult F1 (DSeg O B))
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).
auto with Geom.

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O C) (Fmult F1 (DSeg O B))
+++++
basic_simpl.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).
auto with Geom.
basic_simpl.

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O C) (DSeg O B)
+++++
auto.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
Col O B B
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (Fmult F1 (DSeg O B))
+++++
auto with Geom.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).
auto with Geom.

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (Fmult F1 (DSeg O B))
+++++
basic_simpl.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.
assert (Col O B C).
idtac.
assert (O**B=O**C).
cases_equality O B.
symmetry.
apply (A2b O B C B 1).
auto with Geom.
basic_simpl.

*****
H6 : not (eq O B)
H5 : eq (DSeg O B) (DSeg O C)
H4 : Col O B C
H0 : not (eq D O)
H3 : eq (DSeg D O) (DSeg O C)
H : Col D C O
H2 : eq (DSeg B O) (DSeg O D)
H1 : Col B D O
O,B,C,D : Point
*****
eq (DSeg O B) (DSeg O B)
+++++
auto.
-----
Lemma symmetric_point_unicity : forall O B C D, mid_point O B D -> mid_point O D C -> B=C.
Proof.
intros.
unfold mid_point in *.
use H.
use H0.
cases_equality D O.

*****

*****

+++++
Qed.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D,\n   weak_3_parallelogram A B C D -> parallel B C A D.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), parallel B C A D
+++++
Proof.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), parallel B C A D
+++++
intros.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
parallel B C A D
+++++
unfold weak_3_parallelogram in H.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.

*****
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
parallel B C A D
+++++
elim H.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.

*****
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
forall (x : Point) (_ : and (mid_point x A C) (mid_point x B D)), parallel B C A D
+++++
intros O HO.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.

*****
HO : and (mid_point O A C) (mid_point O B D)
O : Point
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
parallel B C A D
+++++
use HO.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.

*****
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
parallel B C A D
+++++
clear H.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.

*****
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
cases_equality A D.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.

*****
H : eq A D
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
subst.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
subst.

*****
H1 : mid_point O B D
H0 : mid_point O D C
B,C,D,O : Point
*****
parallel B C D D
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.

*****
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
cases_equality B C.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.

*****
H2 : eq B C
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
subst.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
subst.

*****
H : not (eq A D)
H1 : mid_point O C D
H0 : mid_point O A C
A,C,D,O : Point
*****
parallel C C A D
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.

*****
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
cases_equality A C.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.

*****
H3 : eq A C
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
subst.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
subst.

*****
H2 : not (eq B C)
H : not (eq C D)
H1 : mid_point O B D
H0 : mid_point O C C
B,C,D,O : Point
*****
parallel B C C D
+++++
assert (O=C).
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
subst.
assert (O=C).

*****
H2 : not (eq B C)
H : not (eq C D)
H1 : mid_point O B D
H0 : mid_point O C C
B,C,D,O : Point
*****
eq O C
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
subst.
assert (O=C).

*****
H3 : eq O C
H2 : not (eq B C)
H : not (eq C D)
H1 : mid_point O B D
H0 : mid_point O C C
B,C,D,O : Point
*****
parallel B C C D
+++++
subst.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
subst.
assert (O=C).
subst.

*****
H2 : not (eq B C)
H : not (eq C D)
H0 : mid_point C C C
H1 : mid_point C B D
B,C,D : Point
*****
parallel B C C D
+++++
unfold mid_point in *.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
subst.
assert (O=C).
subst.
unfold mid_point in *.

*****
H2 : not (eq B C)
H : not (eq C D)
H0 : and (Col C C C) (eq (DSeg C C) (DSeg C C))
H1 : and (Col B D C) (eq (DSeg B C) (DSeg C D))
B,C,D : Point
*****
parallel B C C D
+++++
use H1.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
subst.
assert (O=C).
subst.
unfold mid_point in *.
use H1.

*****
H4 : eq (DSeg B C) (DSeg C D)
H3 : Col B D C
H2 : not (eq B C)
H : not (eq C D)
H0 : and (Col C C C) (eq (DSeg C C) (DSeg C C))
B,C,D : Point
*****
parallel B C C D
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.

*****
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
cases_equality B D.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.

*****
H4 : eq B D
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
subst.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
subst.

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H1 : mid_point O D D
H0 : mid_point O A C
A,C,D,O : Point
*****
parallel D C A D
+++++
assert (O=D).
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
subst.
assert (O=D).

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H1 : mid_point O D D
H0 : mid_point O A C
A,C,D,O : Point
*****
eq O D
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
subst.
assert (O=D).

*****
H4 : eq O D
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H1 : mid_point O D D
H0 : mid_point O A C
A,C,D,O : Point
*****
parallel D C A D
+++++
subst.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
subst.
assert (O=D).
subst.

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H0 : mid_point D A C
H1 : mid_point D D D
A,C,D : Point
*****
parallel D C A D
+++++
unfold mid_point in *.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
subst.
assert (O=D).
subst.
unfold mid_point in *.

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H0 : and (Col A C D) (eq (DSeg A D) (DSeg D C))
H1 : and (Col D D D) (eq (DSeg D D) (DSeg D D))
A,C,D : Point
*****
parallel D C A D
+++++
use H0.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
subst.
assert (O=D).
subst.
unfold mid_point in *.
use H0.

*****
H5 : eq (DSeg A D) (DSeg D C)
H4 : Col A C D
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H1 : and (Col D D D) (eq (DSeg D D) (DSeg D D))
A,C,D : Point
*****
parallel D C A D
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
apply (midpoint_is_midpoint) in H0.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : is_midpoint O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
apply (midpoint_on_line_d) in H1.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
A,B,C,D,O : Point
*****
parallel B C A D
+++++
unfold is_midpoint in *.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
parallel B C A D
+++++
unfold parallel.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (S4 B A C D) F0
+++++
unfold S4.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (S B A C) (S B C D)) F0
+++++
replace (S B A C) with (S A C B) by auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (S A C B) (S B C D)) F0
+++++
rewrite (elim_area_on_line_d A C O D B (0-1)).
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fmult (Fminus F0 F1) (S A C D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S A C O))) (S B C D)) F0
+++++
replace (S B C D) with (S C D B) by auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fmult (Fminus F0 F1) (S A C D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S A C O))) (S C D B)) F0
+++++
rewrite (elim_area_on_line_d C D O D B (0-1)).
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fmult (Fminus F0 F1) (S A C D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S A C O))) (Fplus (Fmult (Fminus F0 F1) (S C D D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S C D O)))) F0
+++++
clear H1.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fmult (Fminus F0 F1) (S A C D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S A C O))) (Fplus (Fmult (Fminus F0 F1) (S C D D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S C D O)))) F0
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fmult (Fminus F0 F1) (S A C D)) (Fmult (Fminus F1 (Fminus F0 F1)) (S A C O))) (Fmult (Fminus F1 (Fminus F0 F1)) (S C D O))) F0
+++++
ring_simplify_eq.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (S A C O))) (Fmult (Fplus F1 F1) (S C D O))) F0
+++++
unfold is_midpoint in *.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (S A C O))) (Fmult (Fplus F1 F1) (S C D O))) F0
+++++
rewrite (elim_area_on_line_d A C A C O (1/2)).
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (S A C C)) (Fmult (Fminus F1 (Fdiv F1 (Fplus F1 F1))) (S A C A))))) (Fmult (Fplus F1 F1) (S C D O))) F0
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).
basic_simpl.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (S C D O))) F0
+++++
rewrite (elim_area_on_line_d C D A C O (1/2)).
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).
basic_simpl.
rewrite (elim_area_on_line_d C D A C O (1/2)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (S C D C)) (Fmult (Fminus F1 (Fdiv F1 (Fplus F1 F1))) (S C D A))))) F0
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).
basic_simpl.
rewrite (elim_area_on_line_d C D A C O (1/2)).
basic_simpl.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (Fmult (Fdiv F1 (Fplus F1 F1)) (S C D A)))) F0
+++++
uniformize_signed_areas.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).
basic_simpl.
rewrite (elim_area_on_line_d C D A C O (1/2)).
basic_simpl.
uniformize_signed_areas.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
eq (Fplus (Fopp (S A C D)) (Fmult (Fplus F1 F1) (Fmult (Fdiv F1 (Fplus F1 F1)) (S A C D)))) F0
+++++
field.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).
basic_simpl.
rewrite (elim_area_on_line_d C D A C O (1/2)).
basic_simpl.
uniformize_signed_areas.
field.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).
basic_simpl.
rewrite (elim_area_on_line_d C D A C O (1/2)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
on_line_d O A C (Fdiv F1 (Fplus F1 F1))
+++++
auto.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).
clear H1.
basic_simpl.
ring_simplify_eq.
unfold is_midpoint in *.
rewrite (elim_area_on_line_d A C A C O (1/2)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
on_line_d O A C (Fdiv F1 (Fplus F1 F1))
+++++
auto.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).
replace (S B C D) with (S C D B) by auto with Geom.
rewrite (elim_area_on_line_d C D O D B (0-1)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
on_line_d B O D (Fminus F0 F1)
+++++
auto.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.
unfold is_midpoint in *.
unfold parallel.
unfold S4.
replace (S B A C) with (S A C B) by auto with Geom.
rewrite (elim_area_on_line_d A C O D B (0-1)).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
A,B,C,D,O : Point
*****
on_line_d B O D (Fminus F0 F1)
+++++
auto.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.
apply (midpoint_on_line_d) in H1.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : is_midpoint O A C
A,B,C,D,O : Point
*****
not (eq B D)
+++++
auto.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.
cases_equality B C.
cases_equality A C.
cases_equality B D.
apply (midpoint_is_midpoint) in H0.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
H1 : mid_point O B D
H0 : mid_point O A C
A,B,C,D,O : Point
*****
not (eq A C)
+++++
auto.
-----
Lemma weak_3_parallelogram_parallel : forall A B C D, weak_3_parallelogram A B C D -> parallel B C A D.
Proof.
intros.
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
use HO.
clear H.
cases_equality A D.

*****

*****

+++++
Qed.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.

*****

*****
forall (x : F) (_ : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)), eq x F0
+++++
Proof.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.

*****

*****
forall (x : F) (_ : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)), eq x F0
+++++
intros.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.

*****
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq x F0
+++++
assert (x-1/2 * x=0).
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).

*****
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq (Fminus x (Fmult (Fdiv F1 (Fplus F1 F1)) x)) F0
+++++
rewrite H at 1.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
rewrite H at 1.

*****
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq (Fminus (Fmult (Fdiv F1 (Fplus F1 F1)) x) (Fmult (Fdiv F1 (Fplus F1 F1)) x)) F0
+++++
field.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
rewrite H at 1.
field.

*****
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).

*****
H0 : eq (Fminus x (Fmult (Fdiv F1 (Fplus F1 F1)) x)) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq x F0
+++++
replace (x-1/2*x) with (1/2*x) in H0.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.

*****
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq x F0
+++++
IsoleVar x H0.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.

*****
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq x F0
+++++
replace ( 0 / (1 / 2)) with 0 in H0.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.

*****
H0 : eq x F0
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq x F0
+++++
auto.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.

*****
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq F0 (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
+++++
field.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.
field.

*****
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
and (not (eq (Fplus F1 F1) F0)) (not (eq F1 F0))
+++++
split.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.
field.
split.

*****
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.
field.
split.

*****
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq F1 F0)
+++++
auto with Geom.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.
field.
split.
auto with Geom.

*****
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq F1 F0)
+++++
intro.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
replace ( 0 / (1 / 2)) with 0 in H0.
field.
split.
auto with Geom.
intro.

*****
H2 : eq F1 F0
H0 : eq x (Fdiv F0 (Fdiv F1 (Fplus F1 F1)))
H1 : not (eq (Fdiv F1 (Fplus F1 F1)) F0)
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
False
+++++
intuition.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.

*****
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq (Fdiv F1 (Fplus F1 F1)) F0)
+++++
intro.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.

*****
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
False
+++++
assert (1/2*2=0*2).
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).

*****
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq (Fmult (Fdiv F1 (Fplus F1 F1)) (Fplus F1 F1)) (Fmult F0 (Fplus F1 F1))
+++++
rewrite H1.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).
rewrite H1.

*****
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq (Fmult F0 (Fplus F1 F1)) (Fmult F0 (Fplus F1 F1))
+++++
auto.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).

*****
H2 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) (Fplus F1 F1))\n (Fmult F0 (Fplus F1 F1))
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
False
+++++
ring_simplify in H2.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).
ring_simplify in H2.

*****
H2 : eq (Fmult (Fplus F1 F1) (Fdiv F1 (Fplus F1 F1))) F0
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
False
+++++
replace (2 * (1 / 2)) with 1 in H2.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).
ring_simplify in H2.
replace (2 * (1 / 2)) with 1 in H2.

*****
H2 : eq F1 F0
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
False
+++++
intuition.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).
ring_simplify in H2.
replace (2 * (1 / 2)) with 1 in H2.

*****
H2 : eq (Fmult (Fplus F1 F1) (Fdiv F1 (Fplus F1 F1))) F0
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq F1 (Fmult (Fplus F1 F1) (Fdiv F1 (Fplus F1 F1)))
+++++
field.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
IsoleVar x H0.
intro.
assert (1/2*2=0*2).
ring_simplify in H2.
replace (2 * (1 / 2)) with 1 in H2.
field.

*****
H2 : eq (Fmult (Fplus F1 F1) (Fdiv F1 (Fplus F1 F1))) F0
H1 : eq (Fdiv F1 (Fplus F1 F1)) F0
H0 : eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.

*****
H0 : eq (Fminus x (Fmult (Fdiv F1 (Fplus F1 F1)) x)) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
eq (Fmult (Fdiv F1 (Fplus F1 F1)) x) (Fminus x (Fmult (Fdiv F1 (Fplus F1 F1)) x))
+++++
field.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).
replace (x-1/2*x) with (1/2*x) in H0.
field.

*****
H0 : eq (Fminus x (Fmult (Fdiv F1 (Fplus F1 F1)) x)) F0
H : eq x (Fmult (Fdiv F1 (Fplus F1 F1)) x)
x : F
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma eq_half_eq_zero : forall x : F, x = 1/2 * x -> x=0.
Proof.
intros.
assert (x-1/2 * x=0).

*****

*****

+++++
Qed.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D,\n   weak_3_parallelogram A B C D -> B**C= A**D.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), eq (DSeg B C) (DSeg A D)
+++++
Proof.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), eq (DSeg B C) (DSeg A D)
+++++
intros.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
assert (T:=H).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).

*****
H,T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
unfold weak_3_parallelogram in H.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.

*****
T : weak_3_parallelogram A B C D
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
elim H;intros O HO;use HO;clear H.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.

*****
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
assert (W0:=H0).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).

*****
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
assert (W1:=H1).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).

*****
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
cases_equality A D.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.

*****
H : eq A D
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.

*****
W1 : mid_point O B D
W0 : mid_point O D C
H1 : mid_point O B D
H0 : mid_point O D C
O : Point
T : weak_3_parallelogram D B C D
B,C,D : Point
*****
eq (DSeg B C) (DSeg D D)
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.

*****
W1 : mid_point O B D
W0 : mid_point O D C
H1 : mid_point O B D
H0 : mid_point O D C
O : Point
T : weak_3_parallelogram D B C D
B,C,D : Point
*****
eq (DSeg B C) F0
+++++
assert (B=C).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).

*****
W1 : mid_point O B D
W0 : mid_point O D C
H1 : mid_point O B D
H0 : mid_point O D C
O : Point
T : weak_3_parallelogram D B C D
B,C,D : Point
*****
eq B C
+++++
eauto using symmetric_point_unicity.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.

*****
H : eq B C
W1 : mid_point O B D
W0 : mid_point O D C
H1 : mid_point O B D
H0 : mid_point O D C
O : Point
T : weak_3_parallelogram D B C D
B,C,D : Point
*****
eq (DSeg B C) F0
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.

*****
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
cases_equality B C.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.

*****
H2 : eq B C
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.

*****
H : not (eq A D)
W1 : mid_point O C D
W0 : mid_point O A C
H1 : mid_point O C D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A C C D
A,C,D : Point
*****
eq (DSeg C C) (DSeg A D)
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.

*****
H : not (eq A D)
W1 : mid_point O C D
W0 : mid_point O A C
H1 : mid_point O C D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A C C D
A,C,D : Point
*****
eq F0 (DSeg A D)
+++++
assert (A=D).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).

*****
H : not (eq A D)
W1 : mid_point O C D
W0 : mid_point O A C
H1 : mid_point O C D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A C C D
A,C,D : Point
*****
eq A D
+++++
eauto using symmetric_point_unicity.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.

*****
H2 : eq A D
H : not (eq A D)
W1 : mid_point O C D
W0 : mid_point O A C
H1 : mid_point O C D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A C C D
A,C,D : Point
*****
eq F0 (DSeg A D)
+++++
symmetry;auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.

*****
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
cases_equality A C.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.

*****
H3 : eq A C
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.

*****
H2 : not (eq B C)
H : not (eq C D)
W1 : mid_point O B D
W0 : mid_point O C C
H1 : mid_point O B D
H0 : mid_point O C C
O : Point
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq (DSeg B C) (DSeg C D)
+++++
assert (O=C).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).

*****
H2 : not (eq B C)
H : not (eq C D)
W1 : mid_point O B D
W0 : mid_point O C C
H1 : mid_point O B D
H0 : mid_point O C C
O : Point
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq O C
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.

*****
H3 : eq O C
H2 : not (eq B C)
H : not (eq C D)
W1 : mid_point O B D
W0 : mid_point O C C
H1 : mid_point O B D
H0 : mid_point O C C
O : Point
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq (DSeg B C) (DSeg C D)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.

*****
H2 : not (eq B C)
H : not (eq C D)
H0 : mid_point C C C
H1 : mid_point C B D
W0 : mid_point C C C
W1 : mid_point C B D
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq (DSeg B C) (DSeg C D)
+++++
unfold mid_point in *.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.

*****
H2 : not (eq B C)
H : not (eq C D)
H0 : and (Col C C C) (eq (DSeg C C) (DSeg C C))
H1 : and (Col B D C) (eq (DSeg B C) (DSeg C D))
W0 : and (Col C C C) (eq (DSeg C C) (DSeg C C))
W1 : and (Col B D C) (eq (DSeg B C) (DSeg C D))
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq (DSeg B C) (DSeg C D)
+++++
use H1.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.

*****
H4 : eq (DSeg B C) (DSeg C D)
H3 : Col B D C
H2 : not (eq B C)
H : not (eq C D)
W0,H0 : and (Col C C C) (eq (DSeg C C) (DSeg C C))
W1 : and (Col B D C) (eq (DSeg B C) (DSeg C D))
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq (DSeg B C) (DSeg C D)
+++++
auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.

*****
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
cases_equality B D.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.

*****
H4 : eq B D
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
W1 : mid_point O D D
W0 : mid_point O A C
H1 : mid_point O D D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (DSeg D C) (DSeg A D)
+++++
assert (O=D).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
W1 : mid_point O D D
W0 : mid_point O A C
H1 : mid_point O D D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq O D
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.

*****
H4 : eq O D
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
W1 : mid_point O D D
W0 : mid_point O A C
H1 : mid_point O D D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (DSeg D C) (DSeg A D)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H0 : mid_point D A C
H1 : mid_point D D D
W0 : mid_point D A C
W1 : mid_point D D D
T : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (DSeg D C) (DSeg A D)
+++++
unfold mid_point in *.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.

*****
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H0 : and (Col A C D) (eq (DSeg A D) (DSeg D C))
H1 : and (Col D D D) (eq (DSeg D D) (DSeg D D))
W0 : and (Col A C D) (eq (DSeg A D) (DSeg D C))
W1 : and (Col D D D) (eq (DSeg D D) (DSeg D D))
T : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (DSeg D C) (DSeg A D)
+++++
use H0.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.

*****
H5 : eq (DSeg A D) (DSeg D C)
H4 : Col A C D
H3 : not (eq A C)
H2 : not (eq D C)
H : not (eq A D)
H1 : and (Col D D D) (eq (DSeg D D) (DSeg D D))
W0 : and (Col A C D) (eq (DSeg A D) (DSeg D C))
W1 : and (Col D D D) (eq (DSeg D D) (DSeg D D))
T : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (DSeg D C) (DSeg A D)
+++++
auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
apply (midpoint_is_midpoint) in H0.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
2:auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : mid_point O B D
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
apply (midpoint_on_line_d) in H1.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
2:auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
assert (parallel B C A D).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).

*****
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
parallel B C A D
+++++
apply (weak_3_parallelogram_parallel);auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.

*****
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
cut (B**C/A**D= 1).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).

*****
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
forall _ : eq (Fdiv (DSeg B C) (DSeg A D)) F1, eq (DSeg B C) (DSeg A D)
+++++
intros.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.

*****
H6 : eq (Fdiv (DSeg B C) (DSeg A D)) F1
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
IsoleVar (B**C) H6.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.

*****
H6 : eq (DSeg B C) (Fmult (DSeg A D) F1)
H7 : not (eq (DSeg A D) F0)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
rewrite H6.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.

*****
H6 : eq (DSeg B C) (Fmult (DSeg A D) F1)
H7 : not (eq (DSeg A D) F0)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fmult (DSeg A D) F1) (DSeg A D)
+++++
ring.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.

*****
H6 : eq (Fdiv (DSeg B C) (DSeg A D)) F1
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
not (eq (DSeg A D) F0)
+++++
auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.

*****
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : is_midpoint O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg B C) (DSeg A D)) F1
+++++
unfold is_midpoint in *.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.

*****
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg B C) (DSeg A D)) F1
+++++
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.

*****
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg C B) (DSeg D A)) F1
+++++
cases_col C O D.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg C B) (DSeg D A)) F1
+++++
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fplus (Fdiv (DSeg C O) (DSeg O D)) (Fminus F0 F1)) (Fdiv (DSeg D A) (DSeg O D))) F1
+++++
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (Fminus F0 F1) (Fdiv (DSeg D A) (DSeg O D)))) F1
+++++
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (Fminus F0 F1) (Fdiv (DSeg D A) (DSeg O D)))) F1
+++++
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (DSeg D O) (DSeg D A))) F1
+++++
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (DSeg D O) (DSeg D A))) F1
+++++
2:assert (D<>O) by auto with Geom;auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (DSeg D O) (DSeg D A))) F1
+++++
unfold on_line_d in *.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.

*****
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
H0 : and (Col O A C)\n (and (not (eq A C))\n (eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (DSeg D O) (DSeg D A))) F1
+++++
use H0.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.

*****
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (DSeg D O) (DSeg D A))) F1
+++++
use H1.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.

*****
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fdiv (Fdiv (DSeg C O) (DSeg O D)) (Fdiv (DSeg D A) (DSeg O D))) (Fdiv (DSeg D O) (DSeg D A))) F1
+++++
field_simplify_eq.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.

*****
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (DSeg D O)) (DSeg D A)
+++++
2:auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.

*****
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (DSeg D O)) (DSeg D A)
+++++
cases_equality O C.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.

*****
H1 : eq O C
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (DSeg D O)) (DSeg D A)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.

*****
H10 : eq (DSeg A C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H0 : Col B C D
H11 : not (eq C D)
H12 : eq (DSeg C B) (Fmult (Fminus F0 F1) (DSeg C D))
H9 : not (eq A C)
H6 : Col C C D
H7 : Col C A C
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W0 : mid_point C A C
W1 : mid_point C B D
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C C) (DSeg D C)) (DSeg D A)
+++++
assert (A**C=0).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).

*****
H10 : eq (DSeg A C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H0 : Col B C D
H11 : not (eq C D)
H12 : eq (DSeg C B) (Fmult (Fminus F0 F1) (DSeg C D))
H9 : not (eq A C)
H6 : Col C C D
H7 : Col C A C
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W0 : mid_point C A C
W1 : mid_point C B D
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg A C) F0
+++++
apply eq_half_eq_zero.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.

*****
H10 : eq (DSeg A C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H0 : Col B C D
H11 : not (eq C D)
H12 : eq (DSeg C B) (Fmult (Fminus F0 F1) (DSeg C D))
H9 : not (eq A C)
H6 : Col C C D
H7 : Col C A C
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W0 : mid_point C A C
W1 : mid_point C B D
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg A C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
+++++
auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.

*****
H1 : eq (DSeg A C) F0
H10 : eq (DSeg A C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H0 : Col B C D
H11 : not (eq C D)
H12 : eq (DSeg C B) (Fmult (Fminus F0 F1) (DSeg C D))
H9 : not (eq A C)
H6 : Col C C D
H7 : Col C A C
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W0 : mid_point C A C
W1 : mid_point C B D
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C C) (DSeg D C)) (DSeg D A)
+++++
assert (A=C) by auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.

*****
H8 : eq A C
H1 : eq (DSeg A C) F0
H10 : eq (DSeg A C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H0 : Col B C D
H11 : not (eq C D)
H12 : eq (DSeg C B) (Fmult (Fminus F0 F1) (DSeg C D))
H9 : not (eq A C)
H6 : Col C C D
H7 : Col C A C
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W0 : mid_point C A C
W1 : mid_point C B D
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C C) (DSeg D C)) (DSeg D A)
+++++
subst.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.

*****
H10 : eq (DSeg C C) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg C C))
H1 : eq (DSeg C C) F0
H0 : Col B C D
H11 : not (eq C D)
H12 : eq (DSeg C B) (Fmult (Fminus F0 F1) (DSeg C D))
H9 : not (eq C C)
H6 : Col C C D
H5 : parallel B C C D
H7 : Col C C C
H4 : not (eq B D)
H3 : not (eq C C)
H2 : not (eq B C)
W0 : mid_point C C C
H : not (eq C D)
W1 : mid_point C B D
T : weak_3_parallelogram C B C D
B,C,D : Point
*****
eq (Fplus (DSeg C C) (DSeg D C)) (DSeg D C)
+++++
intuition.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.

*****
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (DSeg D O)) (DSeg D A)
+++++
assert (Col O D A).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).

*****
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
Col O D A
+++++
apply (col_trans_1 O C D A);auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.

*****
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (DSeg D O)) (DSeg D A)
+++++
replace (D**O) with (D**A+A**O).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).

*****
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (Fplus (DSeg D A) (DSeg A O))) (DSeg D A)
+++++
2:apply chasles;auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.

*****
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (Fplus (DSeg D A) (DSeg A O))) (DSeg D A)
+++++
cut (C**O = O**A).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).

*****
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
forall _ : eq (DSeg C O) (DSeg O A), eq (Fplus (DSeg C O) (Fplus (DSeg D A) (DSeg A O))) (DSeg D A)
+++++
intro.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.

*****
H13 : eq (DSeg C O) (DSeg O A)
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg C O) (Fplus (DSeg D A) (DSeg A O))) (DSeg D A)
+++++
rewrite H13.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.

*****
H13 : eq (DSeg C O) (DSeg O A)
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (DSeg O A) (Fplus (DSeg D A) (DSeg A O))) (DSeg D A)
+++++
uniformize_dir_seg.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.

*****
H13 : eq (DSeg C O) (Fopp (DSeg A O))
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (Fopp (DSeg B O)) (Fmult (Fminus F0 F1) (Fopp (DSeg D O)))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fopp (DSeg A O)) (Fplus (Fopp (DSeg A D)) (DSeg A O))) (Fopp (DSeg A D))
+++++
ring.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.

*****
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg C O) (DSeg O A)
+++++
unfold mid_point in W0.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.

*****
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : and (Col A C O) (eq (DSeg A O) (DSeg O C))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg C O) (DSeg O A)
+++++
use W0.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.

*****
H14 : eq (DSeg A O) (DSeg O C)
H13 : Col A C O
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg C O) (DSeg O A)
+++++
uniformize_dir_seg.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.

*****
H14 : eq (DSeg A O) (Fopp (DSeg C O))
H13 : Col A C O
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (Fopp (DSeg B O)) (Fmult (Fminus F0 F1) (Fopp (DSeg D O)))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg C O) (Fopp (DSeg A O))
+++++
rewrite H14.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.

*****
H14 : eq (DSeg A O) (Fopp (DSeg C O))
H13 : Col A C O
H8 : Col O D A
H1 : not (eq O C)
H12 : eq (Fopp (DSeg B O)) (Fmult (Fminus F0 F1) (Fopp (DSeg D O)))
H11 : not (eq O D)
H0 : Col B O D
H10 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H9 : not (eq A C)
H7 : Col O A C
H6 : Col C O D
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg C O) (Fopp (Fopp (DSeg C O)))
+++++
ring.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg C B) (DSeg D A)) F1
+++++
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (S C O D) (S4 D O A D)) F1
+++++
unfold S4.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (S C O D) (Fplus (S D O A) (S D A D))) F1
+++++
replace (S C O D) with (S D C O) by auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (S D C O) (Fplus (S D O A) (S D A D))) F1
+++++
replace (S D O A) with (S A D O) by auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (S D C O) (Fplus (S A D O) (S D A D))) F1
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (S D C O) (S A D O)) F1
+++++
rewrite (elim_area_on_line_d D C A C O (1/2)).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C C)) (Fmult (Fminus F1 (Fdiv F1 (Fplus F1 F1))) (S D C A))) (S A D O)) F1
+++++
2:auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C C)) (Fmult (Fminus F1 (Fdiv F1 (Fplus F1 F1))) (S D C A))) (S A D O)) F1
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C A)) (S A D O)) F1
+++++
rewrite (elim_area_on_line_d A D A C O (1/2)).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C A)) (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (S A D C)) (Fmult (Fminus F1 (Fdiv F1 (Fplus F1 F1))) (S A D A)))) F1
+++++
2:auto.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C A)) (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (S A D C)) (Fmult (Fminus F1 (Fdiv F1 (Fplus F1 F1))) (S A D A)))) F1
+++++
basic_simpl.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C A)) (Fmult (Fdiv F1 (Fplus F1 F1)) (S A D C))) F1
+++++
uniformize_signed_areas.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C A)) (Fmult (Fdiv F1 (Fplus F1 F1)) (S D C A))) F1
+++++
field.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
and (not (eq (Fplus F1 F1) F0)) (not (eq (S D C A) F0))
+++++
split;auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.

*****
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
not (eq (S D C A) F0)
+++++
intro.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.

*****
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
False
+++++
assert (Col C A D) by auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.

*****
H8 : Col C A D
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : on_line_d B O D (Fminus F0 F1)
H0 : on_line_d O A C (Fdiv F1 (Fplus F1 F1))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
False
+++++
unfold on_line_d in *.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.
unfold on_line_d in *.

*****
H8 : Col C A D
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
H0 : and (Col O A C)\n (and (not (eq A C))\n (eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
False
+++++
use H0.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.
unfold on_line_d in *.
use H0.

*****
H12 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H11 : not (eq A C)
H9 : Col O A C
H8 : Col C A D
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
False
+++++
assert (Col C A O) by auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.
unfold on_line_d in *.
use H0.
assert (Col C A O) by auto with Geom.

*****
H0 : Col C A O
H12 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H11 : not (eq A C)
H9 : Col O A C
H8 : Col C A D
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
False
+++++
assert (Col C O D).
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.
unfold on_line_d in *.
use H0.
assert (Col C A O) by auto with Geom.
assert (Col C O D).

*****
H0 : Col C A O
H12 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H11 : not (eq A C)
H9 : Col O A C
H8 : Col C A D
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
Col C O D
+++++
apply (col_trans_1 C A O D);auto with Geom.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.
unfold on_line_d in *.
use H0.
assert (Col C A O) by auto with Geom.
assert (Col C O D).
apply (col_trans_1 C A O D);auto with Geom.

*****
H10 : Col C O D
H0 : Col C A O
H12 : eq (DSeg A O) (Fmult (Fdiv F1 (Fplus F1 F1)) (DSeg A C))
H11 : not (eq A C)
H9 : Col O A C
H8 : Col C A D
H7 : eq (S D C A) F0
H6 : not (Col C O D)
H5 : parallel B C A D
H4 : not (eq B D)
H3 : not (eq A C)
H2 : not (eq B C)
H : not (eq A D)
W1 : mid_point O B D
W0 : mid_point O A C
H1 : and (Col B O D)\n (and (not (eq O D)) (eq (DSeg O B) (Fmult (Fminus F0 F1) (DSeg O D))))
O : Point
T : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
False
+++++
intuition.
-----
Lemma weak_3_parallelogram_eq_side : forall A B C D, weak_3_parallelogram A B C D -> B**C= A**D.
Proof.
intros.
assert (T:=H).
unfold weak_3_parallelogram in H.
elim H;intros O HO;use HO;clear H.
assert (W0:=H0).
assert (W1:=H1).
cases_equality A D.
subst.
basic_simpl.
assert (B=C).
eauto using symmetric_point_unicity.
auto with Geom.
cases_equality B C.
subst.
basic_simpl.
assert (A=D).
eauto using symmetric_point_unicity.
symmetry;auto with Geom.
cases_equality A C.
subst.
assert (O=C).
auto with Geom.
subst.
unfold mid_point in *.
use H1.
auto.
cases_equality B D.
subst.
assert (O=D).
auto with Geom.
subst.
unfold mid_point in *.
use H0.
auto.
apply (midpoint_is_midpoint) in H0.
2:auto.
apply (midpoint_on_line_d) in H1.
2:auto.
assert (parallel B C A D).
apply (weak_3_parallelogram_parallel);auto.
cut (B**C/A**D= 1).
intros.
IsoleVar (B**C) H6.
rewrite H6.
ring.
auto with Geom.
unfold is_midpoint in *.
replace (B ** C / A ** D) with (C**B / D**A) by auto with Geom.
cases_col C O D.
rewrite (elim_length_ratio_on_line_d_1 C D A O D B (0-1));auto with Geom.
replace ((C ** O / O ** D + (0 - 1)) / (D ** A / O ** D) ) with ((C ** O / O ** D) / (D ** A / O ** D) + (0 - 1)/(D ** A / O ** D)).
2:field;split;unfold on_line_d in *; use H1;auto with Geom.
replace ((0 - 1) / (D ** A / O ** D)) with (D**O/D**A).
2:uniformize_dir_seg;field;split;unfold on_line_d in *; use H1;auto with Geom.
2:assert (D<>O) by auto with Geom;auto with Geom.
unfold on_line_d in *.
use H0.
use H1.
field_simplify_eq.
2:auto with Geom.
cases_equality O C.
subst.
assert (A**C=0).
apply eq_half_eq_zero.
auto.
assert (A=C) by auto with Geom.
subst.
intuition.
assert (Col O D A).
apply (col_trans_1 O C D A);auto with Geom.
replace (D**O) with (D**A+A**O).
2:apply chasles;auto with Geom.
cut (C**O = O**A).
intro.
rewrite H13.
uniformize_dir_seg.
ring.
unfold mid_point in W0.
use W0.
uniformize_dir_seg.
rewrite H14.
ring.
rewrite (elim_length_ratio_on_line_d_2 C D A O D B (0-1));auto with Geom.
unfold S4.
replace (S C O D) with (S D C O) by auto with Geom.
replace (S D O A) with (S A D O) by auto with Geom.
basic_simpl.
rewrite (elim_area_on_line_d D C A C O (1/2)).
2:auto.
basic_simpl.
rewrite (elim_area_on_line_d A D A C O (1/2)).
2:auto.
basic_simpl.
uniformize_signed_areas.
field.
split;auto with Geom.
intro.
assert (Col C A D) by auto with Geom.
unfold on_line_d in *.
use H0.
assert (Col C A O) by auto with Geom.
assert (Col C O D).
apply (col_trans_1 C A O D);auto with Geom.
intuition.

*****

*****

+++++
Qed.
-----
Lemma l3_6 : forall A B C D, \n  weak_3_parallelogram A B C D ->\n A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
Proof.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
intros.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
cases_equality B D.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.

*****
H0 : eq B D
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
subst.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.

*****
H : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg D D) (DSeg D D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)))
+++++
basic_simpl.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.

*****
H : weak_3_parallelogram A D C D
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)))
+++++
unfold weak_3_parallelogram in H.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.

*****
H : ex (fun O : Point => and (mid_point O A C) (mid_point O D D))
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)))
+++++
use H.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.

*****
H2 : mid_point x D D
H1 : mid_point x A C
A,C,D,x : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)))
+++++
unfold mid_point in H2.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.

*****
H2 : and (Col D D x) (eq (DSeg D x) (DSeg x D))
H1 : mid_point x A C
A,C,D,x : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)))
+++++
use H2.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.

*****
H0 : eq (DSeg D x) (DSeg x D)
H : Col D D x
H1 : mid_point x A C
A,C,D,x : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)))
+++++
uniformize_dir_seg.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.

*****
H0 : eq (DSeg D x) (Fopp (DSeg D x))
H : Col D D x
H1 : mid_point x A C
A,C,D,x : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
assert (D=x).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).

*****
H0 : eq (DSeg D x) (Fopp (DSeg D x))
H : Col D D x
H1 : mid_point x A C
A,C,D,x : Point
*****
eq D x
+++++
auto with Geom.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).

*****
H2 : eq D x
H0 : eq (DSeg D x) (Fopp (DSeg D x))
H : Col D D x
H1 : mid_point x A C
A,C,D,x : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
subst x.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.

*****
H1 : mid_point D A C
H : Col D D D
H0 : eq (DSeg D D) (Fopp (DSeg D D))
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
unfold mid_point in H1.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.

*****
H1 : and (Col A C D) (eq (DSeg A D) (DSeg D C))
H : Col D D D
H0 : eq (DSeg D D) (Fopp (DSeg D D))
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
use H1.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.

*****
H3 : eq (DSeg A D) (DSeg D C)
H2 : Col A C D
H : Col D D D
H0 : eq (DSeg D D) (Fopp (DSeg D D))
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A D)) (DSeg A D)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
rewrite H3.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.

*****
H3 : eq (DSeg A D) (DSeg D C)
H2 : Col A C D
H : Col D D D
H0 : eq (DSeg D D) (Fopp (DSeg D D))
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg D C)) (DSeg D C)) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
uniformize_dir_seg.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.

*****
H3 : eq (DSeg A D) (Fopp (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq (DSeg D D) (Fopp (DSeg D D))
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))) (Fmult (Fmult (Fplus F1 F1) (Fopp (DSeg C D))) (Fopp (DSeg C D))))
+++++
basic_simpl.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.
basic_simpl.

*****
H3 : eq (DSeg A D) (Fopp (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq F0 F0
A,C,D : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg C D)) (DSeg C D)) (Fmult (Fmult (Fplus F1 F1) (DSeg C D)) (DSeg C D)))
+++++
ring_simplify_eq.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.
basic_simpl.
ring_simplify_eq.

*****
H3 : eq (DSeg A D) (Fopp (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq F0 F0
A,C,D : Point
*****
eq (Fminus (Fmult (DSeg A C) (DSeg A C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg C D)) (DSeg C D))) F0
+++++
rewrite <- (chasles A C D) in H3.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.
basic_simpl.
ring_simplify_eq.
rewrite <- (chasles A C D) in H3.

*****
H3 : eq (Fplus (DSeg A C) (DSeg C D)) (Fopp (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq F0 F0
A,C,D : Point
*****
eq (Fminus (Fmult (DSeg A C) (DSeg A C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg C D)) (DSeg C D))) F0
+++++
IsoleVar (A**C) H3.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.
basic_simpl.
ring_simplify_eq.
rewrite <- (chasles A C D) in H3.
IsoleVar (A**C) H3.

*****
H3 : eq (DSeg A C) (Fminus (Fopp (DSeg C D)) (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq F0 F0
A,C,D : Point
*****
eq (Fminus (Fmult (DSeg A C) (DSeg A C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg C D)) (DSeg C D))) F0
+++++
rewrite H3.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.
basic_simpl.
ring_simplify_eq.
rewrite <- (chasles A C D) in H3.
IsoleVar (A**C) H3.
rewrite H3.

*****
H3 : eq (DSeg A C) (Fminus (Fopp (DSeg C D)) (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq F0 F0
A,C,D : Point
*****
eq (Fminus (Fmult (Fminus (Fopp (DSeg C D)) (DSeg C D)) (Fminus (Fopp (DSeg C D)) (DSeg C D))) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg C D)) (DSeg C D))) F0
+++++
ring.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
subst.
basic_simpl.
unfold weak_3_parallelogram in H.
use H.
unfold mid_point in H2.
use H2.
uniformize_dir_seg.
assert (D=x).
subst x.
unfold mid_point in H1.
use H1.
rewrite H3.
uniformize_dir_seg.
basic_simpl.
ring_simplify_eq.
rewrite <- (chasles A C D) in H3.

*****
H3 : eq (DSeg A D) (Fopp (DSeg C D))
H2 : Col A C D
H : Col D D D
H0 : eq F0 F0
A,C,D : Point
*****
Col A C D
+++++
auto.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.

*****
H0 : not (eq B D)
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
assert (B**C= A**D).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).

*****
H0 : not (eq B D)
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
apply weak_3_parallelogram_eq_side.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
apply weak_3_parallelogram_eq_side.

*****
H0 : not (eq B D)
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
weak_3_parallelogram A B C D
+++++
auto.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).

*****
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
unfold weak_3_parallelogram in H.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.

*****
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
elim H.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.

*****
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
forall (x : Point) (_ : and (mid_point x A C) (mid_point x B D)), eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
intros O (hA,hb).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).

*****
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
clear H.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.

*****
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).

*****
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Py A O A) (Fminus (Fplus (Fmult (Fdiv (DSeg B O) (DSeg B D)) (Py A D A)) (Fmult (Fdiv (DSeg O D) (DSeg B D)) (Py A B A))) (Fmult (Fmult (Fdiv (DSeg B O) (DSeg B D)) (Fdiv (DSeg O D) (DSeg B D))) (Py B D B)))
+++++
apply (l3_5_py A A B D O).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
apply (l3_5_py A A B D O).

*****
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
not (eq B D)
+++++
unfold mid_point in *.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
apply (l3_5_py A A B D O).
unfold mid_point in *.

*****
hb : and (Col B D O) (eq (DSeg B O) (DSeg O D))
hA : and (Col A C O) (eq (DSeg A O) (DSeg O C))
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
not (eq B D)
+++++
intuition.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
apply (l3_5_py A A B D O).

*****
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
Col O B D
+++++
unfold mid_point in *.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
apply (l3_5_py A A B D O).
unfold mid_point in *.

*****
hb : and (Col B D O) (eq (DSeg B O) (DSeg O D))
hA : and (Col A C O) (eq (DSeg A O) (DSeg O C))
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
Col O B D
+++++
intuition.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).

*****
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv (DSeg B O) (DSeg B D)) (Py A D A))\n (Fmult (Fdiv (DSeg O D) (DSeg B D)) (Py A B A)))\n (Fmult\n (Fmult (Fdiv (DSeg B O) (DSeg B D))\n (Fdiv (DSeg O D) (DSeg B D))) (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).

*****
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv (DSeg O D) (DSeg B D)) (Py A B A)))\n (Fmult\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv (DSeg O D) (DSeg B D)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).

*****
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
assert (A**C = 2* A**O).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).

*****
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
+++++
unfold mid_point in *.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
unfold mid_point in *.

*****
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : and (Col B D O) (eq (DSeg B O) (DSeg O D))
hA : and (Col A C O) (eq (DSeg A O) (DSeg O C))
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
+++++
use hA.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
unfold mid_point in *.
use hA.

*****
H3 : eq (DSeg A O) (DSeg O C)
H2 : Col A C O
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : and (Col B D O) (eq (DSeg B O) (DSeg O D))
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
+++++
replace (A**C) with (A**O + O**C) by auto with Geom.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
unfold mid_point in *.
use hA.
replace (A**C) with (A**O + O**C) by auto with Geom.

*****
H3 : eq (DSeg A O) (DSeg O C)
H2 : Col A C O
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : and (Col B D O) (eq (DSeg B O) (DSeg O D))
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (DSeg A O) (DSeg O C)) (Fmult (Fplus F1 F1) (DSeg A O))
+++++
rewrite H3.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
unfold mid_point in *.
use hA.
replace (A**C) with (A**O + O**C) by auto with Geom.
rewrite H3.

*****
H3 : eq (DSeg A O) (DSeg O C)
H2 : Col A C O
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : and (Col B D O) (eq (DSeg B O) (DSeg O D))
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (DSeg O C) (DSeg O C)) (Fmult (Fplus F1 F1) (DSeg O C))
+++++
ring.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
rewrite H2.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A O)) (Fmult (Fplus F1 F1) (DSeg A O))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Fmult (Fmult (Fplus F1 F1) (DSeg A O)) (DSeg A O))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Py A O A)) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
rewrite H.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
rewrite H.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1))) (Py B D B)))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
unfold Py.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
rewrite H.
unfold Py.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg D A) (DSeg D A))) (Fmult (DSeg A A) (DSeg A A)))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg A A) (DSeg A A))))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1))) (Fminus (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (DSeg D B) (DSeg D B))) (Fmult (DSeg B B) (DSeg B B)))))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
uniformize_dir_seg.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
rewrite H.
unfold Py.
uniformize_dir_seg.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (Fopp (DSeg A D)) (Fopp (DSeg A D)))) (Fmult (DSeg A A) (DSeg A A)))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fmult (DSeg A A) (DSeg A A))))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1))) (Fminus (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (Fopp (DSeg B D)) (Fopp (DSeg B D)))) (Fmult (DSeg B B) (DSeg B B)))))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
basic_simpl.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
rewrite H.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Fplus (Fmult (DSeg A D) (DSeg A D)) (Fmult (DSeg A D) (DSeg A D)))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1))) (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (DSeg B D) (DSeg B D)))))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
replace (A**D) with (B**C).
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
rewrite H.
unfold Py.
uniformize_dir_seg.
basic_simpl.
replace (A**D) with (B**C).

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Fplus (Fmult (DSeg B C) (DSeg B C)) (Fmult (DSeg B C) (DSeg B C)))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A B) (DSeg A B))))) (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1))) (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (DSeg B D) (DSeg B D)))))) (Fmult (DSeg B D) (DSeg B D))) (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
+++++
field.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.
assert (B**C= A**D).
unfold weak_3_parallelogram in H.
elim H.
intros O (hA,hb).
clear H.
assert (Py A O A = B ** O / B ** D * Py A D A + O ** D / B ** D * Py A B A - B ** O / B ** D * (O ** D / B ** D) * Py B D B).
replace (B ** O / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_1;auto).
replace (O ** D / B ** D) with (1/2) in * by (symmetry;apply midpoint_ratio_2;auto).
assert (A**C = 2* A**O).
rewrite H2.
replace (2 * A ** O * (2 * A ** O)) with (2*(2*A ** O * A**O)) by ring.
replace (2*A ** O * A**O) with (Py A O A) by (unfold Py;uniformize_dir_seg;basic_simpl;try ring).
rewrite H.
unfold Py.
uniformize_dir_seg.
basic_simpl.
replace (A**D) with (B**C).
field.

*****
H2 : eq (DSeg A C) (Fmult (Fplus F1 F1) (DSeg A O))
H : eq (Py A O A)\n (Fminus\n (Fplus (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A D A))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A B A)))\n (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fdiv F1 (Fplus F1 F1)))\n (Py B D B)))
hb : mid_point O B D
hA : mid_point O A C
O : Point
H1 : eq (DSeg B C) (DSeg A D)
H0 : not (eq B D)
A,B,C,D : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l3_6 : forall A B C D, weak_3_parallelogram A B C D -> A**C * A**C + B**D * B**D = 2*A**B * A**B + 2*B**C*B**C.
Proof.
intros.
cases_equality B D.

*****

*****

+++++
Qed.
-----
Lemma l3_6_b : forall A B C D, \n  weak_3_parallelogram A B C D ->\n  Py A B C = - Py B A D.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), eq (Py A B C) (Fopp (Py B A D))
+++++
Proof.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.

*****

*****
forall (A B C D : Point) (_ : weak_3_parallelogram A B C D), eq (Py A B C) (Fopp (Py B A D))
+++++
intros.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Py A B C) (Fopp (Py B A D))
+++++
unfold Py.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.

*****
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))) (Fopp (Fminus (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg B D) (DSeg B D))))
+++++
assert (T:=l3_6 A B C D H).
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).

*****
T : eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D)))\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))) (Fopp (Fminus (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg B D) (DSeg B D))))
+++++
IsoleVar (A ** C * A ** C) T.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))) (Fopp (Fminus (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg B D) (DSeg B D))))
+++++
rewrite T.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fminus (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C))) (Fmult (DSeg B D) (DSeg B D)))) (Fopp (Fminus (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg B D) (DSeg B D))))
+++++
uniformize_dir_seg.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fminus (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C))) (Fmult (DSeg B D) (DSeg B D)))) (Fopp (Fminus (Fplus (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B))) (Fmult (DSeg A D) (DSeg A D))) (Fmult (DSeg B D) (DSeg B D))))
+++++
ring_simplify_eq.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.
ring_simplify_eq.

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fopp (DSeg B C)) (DSeg B C)) (Fmult (DSeg A D) (DSeg A D))) F0
+++++
replace (B**C) with (A**D).
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.
ring_simplify_eq.
replace (B**C) with (A**D).

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (Fplus (Fmult (Fopp (DSeg A D)) (DSeg A D)) (Fmult (DSeg A D) (DSeg A D))) F0
+++++
ring.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.
ring_simplify_eq.
replace (B**C) with (A**D).

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg A D) (DSeg B C)
+++++
symmetry.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.
ring_simplify_eq.
replace (B**C) with (A**D).
symmetry.

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
eq (DSeg B C) (DSeg A D)
+++++
apply weak_3_parallelogram_eq_side.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.
ring_simplify_eq.
replace (B**C) with (A**D).
symmetry.
apply weak_3_parallelogram_eq_side.

*****
T : eq (Fmult (DSeg A C) (DSeg A C))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg B D) (DSeg B D)))
H : weak_3_parallelogram A B C D
A,B,C,D : Point
*****
weak_3_parallelogram A B C D
+++++
auto.
-----
Lemma l3_6_b : forall A B C D, weak_3_parallelogram A B C D -> Py A B C = - Py B A D.
Proof.
intros.
unfold Py.
assert (T:=l3_6 A B C D H).
IsoleVar (A ** C * A ** C) T.
rewrite T.
uniformize_dir_seg.
ring_simplify_eq.
replace (B**C) with (A**D).

*****

*****

+++++
Qed.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D ->\nPy P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.

*****

*****
forall (A B C D P Q : Point) (_ : weak_3_parallelogram A B C D), eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
Proof.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.

*****

*****
forall (A B C D P Q : Point) (_ : weak_3_parallelogram A B C D), eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
intros.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
assert (X:= H).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).

*****
H,X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
unfold weak_3_parallelogram in H.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.

*****
X : weak_3_parallelogram A B C D
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
elim H.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.

*****
X : weak_3_parallelogram A B C D
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D,P,Q : Point
*****
forall (x : Point) (_ : and (mid_point x A C) (mid_point x B D)), eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
intros O HO.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.

*****
HO : and (mid_point O A C) (mid_point O B D)
O : Point
X : weak_3_parallelogram A B C D
H : ex (fun O : Point => and (mid_point O A C) (mid_point O B D))
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
clear H.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.

*****
HO : and (mid_point O A C) (mid_point O B D)
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
use HO.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.

*****
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
assert (T:= l_28_b_midpoint O A C P Q H).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).

*****
T : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
assert (U:= l_28_b_midpoint O B D P Q H0).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).

*****
U : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
T : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).

*****
U : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
T : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fminus (Fplus (Py P A Q) (Py P C Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A))) (Fminus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
+++++
congruence.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
U : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
T : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
idtac.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
U : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
T : eq (Fmult (Fplus F1 F1) (Py P O Q))\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
clear T U.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fmult (Fplus F1 F1) (Py B A D)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
+++++
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py B A D) (Py B A D)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
+++++
replace (Py B A D) with (- Py A B C).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fopp (Py A B C)) (Fopp (Py A B C))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
+++++
unfold Py.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fopp (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fopp (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fminus (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg C A) (DSeg C A))) (Fmult (DSeg A A) (DSeg A A))) (Fminus (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (DSeg D B) (DSeg D B))) (Fmult (DSeg B B) (DSeg B B)))))
+++++
uniformize_dir_seg.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fopp (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fopp (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fminus (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (Fopp (DSeg A C)) (Fopp (DSeg A C)))) (Fmult F0 F0)) (Fminus (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (Fopp (DSeg B D)) (Fopp (DSeg B D)))) (Fmult F0 F0))))
+++++
basic_simpl.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fminus (Fopp (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg A C) (DSeg A C))) (Fplus (Fmult (DSeg B D) (DSeg B D)) (Fmult (DSeg B D) (DSeg B D)))))
+++++
field_simplify_eq.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fminus (Fmult (Fmult (Fopp (Fmult (Fplus F1 F1) (Fplus F1 F1))) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg B C)) (DSeg B C))) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg A C)) (DSeg A C))) (Fminus (Fmult (Fmult (Fplus F1 F1) (DSeg A C)) (DSeg A C)) (Fmult (Fmult (Fplus F1 F1) (DSeg B D)) (DSeg B D)))
+++++
ring_simplify_eq.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.
ring_simplify_eq.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fplus (Fminus (Fmult (Fmult (Fopp (Fmult (Fplus F1 F1) (Fplus F1 F1))) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg B C)) (DSeg B C))) (Fmult (Fmult (Fplus F1 F1) (DSeg A C)) (DSeg A C))) (Fmult (Fmult (Fplus F1 F1) (DSeg B D)) (DSeg B D))) F0
+++++
assert (T:=l3_6 A B C D X).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.
ring_simplify_eq.
assert (T:=l3_6 A B C D X).

*****
T : eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg B D) (DSeg B D)))\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fplus (Fminus (Fmult (Fmult (Fopp (Fmult (Fplus F1 F1) (Fplus F1 F1))) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg B C)) (DSeg B C))) (Fmult (Fmult (Fplus F1 F1) (DSeg A C)) (DSeg A C))) (Fmult (Fmult (Fplus F1 F1) (DSeg B D)) (DSeg B D))) F0
+++++
IsoleVar (B ** D * B ** D) T.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.
ring_simplify_eq.
assert (T:=l3_6 A B C D X).
IsoleVar (B ** D * B ** D) T.

*****
T : eq (Fmult (DSeg B D) (DSeg B D))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fplus (Fminus (Fmult (Fmult (Fopp (Fmult (Fplus F1 F1) (Fplus F1 F1))) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg B C)) (DSeg B C))) (Fmult (Fmult (Fplus F1 F1) (DSeg A C)) (DSeg A C))) (Fmult (Fmult (Fplus F1 F1) (DSeg B D)) (DSeg B D))) F0
+++++
replace (2 * B ** D * B ** D) with (2 * (B ** D * B ** D)) by ring.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.
ring_simplify_eq.
assert (T:=l3_6 A B C D X).
IsoleVar (B ** D * B ** D) T.
replace (2 * B ** D * B ** D) with (2 * (B ** D * B ** D)) by ring.

*****
T : eq (Fmult (DSeg B D) (DSeg B D))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fplus (Fminus (Fmult (Fmult (Fopp (Fmult (Fplus F1 F1) (Fplus F1 F1))) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg B C)) (DSeg B C))) (Fmult (Fmult (Fplus F1 F1) (DSeg A C)) (DSeg A C))) (Fmult (Fplus F1 F1) (Fmult (DSeg B D) (DSeg B D)))) F0
+++++
rewrite T.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.
ring_simplify_eq.
assert (T:=l3_6 A B C D X).
IsoleVar (B ** D * B ** D) T.
replace (2 * B ** D * B ** D) with (2 * (B ** D * B ** D)) by ring.
rewrite T.

*****
T : eq (Fmult (DSeg B D) (DSeg B D))\n (Fminus\n (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fplus (Fminus (Fmult (Fmult (Fopp (Fmult (Fplus F1 F1) (Fplus F1 F1))) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (DSeg B C)) (DSeg B C))) (Fmult (Fmult (Fplus F1 F1) (DSeg A C)) (DSeg A C))) (Fmult (Fplus F1 F1) (Fminus (Fplus (Fmult (Fmult (Fplus F1 F1) (DSeg A B)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg B C)) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))))) F0
+++++
ring.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
unfold Py.
uniformize_dir_seg.
basic_simpl.
field_simplify_eq.

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).

*****
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fopp (Py A B C)) (Py B A D)
+++++
assert (U:=l3_6_b A B C D X).
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
assert (U:=l3_6_b A B C D X).

*****
U : eq (Py A B C) (Fopp (Py B A D))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fopp (Py A B C)) (Py B A D)
+++++
rewrite U.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
replace (2 * Py B A D) with (Py B A D + Py B A D) by ring.
replace (Py B A D) with (- Py A B C).
assert (U:=l3_6_b A B C D X).
rewrite U.

*****
U : eq (Py A B C) (Fopp (Py B A D))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fopp (Fopp (Py B A D))) (Py B A D)
+++++
ring.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).

*****
H2 : eq (Fmult (Fplus F1 F1) (Py B A D))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fplus F1 F1) (Py B A D)))
+++++
rewrite H2.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
rewrite H2.

*****
H2 : eq (Fmult (Fplus F1 F1) (Py B A D))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
H1 : eq\n (Fminus (Fplus (Py P A Q) (Py P C Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B))))
+++++
IsoleVar (Py P A Q + Py P C Q) H1.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
rewrite H2.
IsoleVar (Py P A Q + Py P C Q) H1.

*****
H1 : eq (Fplus (Py P A Q) (Py P C Q))\n (Fplus\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H2 : eq (Fmult (Fplus F1 F1) (Py B A D))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Py P A Q) (Py P C Q)) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B))))
+++++
rewrite H1.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
rewrite H2.
IsoleVar (Py P A Q + Py P C Q) H1.
rewrite H1.

*****
H1 : eq (Fplus (Py P A Q) (Py P C Q))\n (Fplus\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H2 : eq (Fmult (Fplus F1 F1) (Py B A D))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
eq (Fplus (Fminus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B))) (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A))) (Fplus (Fplus (Py P B Q) (Py P D Q)) (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B))))
+++++
field.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).
idtac.
clear T U.
assert (2* Py B A D = 1/2 * (Py A C A - Py B D B)).
rewrite H2.
IsoleVar (Py P A Q + Py P C Q) H1.
rewrite H1.
field.

*****
H1 : eq (Fplus (Py P A Q) (Py P C Q))\n (Fplus\n (Fminus (Fplus (Py P B Q) (Py P D Q))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py B D B)))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Py A C A)))
H2 : eq (Fmult (Fplus F1 F1) (Py B A D))\n (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Py A C A) (Py B D B)))
H0 : mid_point O B D
H : mid_point O A C
O : Point
X : weak_3_parallelogram A B C D
A,B,C,D,P,Q : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma l_27_c : forall A B C D P Q, weak_3_parallelogram A B C D -> Py P A Q + Py P C Q = Py P B Q + Py P D Q + 2 * Py B A D.
Proof.
intros.
assert (X:= H).
unfold weak_3_parallelogram in H.
elim H.
intros O HO.
clear H.
use HO.
assert (T:= l_28_b_midpoint O A C P Q H).
assert (U:= l_28_b_midpoint O B D P Q H0).
assert (Py P A Q + Py P C Q - 1 / 2 * Py A C A = Py P B Q + Py P D Q - 1 / 2 * Py B D B).

*****

*****

+++++
Qed.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D ->\nPy P A B = Py4 P D A C.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.

*****

*****
forall (A B C D P : Point) (_ : weak_3_parallelogram A B C D), eq (Py P A B) (Py4 P D A C)
+++++
Proof.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.

*****

*****
forall (A B C D P : Point) (_ : weak_3_parallelogram A B C D), eq (Py P A B) (Py4 P D A C)
+++++
intros.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Py4 P D A C)
+++++
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Py4 C A D P)
+++++
unfold Py4.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
unfold Py4.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Fminus (Py C A P) (Py D A P))
+++++
assert (T:=l_27_a A B C D A P H).
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
unfold Py4.
assert (T:=l_27_a A B C D A P H).

*****
T : eq (Fplus (Py A A P) (Py C A P)) (Fplus (Py B A P) (Py D A P))
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Fminus (Py C A P) (Py D A P))
+++++
basic_simpl.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
unfold Py4.
assert (T:=l_27_a A B C D A P H).
basic_simpl.

*****
T : eq (Py C A P) (Fplus (Py B A P) (Py D A P))
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Fminus (Py C A P) (Py D A P))
+++++
rewrite T.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
unfold Py4.
assert (T:=l_27_a A B C D A P H).
basic_simpl.
rewrite T.

*****
T : eq (Py C A P) (Fplus (Py B A P) (Py D A P))
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Fminus (Fplus (Py B A P) (Py D A P)) (Py D A P))
+++++
uniformize_pys.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
unfold Py4.
assert (T:=l_27_a A B C D A P H).
basic_simpl.
rewrite T.
uniformize_pys.

*****
T : eq (Py C A P) (Fplus (Py B A P) (Py D A P))
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py B A P) (Fminus (Fplus (Py B A P) (Py D A P)) (Py D A P))
+++++
ring.
-----
Lemma l3_8_a : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py4 P D A C.
Proof.
intros.
replace (Py4 P D A C) with (Py4 C A D P) by auto with Geom.
unfold Py4.
assert (T:=l_27_a A B C D A P H).
basic_simpl.
rewrite T.
uniformize_pys.
ring.

*****

*****

+++++
Qed.
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D ->\nPy P A B = Py P D C - Py A D C.
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.

*****

*****
forall (A B C D P : Point) (_ : weak_3_parallelogram A B C D), eq (Py P A B) (Fminus (Py P D C) (Py A D C))
+++++
Proof.
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.
Proof.

*****

*****
forall (A B C D P : Point) (_ : weak_3_parallelogram A B C D), eq (Py P A B) (Fminus (Py P D C) (Py A D C))
+++++
intros.
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.
Proof.
intros.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py P A B) (Fminus (Py P D C) (Py A D C))
+++++
rewrite (l3_8_a A B C D).
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.
Proof.
intros.
rewrite (l3_8_a A B C D).

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py4 P D A C) (Fminus (Py P D C) (Py A D C))
+++++
idtac.
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.
Proof.
intros.
rewrite (l3_8_a A B C D).
idtac.

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
eq (Py4 P D A C) (Fminus (Py P D C) (Py A D C))
+++++
auto with Geom.
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.
Proof.
intros.
rewrite (l3_8_a A B C D).

*****
H : weak_3_parallelogram A B C D
A,B,C,D,P : Point
*****
weak_3_parallelogram A B C D
+++++
auto .
-----
Lemma l3_8_b : forall A B C D P, weak_3_parallelogram A B C D -> Py P A B = Py P D C - Py A D C.
Proof.
intros.
rewrite (l3_8_a A B C D).

*****

*****

+++++
Qed.
-----
Lemma l_28_a : forall A B U V Y,\nCol Y U V -> U <> V ->\nS A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.

*****

*****
forall (A B U V Y : Point) (_ : Col Y U V) (_ : not (eq U V)), eq (S A B Y) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S A B U)))
+++++
Proof.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.

*****

*****
forall (A B U V Y : Point) (_ : Col Y U V) (_ : not (eq U V)), eq (S A B Y) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S A B U)))
+++++
intros.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
eq (S A B Y) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S A B U)))
+++++
replace (S A B Y) with (S Y A B) by auto with Geom.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
eq (S Y A B) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S A B U)))
+++++
rewrite (l2_9 A B U V Y).
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.
rewrite (l2_9 A B U V Y).

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
eq (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S V A B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S U A B))) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S A B U)))
+++++
idtac.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.
rewrite (l2_9 A B U V Y).
idtac.

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
eq (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S V A B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S U A B))) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S A B V)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S A B U)))
+++++
uniformize_signed_areas.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.
rewrite (l2_9 A B U V Y).
idtac.
uniformize_signed_areas.

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
eq (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S V A B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S U A B))) (Fplus (Fmult (Fdiv (DSeg U Y) (DSeg U V)) (S V A B)) (Fmult (Fdiv (DSeg Y V) (DSeg U V)) (S U A B)))
+++++
auto.
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.
rewrite (l2_9 A B U V Y).

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
not (eq U V)
+++++
auto .
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.
rewrite (l2_9 A B U V Y).

*****
H0 : not (eq U V)
H : Col Y U V
A,B,U,V,Y : Point
*****
Col Y U V
+++++
auto .
-----
Lemma l_28_a : forall A B U V Y, Col Y U V -> U <> V -> S A B Y = U**Y/U**V * S A B V + Y**V/U**V * S A B U.
Proof.
intros.
replace (S A B Y) with (S Y A B) by auto with Geom.
rewrite (l2_9 A B U V Y).

*****

*****

+++++
Qed.
-----
Lemma on_foot_per : forall A B C F, \n  on_foot F A B C ->\n  per A F B.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.

*****

*****
forall (A B C F : Point) (_ : on_foot F A B C), per A F B
+++++
Proof.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.

*****

*****
forall (A B C F : Point) (_ : on_foot F A B C), per A F B
+++++
intros.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.

*****
H : on_foot F A B C
A,B,C,F : Point
*****
per A F B
+++++
unfold on_foot in H.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.

*****
H : and (perp F A B C) (and (Col F B C) (not (eq B C)))
A,B,C,F : Point
*****
per A F B
+++++
use H.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.

*****
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
per A F B
+++++
assert (perp A F B C).
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).

*****
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
perp A F B C
+++++
auto with Geom.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
per A F B
+++++
idtac.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
per A F B
+++++
cut (perp A F F B).
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
forall _ : perp A F F B, per A F B
+++++
auto with Geom.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
perp A F F B
+++++
cut (perp F B A F).
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).
cut (perp F B A F).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
forall _ : perp F B A F, perp A F F B
+++++
auto with Geom.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).
cut (perp F B A F).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
perp F B A F
+++++
apply (perp_para_perp B C A F F B).
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).
cut (perp F B A F).
apply (perp_para_perp B C A F F B).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
not (eq B C)
+++++
auto with Geom.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).
cut (perp F B A F).
apply (perp_para_perp B C A F F B).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
perp B C A F
+++++
auto with Geom.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).
idtac.
cut (perp A F F B).
cut (perp F B A F).
apply (perp_para_perp B C A F F B).

*****
H : perp A F B C
H3 : not (eq B C)
H2 : Col F B C
H0 : perp F A B C
A,B,C,F : Point
*****
parallel B C F B
+++++
auto with Geom.
-----
Lemma on_foot_per : forall A B C F, on_foot F A B C -> per A F B.
Proof.
intros.
unfold on_foot in H.
use H.
assert (perp A F B C).

*****

*****

+++++
Qed.
-----
Lemma herron_qin : forall A B C,\nS A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).

*****

*****
forall A B C : Point, eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
Proof.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.

*****

*****
forall A B C : Point, eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
intros.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.

*****
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
cases_equality B C.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.

*****
H : eq B C
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
subst.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.

*****
A,C : Point
*****
eq (Fmult (S A C C) (S A C C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A C A) (Py A C A)) (Fmult (Py C A C) (Py C A C))))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.

*****
A,C : Point
*****
eq F0 (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A C A) (Py A C A)) (Fmult (Py C A C) (Py C A C))))
+++++
uniformize_pys.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.

*****
A,C : Point
*****
eq F0 (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py C A C) (Py C A C)) (Fmult (Py C A C) (Py C A C))))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.

*****
A,C : Point
*****
eq F0 F0
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.

*****
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
elim (proj_ex A B C H).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).

*****
H : not (eq B C)
A,B,C : Point
*****
forall (x : Point) (_ : on_foot x A B C), eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
intros F HF.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.

*****
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
cases_equality B F.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.

*****
H0 : eq B F
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
subst.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.

*****
H : not (eq F C)
HF : on_foot F A F C
A,C,F : Point
*****
eq (Fmult (S A F C) (S A F C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C))))
+++++
assert (T:=on_foot_area A F C F HF).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
HF : on_foot F A F C
A,C,F : Point
*****
eq (Fmult (S A F C) (S A F C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C))))
+++++
field_simplify_eq.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
HF : on_foot F A F C
A,C,F : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (S A F C)) (S A F C)) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
2:repeat apply nonzeromult;auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
HF : on_foot F A F C
A,C,F : Point
*****
eq (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (S A F C)) (S A F C)) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
HF : on_foot F A F C
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C)) (S A F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
rewrite T.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
HF : on_foot F A F C
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
unfold on_foot in HF.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
HF : and (perp F A F C) (and (Col F F C) (not (eq F C)))
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
use HF.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.

*****
H3 : not (eq F C)
H2 : Col F F C
H0 : perp F A F C
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
clear H2 H3.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.

*****
H0 : perp F A F C
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
assert (perp F C A F) by auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.

*****
H1 : perp F C A F
H0 : perp F A F C
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
unfold perp, Py4 in *.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.

*****
H1 : eq (Fminus (Py F A F) (Py C A F)) F0
H0 : eq (Fminus (Py F F C) (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
IsoleVar (Py C A F) H1.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.

*****
H1 : eq (Py C A F) (Fminus (Py F A F) F0)
H0 : eq (Fminus (Py F F C) (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.

*****
H1 : eq (Py F A C) (Fminus (Py F A F) F0)
H0 : eq (Fminus (Py F F C) (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Py F A C) (Py F A C)))
+++++
rewrite H1.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.

*****
H1 : eq (Py F A C) (Fminus (Py F A F) F0)
H0 : eq (Fminus (Py F F C) (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py A F A) (Py A C A)) (Fmult (Fminus (Py F A F) F0) (Fminus (Py F A F) F0)))
+++++
uniformize_pys.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.

*****
H1 : eq (Py F A C) (Fminus (Py F A F) F0)
H0 : eq (Fminus (Py F F C) (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py F A F) (Py A C A)) (Fmult (Fminus (Py F A F) F0) (Fminus (Py F A F) F0)))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py F A F) (Py A C A)) (Fmult (Py F A F) (Py F A F)))
+++++
assert (Py A C A = Py A F A + Py F C F).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Py A C A) (Fplus (Py A F A) (Py F C F))
+++++
unfold Py.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fminus (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg C A) (DSeg C A))) (Fmult (DSeg A A) (DSeg A A))) (Fplus (Fminus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F A) (DSeg F A))) (Fmult (DSeg A A) (DSeg A A))) (Fminus (Fplus (Fmult (DSeg F C) (DSeg F C)) (Fmult (DSeg C F) (DSeg C F))) (Fmult (DSeg F F) (DSeg F F))))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg C A) (DSeg C A))) (Fplus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F A) (DSeg F A))) (Fplus (Fmult (DSeg F C) (DSeg F C)) (Fmult (DSeg C F) (DSeg C F))))
+++++
uniformize_dir_seg.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (Fopp (DSeg C F)))\n (Fopp (DSeg C F)))
H : not (eq F C)
A,C,F : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (Fopp (DSeg A C)) (Fopp (DSeg A C)))) (Fplus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (Fopp (DSeg A F)) (Fopp (DSeg A F)))) (Fplus (Fmult (Fopp (DSeg C F)) (Fopp (DSeg C F))) (Fmult (DSeg C F) (DSeg C F))))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg A C) (DSeg A C))) (Fplus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg A F) (DSeg A F))) (Fplus (Fmult (DSeg C F) (DSeg C F)) (Fmult (DSeg C F) (DSeg C F))))
+++++
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fplus F1 F1) (Fmult (DSeg A C) (DSeg A C))) (Fplus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg A F) (DSeg A F))) (Fplus (Fmult (DSeg C F) (DSeg C F)) (Fmult (DSeg C F) (DSeg C F))))
+++++
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fplus F1 F1) (Fmult (DSeg A C) (DSeg A C))) (Fplus (Fmult (Fplus F1 F1) (Fmult (DSeg A F) (DSeg A F))) (Fplus (Fmult (DSeg C F) (DSeg C F)) (Fmult (DSeg C F) (DSeg C F))))
+++++
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fplus F1 F1) (Fmult (DSeg A C) (DSeg A C))) (Fplus (Fmult (Fplus F1 F1) (Fmult (DSeg A F) (DSeg A F))) (Fmult (Fplus F1 F1) (Fmult (DSeg C F) (DSeg C F))))
+++++
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fplus F1 F1) (Fmult (DSeg A C) (DSeg A C))) (Fmult (Fplus F1 F1) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F))))
+++++
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
+++++
assert (Py A F C = 0).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Py A F C) F0
+++++
replace 0 with (-0) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Py A F C) (Fopp F0)
+++++
rewrite <- H0.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.

*****
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Py A F C) (Fopp (Fminus F0 (Py A F C)))
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.

*****
H2 : eq (Py A F C) F0
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
+++++
unfold Py in H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.

*****
H2 : eq\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F C) (DSeg F C)))\n (Fmult (DSeg A C) (DSeg A C))) F0
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
+++++
uniformize_dir_seg.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.

*****
H2 : eq\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F))\n (Fmult (Fopp (DSeg C F)) (Fopp (DSeg C F))))\n (Fmult (DSeg A C) (DSeg A C))) F0
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.

*****
H2 : eq\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))\n (Fmult (DSeg A C) (DSeg A C))) F0
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
+++++
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.

*****
H2 : eq (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))\n (Fplus F0 (Fmult (DSeg A C) (DSeg A C)))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
+++++
rewrite H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.

*****
H2 : eq (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))\n (Fplus F0 (Fmult (DSeg A C) (DSeg A C)))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (DSeg A C) (DSeg A C)) (Fplus F0 (Fmult (DSeg A C) (DSeg A C)))
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.

*****
H2 : eq (Fmult (DSeg A C) (DSeg A C))\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F)))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fplus F1 F1) (Fmult (DSeg A C) (DSeg A C))) (Fmult (Fplus F1 F1) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg C F) (DSeg C F))))
+++++
rewrite H2;auto.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.

*****
H2 : eq (Py A C A) (Fplus (Py A F A) (Py F C F))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py F A F) (Py A C A)) (Fmult (Py F A F) (Py F A F)))
+++++
rewrite H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.

*****
H2 : eq (Py A C A) (Fplus (Py A F A) (Py F C F))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Py F A F) (Fplus (Py A F A) (Py F C F))) (Fmult (Py F A F) (Py F A F)))
+++++
unfold Py.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.

*****
H2 : eq (Py A C A) (Fplus (Py A F A) (Py F C F))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg F C)) (DSeg F C))) (Fminus (Fmult (Fminus (Fplus (Fmult (DSeg F A) (DSeg F A)) (Fmult (DSeg A F) (DSeg A F))) (Fmult (DSeg F F) (DSeg F F))) (Fplus (Fminus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F A) (DSeg F A))) (Fmult (DSeg A A) (DSeg A A))) (Fminus (Fplus (Fmult (DSeg F C) (DSeg F C)) (Fmult (DSeg C F) (DSeg C F))) (Fmult (DSeg F F) (DSeg F F))))) (Fmult (Fminus (Fplus (Fmult (DSeg F A) (DSeg F A)) (Fmult (DSeg A F) (DSeg A F))) (Fmult (DSeg F F) (DSeg F F))) (Fminus (Fplus (Fmult (DSeg F A) (DSeg F A)) (Fmult (DSeg A F) (DSeg A F))) (Fmult (DSeg F F) (DSeg F F)))))
+++++
uniformize_dir_seg.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.

*****
H2 : eq (Py A C A) (Fplus (Py A F A) (Py F C F))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (Fopp (DSeg C F)))\n (Fopp (DSeg C F)))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (Fopp (DSeg C F))) (Fopp (DSeg C F)))) (Fminus (Fmult (Fminus (Fplus (Fmult (Fopp (DSeg A F)) (Fopp (DSeg A F))) (Fmult (DSeg A F) (DSeg A F))) (Fmult (DSeg F F) (DSeg F F))) (Fplus (Fminus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (Fopp (DSeg A F)) (Fopp (DSeg A F)))) (Fmult (DSeg A A) (DSeg A A))) (Fminus (Fplus (Fmult (Fopp (DSeg C F)) (Fopp (DSeg C F))) (Fmult (DSeg C F) (DSeg C F))) (Fmult (DSeg F F) (DSeg F F))))) (Fmult (Fminus (Fplus (Fmult (Fopp (DSeg A F)) (Fopp (DSeg A F))) (Fmult (DSeg A F) (DSeg A F))) (Fmult (DSeg F F) (DSeg F F))) (Fminus (Fplus (Fmult (Fopp (DSeg A F)) (Fopp (DSeg A F))) (Fmult (DSeg A F) (DSeg A F))) (Fmult (DSeg F F) (DSeg F F)))))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
H2 : eq (Py A C A) (Fplus (Py A F A) (Py F C F))
H1 : eq (Py F A C) (Py F A F)
H0 : eq (Fminus F0 (Py A F C)) F0
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (S A F C))\n (S A F C))\n (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))
H : not (eq F C)
A,C,F : Point
*****
eq (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fmult (DSeg A F) (DSeg A F)) (DSeg C F)) (DSeg C F))) (Fminus (Fmult (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg A F) (DSeg A F))) (Fplus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg A F) (DSeg A F))) (Fplus (Fmult (DSeg C F) (DSeg C F)) (Fmult (DSeg C F) (DSeg C F))))) (Fmult (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg A F) (DSeg A F))) (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg A F) (DSeg A F)))))
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.

*****
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
assert (Col B F C).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).

*****
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
Col B F C
+++++
unfold on_foot in HF.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.

*****
H0 : not (eq B F)
HF : and (perp F A B C) (and (Col F B C) (not (eq B C)))
F : Point
H : not (eq B C)
A,B,C : Point
*****
Col B F C
+++++
use HF;auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.

*****
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
assert (T:= l_3_4_b B F C A H1).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).

*****
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
replace (Py A B F) with (Py F B F) in T.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.

*****
T : eq (Fmult (Py F B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
replace (Py F B F) with (2*B**F*B**F) in T.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B F)) (DSeg B C))\n (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.

*****
T : eq\n (Fmult (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B F)) (DSeg B C))\n (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
IsoleVar (Py A B C) T.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.

*****
T : eq (Py A B C)\n (Fdiv\n (Fmult (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B F))\n (DSeg B C)) (DSeg B F))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2:auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.

*****
T : eq (Py A B C)\n (Fdiv\n (Fmult (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B F))\n (DSeg B C)) (DSeg B F))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2:field;auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (S A B C) (S A B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fmult (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) F1) (Fplus F1 F1)) (DSeg A F)) (DSeg A F)) (DSeg B C)) (DSeg B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fmult (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) F1) (Fplus F1 F1)) (DSeg A F)) (DSeg A F)) (DSeg B C)) (DSeg B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2: (rewrite <- on_foot_area).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fmult (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) F1) (Fplus F1 F1)) (DSeg A F)) (DSeg A F)) (DSeg B C)) (DSeg B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2:field;auto with Geom.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fmult (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) F1) (Fplus F1 F1)) (DSeg A F)) (DSeg A F)) (DSeg B C)) (DSeg B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
2:auto.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fmult (Fdiv (Fmult (Fdiv F1 (Fplus F1 F1)) F1) (Fplus F1 F1)) (DSeg A F)) (DSeg A F)) (DSeg B C)) (DSeg B C)) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fmult (DSeg A F) (DSeg A F))) (Fdiv F1 (Fplus F1 F1))) (Fmult (DSeg B C) (DSeg B C))) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fmult (Fmult (Fmult (Fdiv F1 (Fplus F1 F1)) (Fminus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F)))) (Fdiv F1 (Fplus F1 F1))) (Fmult (DSeg B C) (DSeg B C))) (Fmult (Fdiv F1 (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus F1 F1)) (Fplus F1 F1))) (Fminus (Fmult (Py A B A) (Py A C A)) (Fmult (Py B A C) (Py B A C))))
+++++
field_simplify_eq.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg A B)) (DSeg A B)) (DSeg B C)) (DSeg B C)) (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg B F)) (DSeg B F)) (DSeg B C)) (DSeg B C))) (Fminus (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py A B A)) (Py A C A)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py B A C)) (Py B A C)))
+++++
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg A B)) (DSeg A B)) (DSeg B C)) (DSeg B C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C)))) (Fminus (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py A B A)) (Py A C A)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py B A C)) (Py B A C)))
+++++
rewrite <- T.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg A B)) (DSeg A B)) (DSeg B C)) (DSeg B C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py A B C)) (Py A B C))) (Fminus (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py A B A)) (Py A C A)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Py B A C)) (Py B A C)))
+++++
unfold Py.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg A B)) (DSeg A B)) (DSeg B C)) (DSeg B C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))))) (Fminus (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B A) (DSeg B A))) (Fmult (DSeg A A) (DSeg A A)))) (Fminus (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg C A) (DSeg C A))) (Fmult (DSeg A A) (DSeg A A)))) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A C) (DSeg A C))) (Fmult (DSeg B C) (DSeg B C)))) (Fminus (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A C) (DSeg A C))) (Fmult (DSeg B C) (DSeg B C)))))
+++++
uniformize_dir_seg.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg A B)) (DSeg A B)) (DSeg B C)) (DSeg B C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))))) (Fminus (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))) (Fmult (DSeg A A) (DSeg A A)))) (Fminus (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (Fopp (DSeg A C)) (Fopp (DSeg A C)))) (Fmult (DSeg A A) (DSeg A A)))) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B))) (Fmult (DSeg A C) (DSeg A C))) (Fmult (DSeg B C) (DSeg B C)))) (Fminus (Fplus (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B))) (Fmult (DSeg A C) (DSeg A C))) (Fmult (DSeg B C) (DSeg B C)))))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (Fmult (Fmult (Fmult (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) (DSeg A B)) (DSeg A B)) (DSeg B C)) (DSeg B C)) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C)))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C))) (Fmult (DSeg A C) (DSeg A C))))) (Fminus (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A B) (DSeg A B)))) (Fplus (Fmult (DSeg A C) (DSeg A C)) (Fmult (DSeg A C) (DSeg A C)))) (Fmult (Fmult (Fmult (Fplus F1 F1) (Fplus F1 F1)) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A C) (DSeg A C))) (Fmult (DSeg B C) (DSeg B C)))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A C) (DSeg A C))) (Fmult (DSeg B C) (DSeg B C)))))
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
and (not (eq (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fmult (Fplus F1 F1) (Fplus F1 F1)))) F0)) (not (eq (Fplus F1 F1) F0))
+++++
solve_conds.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F))
+++++
assert (per A F B).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).

*****
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
per A F B
+++++
apply (on_foot_per A B C F);auto.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.

*****
H3 : per A F B
T : eq (Py A B C) (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F))
+++++
unfold per,Py in *.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.

*****
H3 : eq\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F B) (DSeg F B)))\n (Fmult (DSeg A B) (DSeg A B))) F0
T : eq\n (Fminus\n (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F))
+++++
uniformize_dir_seg.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.

*****
H3 : eq\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F))\n (Fmult (Fopp (DSeg B F)) (Fopp (DSeg B F))))\n (Fmult (DSeg A B) (DSeg A B))) F0
T : eq\n (Fminus\n (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F))
+++++
IsoleVar (A**B*A**B) H3.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.

*****
H3 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F))\n (Fmult (Fopp (DSeg B F)) (Fopp (DSeg B F)))) F0)
T : eq\n (Fminus\n (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F))
+++++
rewrite H3.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.

*****
H3 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F))\n (Fmult (Fopp (DSeg B F)) (Fopp (DSeg B F)))) F0)
T : eq\n (Fminus\n (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B C) (DSeg B C)))\n (Fmult (DSeg A C) (DSeg A C)))\n (Fmult (Fmult (Fplus F1 F1) (DSeg B F)) (DSeg B C))
H2 : not (eq (DSeg B F) F0)
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fminus (Fminus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (Fopp (DSeg B F)) (Fopp (DSeg B F)))) F0) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F))
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.

*****
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Py F B F) (Py A B F)
+++++
assert (per A F B).
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).

*****
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
per A F B
+++++
apply (on_foot_per A B C F);assumption.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.

*****
H2 : per A F B
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Py F B F) (Py A B F)
+++++
unfold Py;uniformize_dir_seg;basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.

*****
H2 : per A F B
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fplus (Fmult (DSeg B F) (DSeg B F)) (Fmult (DSeg B F) (DSeg B F))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F)))
+++++
unfold per, Py in H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.
unfold per, Py in H2.

*****
H2 : eq\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F B) (DSeg F B)))\n (Fmult (DSeg A B) (DSeg A B))) F0
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fplus (Fmult (DSeg B F) (DSeg B F)) (Fmult (DSeg B F) (DSeg B F))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F)))
+++++
IsoleVar (A**B*A**B) H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.
unfold per, Py in H2.
IsoleVar (A**B*A**B) H2.

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F B) (DSeg F B)))\n F0)
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fplus (Fmult (DSeg B F) (DSeg B F)) (Fmult (DSeg B F) (DSeg B F))) (Fminus (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F)))
+++++
rewrite H2.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.
unfold per, Py in H2.
IsoleVar (A**B*A**B) H2.
rewrite H2.

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F B) (DSeg F B)))\n F0)
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fplus (Fmult (DSeg B F) (DSeg B F)) (Fmult (DSeg B F) (DSeg B F))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg F B) (DSeg F B))) F0) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F)))
+++++
uniformize_dir_seg.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.
unfold per, Py in H2.
IsoleVar (A**B*A**B) H2.
rewrite H2.
uniformize_dir_seg.

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fminus\n (Fplus (Fmult (DSeg A F) (DSeg A F))\n (Fmult (Fopp (DSeg B F)) (Fopp (DSeg B F)))) F0)
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fplus (Fmult (DSeg B F) (DSeg B F)) (Fmult (DSeg B F) (DSeg B F))) (Fminus (Fplus (Fminus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (Fopp (DSeg B F)) (Fopp (DSeg B F)))) F0) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F)))
+++++
basic_simpl.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.
unfold per, Py in H2.
IsoleVar (A**B*A**B) H2.
rewrite H2.
uniformize_dir_seg.
basic_simpl.

*****
H2 : eq (Fmult (DSeg A B) (DSeg A B))\n (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg B F) (DSeg B F)))
T : eq (Fmult (Py A B F) (DSeg B C)) (Fmult (Py A B C) (DSeg B F))
H1 : Col B F C
H0 : not (eq B F)
HF : on_foot F A B C
F : Point
H : not (eq B C)
A,B,C : Point
*****
eq (Fplus (Fmult (DSeg B F) (DSeg B F)) (Fmult (DSeg B F) (DSeg B F))) (Fminus (Fplus (Fplus (Fmult (DSeg A F) (DSeg A F)) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg B F) (DSeg B F))) (Fmult (DSeg A F) (DSeg A F)))
+++++
ring.
-----
Lemma herron_qin : forall A B C, S A B C * S A B C = 1 / (2*2*2*2) * (Py A B A * Py A C A - Py B A C * Py B A C).
Proof.
intros.
cases_equality B C.
subst.
basic_simpl.
uniformize_pys.
basic_simpl.
ring.
elim (proj_ex A B C H).
intros F HF.
cases_equality B F.
subst.
assert (T:=on_foot_area A F C F HF).
field_simplify_eq.
2:repeat apply nonzeromult;auto with Geom.
replace (2 * (2 * (2 * 2)) * S A F C * S A F C) with (2*2*(2 * 2 * S A F C * S A F C)) by ring.
rewrite T.
unfold on_foot in HF.
use HF.
clear H2 H3.
assert (perp F C A F) by auto with Geom.
unfold perp, Py4 in *.
IsoleVar (Py C A F) H1.
replace (Py C A F) with (Py F A C) in H1 by auto with Geom.
rewrite H1.
uniformize_pys.
basic_simpl.
assert (Py A C A = Py A F A + Py F C F).
unfold Py.
basic_simpl.
uniformize_dir_seg.
basic_simpl.
replace (A ** C * A ** C + A ** C * A ** C) with (2*(A**C*A**C)) by ring.
replace (A ** F * A ** F + A ** F * A ** F) with (2*(A ** F * A ** F)) by ring.
replace (C ** F * C ** F + C ** F * C ** F) with (2*(C**F*C**F)) by ring.
replace ( 2 * (A ** F * A ** F) + 2 * (C ** F * C ** F)) with (2*(A ** F * A ** F + C ** F * C ** F)) by ring.
assert (A ** C * A ** C = A ** F * A ** F + C ** F * C ** F).
assert (Py A F C = 0).
replace 0 with (-0) by ring.
rewrite <- H0.
ring.
unfold Py in H2.
uniformize_dir_seg.
basic_simpl.
IsoleVar (A ** F * A ** F + C ** F * C ** F) H2.
rewrite H2.
ring.
rewrite H2;auto.
rewrite H2.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
assert (Col B F C).
unfold on_foot in HF.
use HF;auto with Geom.
assert (T:= l_3_4_b B F C A H1).
replace (Py A B F) with (Py F B F) in T.
replace (Py F B F) with (2*B**F*B**F) in T.
2:unfold Py;uniformize_dir_seg;basic_simpl;ring.
IsoleVar (Py A B C) T.
2:auto with Geom.
replace (2 * B ** F * B ** F * B ** C / B ** F) with ( 2 * B ** F * B ** C) in T.
2:field;auto with Geom.
replace (S A B C * S A B C) with (1/2 *1/2*A**F*A**F*B**C*B**C).
2: replace (1 / 2 * 1/2*A**F*A**F*B**C* B ** C ) with (1/2 * 1/2 * (A ** F * A**F * B ** C *B**C )) by ring.
2: (rewrite <- on_foot_area).
2:field;auto with Geom.
2:auto.
replace ( 1 / 2 * 1/2 * A ** F * A ** F * B ** C * B**C ) with ((1/2)* (A**F * A**F) * (1/2)* (B**C * B**C)) by (field;solve_conds;auto with Geom).
replace (A**F * A**F) with (A**B * A**B - B**F * B**F).
field_simplify_eq.
replace (2 * (2 * (2 * 2)) * B ** F * B ** F * B ** C * B ** C) with ( 2 * 2 * (2*B ** F *B ** C) * (2*B ** F * B ** C)) by ring.
rewrite <- T.
unfold Py.
uniformize_dir_seg.
basic_simpl.
ring.
solve_conds.
assert (per A F B).
apply (on_foot_per A B C F);auto.
unfold per,Py in *.
uniformize_dir_seg.
IsoleVar (A**B*A**B) H3.
rewrite H3.
ring.
assert (per A F B).
apply (on_foot_per A B C F);assumption.
unfold Py;uniformize_dir_seg;basic_simpl.
unfold per, Py in H2.
IsoleVar (A**B*A**B) H2.
rewrite H2.
uniformize_dir_seg.
basic_simpl.
ring.

*****

*****

+++++
Qed.
-----
Lemma l3_9_aux : forall B D P Q R S Y ,\n Col Y B D ->\n B<>D ->\n B ** Y = Q ** S ->\n weak_3_parallelogram B Y S Q ->\n Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.

*****

*****
forall (B D P Q R S Y : Point) (_ : Col Y B D) (_ : not (eq B D)) (_ : eq (DSeg B Y) (DSeg Q S)) (_ : weak_3_parallelogram B Y S Q), eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
+++++
Proof.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.

*****

*****
forall (B D P Q R S Y : Point) (_ : Col Y B D) (_ : not (eq B D)) (_ : eq (DSeg B Y) (DSeg Q S)) (_ : weak_3_parallelogram B Y S Q), eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
+++++
intros.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
+++++
rewrite <- H1.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Py4 P Q R S) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Py4 P B R D))
+++++
replace (Py4 P Q R S) with (Py4 P B R Y).
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Py4 P B R Y) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Py4 P B R D))
+++++
unfold Py4.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Py P B Y) (Py R B Y)) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fmult (Py P B Y) (DSeg B D)) (Fmult (Py P B D) (DSeg B Y))
+++++
apply (l_3_4_b B Y D P).
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
apply (l_3_4_b B Y D P).

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
Col B Y D
+++++
auto with Geom.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).

*****
H3 : eq (Fmult (Py P B Y) (DSeg B D)) (Fmult (Py P B D) (DSeg B Y))
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Py P B Y) (Py R B Y)) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
IsoleVar (Py P B Y) H3.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.

*****
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Py P B Y) (Py R B Y)) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
rewrite H3.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.

*****
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D)) (Py R B Y)) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
assert (Py R B Y * B ** D = Py R B D * B ** Y).
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.
assert (Py R B Y * B ** D = Py R B D * B ** Y).

*****
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fmult (Py R B Y) (DSeg B D)) (Fmult (Py R B D) (DSeg B Y))
+++++
apply (l_3_4_b B Y D R).
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.
assert (Py R B Y * B ** D = Py R B D * B ** Y).
apply (l_3_4_b B Y D R).

*****
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
Col B Y D
+++++
auto with Geom.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.
assert (Py R B Y * B ** D = Py R B D * B ** Y).

*****
H5 : eq (Fmult (Py R B Y) (DSeg B D)) (Fmult (Py R B D) (DSeg B Y))
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D)) (Py R B Y)) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
IsoleVar (Py R B Y) H5.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.
assert (Py R B Y * B ** D = Py R B D * B ** Y).
IsoleVar (Py R B Y) H5.

*****
H5 : eq (Py R B Y) (Fdiv (Fmult (Py R B D) (DSeg B Y)) (DSeg B D))
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D)) (Py R B Y)) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
rewrite H5.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.
assert (Py R B Y * B ** D = Py R B D * B ** Y).
IsoleVar (Py R B Y) H5.
rewrite H5.

*****
H5 : eq (Py R B Y) (Fdiv (Fmult (Py R B D) (DSeg B Y)) (DSeg B D))
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Fminus (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D)) (Fdiv (Fmult (Py R B D) (DSeg B Y)) (DSeg B D))) (Fmult (Fdiv (DSeg B Y) (DSeg B D)) (Fminus (Py P B D) (Py R B D)))
+++++
field.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.
rewrite H3.
assert (Py R B Y * B ** D = Py R B D * B ** Y).
IsoleVar (Py R B Y) H5.
rewrite H5.
field.

*****
H5 : eq (Py R B Y) (Fdiv (Fmult (Py R B D) (DSeg B Y)) (DSeg B D))
H3 : eq (Py P B Y) (Fdiv (Fmult (Py P B D) (DSeg B Y)) (DSeg B D))
H4 : not (eq (DSeg B D) F0)
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
not (eq (DSeg B D) F0)
+++++
auto with Geom.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
unfold Py4.
assert ( Py P B Y * B ** D = Py P B D * B ** Y).
IsoleVar (Py P B Y) H3.

*****
H3 : eq (Fmult (Py P B Y) (DSeg B D)) (Fmult (Py P B D) (DSeg B Y))
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
not (eq (DSeg B D) F0)
+++++
auto with Geom.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Py4 P B R Y) (Py4 P Q R S)
+++++
replace (Py4 P B R Y) with (Py4 B P Y R) by auto with Geom.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
replace (Py4 P B R Y) with (Py4 B P Y R) by auto with Geom.

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Py4 B P Y R) (Py4 P Q R S)
+++++
rewrite (l_27_b B Y S Q P R H2).
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).
replace (Py4 P B R Y) with (Py4 B P Y R) by auto with Geom.
rewrite (l_27_b B Y S Q P R H2).

*****
H2 : weak_3_parallelogram B Y S Q
H1 : eq (DSeg B Y) (DSeg Q S)
H0 : not (eq B D)
H : Col Y B D
B,D,P,Q,R,S,Y : Point
*****
eq (Py4 Q P S R) (Py4 P Q R S)
+++++
auto with Geom.
-----
Lemma l3_9_aux : forall B D P Q R S Y , Col Y B D -> B<>D -> B ** Y = Q ** S -> weak_3_parallelogram B Y S Q -> Py4 P Q R S = Q ** S / B ** D * Py4 P B R D.
Proof.
intros.
rewrite <- H1.
replace (Py4 P Q R S) with (Py4 P B R Y).

*****

*****

+++++
Qed.
-----
Lemma l3_9 : forall P Q R S A B C D,\n  parallel P R A C ->\n  parallel Q S B D ->\n  B<>D -> A<>C -> ~ perp A C B D ->\n  Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).

*****

*****
forall (P Q R S A B C D : Point) (_ : parallel P R A C) (_ : parallel Q S B D) (_ : not (eq B D)) (_ : not (eq A C)) (_ : not (perp A C B D)), eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
Proof.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.

*****

*****
forall (P Q R S A B C D : Point) (_ : parallel P R A C) (_ : parallel Q S B D) (_ : not (eq B D)) (_ : not (eq A C)) (_ : not (perp A C B D)), eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
intros.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.

*****
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
assert (exists Y : Point, Col Y A C /\ A ** Y = P ** R /\ weak_3_parallelogram A Y R P).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).

*****
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
ex (fun Y : Point => and (Col Y A C) (and (eq (DSeg A Y) (DSeg P R)) (weak_3_parallelogram A Y R P)))
+++++
apply (on_line_dex_spec_strong_f A C P R).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
apply (on_line_dex_spec_strong_f A C P R).

*****
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
parallel A C P R
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
apply (on_line_dex_spec_strong_f A C P R).

*****
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
not (eq A C)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).

*****
H4 : ex\n (fun Y : Point =>\n and (Col Y A C)\n (and (eq (DSeg A Y) (DSeg P R)) (weak_3_parallelogram A Y R P)))
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
elim H4.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.

*****
H4 : ex\n (fun Y : Point =>\n and (Col Y A C)\n (and (eq (DSeg A Y) (DSeg P R)) (weak_3_parallelogram A Y R P)))
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
forall (x : Point) (_ : and (Col x A C) (and (eq (DSeg A x) (DSeg P R)) (weak_3_parallelogram A x R P))), eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
intros X HX.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.

*****
HX : and (Col X A C)\n (and (eq (DSeg A X) (DSeg P R)) (weak_3_parallelogram A X R P))
X : Point
H4 : ex\n (fun Y : Point =>\n and (Col Y A C)\n (and (eq (DSeg A Y) (DSeg P R)) (weak_3_parallelogram A Y R P)))
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
clear H4.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.

*****
HX : and (Col X A C)\n (and (eq (DSeg A X) (DSeg P R)) (weak_3_parallelogram A X R P))
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
use HX.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.

*****
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
assert (exists Y : Point, Col Y B D /\ B ** Y = Q ** S /\ weak_3_parallelogram B Y S Q).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).

*****
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
ex (fun Y : Point => and (Col Y B D) (and (eq (DSeg B Y) (DSeg Q S)) (weak_3_parallelogram B Y S Q)))
+++++
apply (on_line_dex_spec_strong_f B D Q S).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
apply (on_line_dex_spec_strong_f B D Q S).

*****
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
parallel B D Q S
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
apply (on_line_dex_spec_strong_f B D Q S).

*****
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
not (eq B D)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).

*****
H5 : ex\n (fun Y : Point =>\n and (Col Y B D)\n (and (eq (DSeg B Y) (DSeg Q S)) (weak_3_parallelogram B Y S Q)))
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
elim H5.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.

*****
H5 : ex\n (fun Y : Point =>\n and (Col Y B D)\n (and (eq (DSeg B Y) (DSeg Q S)) (weak_3_parallelogram B Y S Q)))
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
forall (x : Point) (_ : and (Col x B D) (and (eq (DSeg B x) (DSeg Q S)) (weak_3_parallelogram B x S Q))), eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
intros Y HY.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.

*****
HY : and (Col Y B D)\n (and (eq (DSeg B Y) (DSeg Q S)) (weak_3_parallelogram B Y S Q))
Y : Point
H5 : ex\n (fun Y : Point =>\n and (Col Y B D)\n (and (eq (DSeg B Y) (DSeg Q S)) (weak_3_parallelogram B Y S Q)))
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
clear H5.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.

*****
HY : and (Col Y B D)\n (and (eq (DSeg B Y) (DSeg Q S)) (weak_3_parallelogram B Y S Q))
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
use HY.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.

*****
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).

*****
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
+++++
eapply l3_9_aux with (Y:=Y).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
eapply l3_9_aux with (Y:=Y).

*****
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
Col Y B D
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
eapply l3_9_aux with (Y:=Y).

*****
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
not (eq B D)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
eapply l3_9_aux with (Y:=Y).

*****
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (DSeg B Y) (DSeg Q S)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
eapply l3_9_aux with (Y:=Y).

*****
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
weak_3_parallelogram B Y S Q
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).

*****
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).

*****
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
+++++
replace (Py4 P B R D) with (Py4 B P D R) by auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
replace (Py4 P B R D) with (Py4 B P D R) by auto with Geom.

*****
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Py4 B P D R) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
+++++
rewrite (l3_9_aux A C B P D R X H4 H2 H6 H7).
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
replace (Py4 P B R D) with (Py4 B P D R) by auto with Geom.
rewrite (l3_9_aux A C B P D R X H4 H2 H6 H7).

*****
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 B A D C)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
+++++
replace (Py4 B A D C) with (Py4 A B C D) by auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
replace (Py4 P B R D) with (Py4 B P D R) by auto with Geom.
rewrite (l3_9_aux A C B P D R X H4 H2 H6 H7).
replace (Py4 B A D C) with (Py4 A B C D) by auto with Geom.

*****
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
+++++
field.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
replace (Py4 P B R D) with (Py4 B P D R) by auto with Geom.
rewrite (l3_9_aux A C B P D R X H4 H2 H6 H7).
replace (Py4 B A D C) with (Py4 A B C D) by auto with Geom.
field.

*****
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
not (eq (DSeg A C) F0)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).

*****
Hb : eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Py4 P Q R S) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
rewrite Ha.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
rewrite Ha.

*****
Hb : eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D)) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
rewrite Hb.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
rewrite Ha.
rewrite Hb.

*****
Hb : eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
eq (Fdiv (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))) (Py4 A B C D)) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Fdiv (DSeg Q S) (DSeg B D)))
+++++
field.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
rewrite Ha.
rewrite Hb.
field.

*****
Hb : eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
and (not (eq (DSeg B D) F0)) (and (not (eq (DSeg A C) F0)) (not (eq (Py4 A B C D) F0)))
+++++
solve_conds.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
rewrite Ha.
rewrite Hb.
field.
solve_conds.

*****
Hb : eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
not (eq (DSeg B D) F0)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).
elim H4.
intros X HX.
clear H4.
use HX.
assert (exists Y : Point, Col Y B D /\\ B ** Y = Q ** S /\\ weak_3_parallelogram B Y S Q).
elim H5.
intros Y HY.
clear H5.
use HY.
assert (Ha:Py4 P Q R S = Q**S / B**D * Py4 P B R D).
assert (Hb:Py4 P B R D = P**R / A**C * Py4 A B C D).
rewrite Ha.
rewrite Hb.
field.
solve_conds.

*****
Hb : eq (Py4 P B R D) (Fmult (Fdiv (DSeg P R) (DSeg A C)) (Py4 A B C D))
Ha : eq (Py4 P Q R S) (Fmult (Fdiv (DSeg Q S) (DSeg B D)) (Py4 P B R D))
H10 : weak_3_parallelogram B Y S Q
H9 : eq (DSeg B Y) (DSeg Q S)
H5 : Col Y B D
Y : Point
H7 : weak_3_parallelogram A X R P
H6 : eq (DSeg A X) (DSeg P R)
H4 : Col X A C
X : Point
H3 : not (perp A C B D)
H2 : not (eq A C)
H1 : not (eq B D)
H0 : parallel Q S B D
H : parallel P R A C
P,Q,R,S,A,B,C,D : Point
*****
not (eq (DSeg A C) F0)
+++++
auto with Geom.
-----
Lemma l3_9 : forall P Q R S A B C D, parallel P R A C -> parallel Q S B D -> B<>D -> A<>C -> ~ perp A C B D -> Py4 P Q R S / Py4 A B C D = (P**R / A**C) * (Q**S / B**D).
Proof.
intros.
assert (exists Y : Point, Col Y A C /\\ A ** Y = P ** R /\\ weak_3_parallelogram A Y R P).

*****

*****

+++++
Qed.
-----
Lemma l3_10 : forall A B C D,\n parallel A B C D ->\n C<>D ->\n A**B/C**D = Py4 A C B D / - Py C D C.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D) (_ : not (eq C D)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
+++++
Proof.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D) (_ : not (eq C D)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
+++++
intros.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
+++++
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fmult (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (DSeg C D) (DSeg C D))) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
+++++
rewrite <- (l3_9 A C B D C C D D).
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Py4 A C B D) (Py4 C C D D)) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Py4 A C B D) (Py4 C C D D)) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
+++++
unfold Py4.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold Py4.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fminus (Py A C D) (Py B C D)) (Fminus (Py C C D) (Py D C D))) (Fdiv (Fminus (Py A C D) (Py B C D)) (Fopp (Py C D C)))
+++++
basic_simpl.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold Py4.
basic_simpl.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fminus (Py A C D) (Py B C D)) (Fminus F0 (Py D C D))) (Fdiv (Fminus (Py A C D) (Py B C D)) (Fopp (Py C D C)))
+++++
uniformize_pys.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold Py4.
basic_simpl.
uniformize_pys.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Fminus (Py A C D) (Py B C D)) (Fminus F0 (Py C D C))) (Fdiv (Fminus (Py A C D) (Py B C D)) (Fopp (Py C D C)))
+++++
field.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold Py4.
basic_simpl.
uniformize_pys.
field.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Fopp (Py C D C)) F0)
+++++
cut (Py C D C <> 0).
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold Py4.
basic_simpl.
uniformize_pys.
field.
cut (Py C D C <> 0).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
forall _ : not (eq (Py C D C) F0), not (eq (Fopp (Py C D C)) F0)
+++++
intuition.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold Py4.
basic_simpl.
uniformize_pys.
field.
cut (Py C D C <> 0).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Py C D C) F0)
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
parallel A B C D
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
parallel C D C D
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq C D)
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq C D)
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (perp C D C D)
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (perp C D C D)
+++++
unfold perp.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Py4 C C D D) F0)
+++++
unfold Py4.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Fminus (Py C C D) (Py D C D)) F0)
+++++
basic_simpl.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Fminus F0 (Py D C D)) F0)
+++++
intro.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.

*****
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
False
+++++
assert (Py D C D = 0).
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.
assert (Py D C D = 0).

*****
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Py D C D) F0
+++++
replace (0) with (-0) by ring.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.
assert (Py D C D = 0).
replace (0) with (-0) by ring.

*****
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Py D C D) (Fopp F0)
+++++
rewrite <- H1.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.
assert (Py D C D = 0).
replace (0) with (-0) by ring.
rewrite <- H1.

*****
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Py D C D) (Fopp (Fminus F0 (Py D C D)))
+++++
ring.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.
assert (Py D C D = 0).

*****
H2 : eq (Py D C D) F0
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
False
+++++
assert (D=C).
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.
assert (Py D C D = 0).
assert (D=C).

*****
H2 : eq (Py D C D) F0
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq D C
+++++
auto with Geom.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).
auto with Geom.
unfold perp.
unfold Py4.
basic_simpl.
intro.
assert (Py D C D = 0).
assert (D=C).

*****
H3 : eq D C
H2 : eq (Py D C D) F0
H1 : eq (Fminus F0 (Py D C D)) F0
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
False
+++++
intuition.
-----
Lemma l3_10 : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 A C B D / - Py C D C.
Proof.
intros.
replace (A ** B / C ** D) with ((A ** B / C ** D) * (C**D / C**D)) by (field;auto with Geom).
rewrite <- (l3_9 A C B D C C D D).

*****

*****

+++++
Qed.
-----
Lemma l3_10b : forall A B C D,\n parallel A B C D ->\n C<>D ->\n A**B/C**D = Py4 B C A D / Py C D C.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D) (_ : not (eq C D)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 B C A D) (Py C D C))
+++++
Proof.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D) (_ : not (eq C D)), eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 B C A D) (Py C D C))
+++++
intros.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 B C A D) (Py C D C))
+++++
rewrite l3_10.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Py4 A C B D) (Fopp (Py C D C))) (Fdiv (Py4 B C A D) (Py C D C))
+++++
idtac.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.
idtac.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Py4 A C B D) (Fopp (Py C D C))) (Fdiv (Py4 B C A D) (Py C D C))
+++++
replace (Py4 B C A D) with (- Py4 A C B D) by auto with Geom.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.
idtac.
replace (Py4 B C A D) with (- Py4 A C B D) by auto with Geom.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
eq (Fdiv (Py4 A C B D) (Fopp (Py C D C))) (Fdiv (Fopp (Py4 A C B D)) (Py C D C))
+++++
field.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.
idtac.
replace (Py4 B C A D) with (- Py4 A C B D) by auto with Geom.
field.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
and (not (eq (Py C D C) F0)) (not (eq (Fopp (Py C D C)) F0))
+++++
split.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.
idtac.
replace (Py4 B C A D) with (- Py4 A C B D) by auto with Geom.
field.
split.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Py C D C) F0)
+++++
auto with Geom.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.
idtac.
replace (Py4 B C A D) with (- Py4 A C B D) by auto with Geom.
field.
split.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq (Fopp (Py C D C)) F0)
+++++
auto with Geom.
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
parallel A B C D
+++++
assumption .
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.

*****
H0 : not (eq C D)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq C D)
+++++
assumption .
-----
Lemma l3_10b : forall A B C D, parallel A B C D -> C<>D -> A**B/C**D = Py4 B C A D / Py C D C.
Proof.
intros.
rewrite l3_10.

*****

*****

+++++
Qed.
-----
Lemma perp_not_parallel : forall A B C D,\n  perp A B C D ->\n  A <> B -> C <> D ->\n  ~ parallel A B C D.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.

*****

*****
forall (A B C D : Point) (_ : perp A B C D) (_ : not (eq A B)) (_ : not (eq C D)), not (parallel A B C D)
+++++
Proof.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.

*****

*****
forall (A B C D : Point) (_ : perp A B C D) (_ : not (eq A B)) (_ : not (eq C D)), not (parallel A B C D)
+++++
intros.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.

*****
H1 : not (eq C D)
H0 : not (eq A B)
H : perp A B C D
A,B,C,D : Point
*****
not (parallel A B C D)
+++++
unfold perp in H.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.

*****
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
not (parallel A B C D)
+++++
intro.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.

*****
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
assert (T:=l3_10 A B C D H2 H1).
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).

*****
T : eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv (Py4 A C B D) (Fopp (Py C D C)))
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
rewrite H in T.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.

*****
T : eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv F0 (Fopp (Py C D C)))
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
IsoleVar (A**B) T.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.

*****
T : eq (DSeg A B) (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
replace (C ** D * (0 / - Py C D C)) with 0 in T.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.

*****
T : eq (DSeg A B) F0
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
assert (A=B).
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
assert (A=B).

*****
T : eq (DSeg A B) F0
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
eq A B
+++++
auto with Geom.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
assert (A=B).

*****
H4 : eq A B
T : eq (DSeg A B) F0
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
idtac.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
assert (A=B).
idtac.

*****
H4 : eq A B
T : eq (DSeg A B) F0
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
False
+++++
subst A.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
assert (A=B).
idtac.
subst A.

*****
T : eq (DSeg B B) F0
H3 : not (eq (DSeg C D) F0)
H2 : parallel B B C D
H1 : not (eq C D)
H : eq (Py4 B C B D) F0
H0 : not (eq B B)
B,C,D : Point
*****
False
+++++
intuition.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.

*****
T : eq (DSeg A B) (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
eq F0 (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
+++++
field.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
field.

*****
T : eq (DSeg A B) (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
not (eq (Fopp (Py C D C)) F0)
+++++
cut (Py C D C <> 0).
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
field.
cut (Py C D C <> 0).

*****
T : eq (DSeg A B) (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
forall _ : not (eq (Py C D C) F0), not (eq (Fopp (Py C D C)) F0)
+++++
intro.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
field.
cut (Py C D C <> 0).
intro.

*****
H4 : not (eq (Py C D C) F0)
T : eq (DSeg A B) (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
not (eq (Fopp (Py C D C)) F0)
+++++
intuition.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.
replace (C ** D * (0 / - Py C D C)) with 0 in T.
field.
cut (Py C D C <> 0).

*****
T : eq (DSeg A B) (Fmult (DSeg C D) (Fdiv F0 (Fopp (Py C D C))))
H3 : not (eq (DSeg C D) F0)
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
not (eq (Py C D C) F0)
+++++
auto with Geom.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.

*****
T : eq (Fdiv (DSeg A B) (DSeg C D)) (Fdiv F0 (Fopp (Py C D C)))
H2 : parallel A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : eq (Py4 A C B D) F0
A,B,C,D : Point
*****
not (eq (DSeg C D) F0)
+++++
auto with Geom.
-----
Lemma perp_not_parallel : forall A B C D, perp A B C D -> A <> B -> C <> D -> ~ parallel A B C D.
Proof.
intros.
unfold perp in H.
intro.
assert (T:=l3_10 A B C D H2 H1).
rewrite H in T.
IsoleVar (A**B) T.

*****

*****

+++++
Qed.
-----
Lemma not_perp_to_itself : forall A B,\nA <> B ->~ perp A B A B.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.

*****

*****
forall (A B : Point) (_ : not (eq A B)), not (perp A B A B)
+++++
Proof.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.

*****

*****
forall (A B : Point) (_ : not (eq A B)), not (perp A B A B)
+++++
intros.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.

*****
H : not (eq A B)
A,B : Point
*****
not (perp A B A B)
+++++
unfold perp in *.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.

*****
H : not (eq A B)
A,B : Point
*****
not (eq (Py4 A A B B) F0)
+++++
unfold Py4 in *.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.

*****
H : not (eq A B)
A,B : Point
*****
not (eq (Fminus (Py A A B) (Py B A B)) F0)
+++++
basic_simpl.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.

*****
H : not (eq A B)
A,B : Point
*****
not (eq (Fminus F0 (Py B A B)) F0)
+++++
intro.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.

*****
H0 : eq (Fminus F0 (Py B A B)) F0
H : not (eq A B)
A,B : Point
*****
False
+++++
IsoleVar (Py B A B) H0.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.

*****
H0 : eq (Py B A B) (Fminus F0 F0)
H : not (eq A B)
A,B : Point
*****
False
+++++
basic_simpl.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.

*****
H0 : eq (Py B A B) F0
H : not (eq A B)
A,B : Point
*****
False
+++++
assert (A=B).
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).

*****
H0 : eq (Py B A B) F0
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
unfold Py in *.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.

*****
H0 : eq\n (Fminus\n (Fplus (Fmult (DSeg B A) (DSeg B A)) (Fmult (DSeg A B) (DSeg A B)))\n (Fmult (DSeg B B) (DSeg B B))) F0
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
uniformize_dir_seg.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.

*****
H0 : eq\n (Fminus\n (Fplus (Fmult (Fopp (DSeg A B)) (Fopp (DSeg A B)))\n (Fmult (DSeg A B) (DSeg A B))) (Fmult (DSeg B B) (DSeg B B)))\n F0
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
basic_simpl.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.

*****
H0 : eq (Fplus (Fmult (DSeg A B) (DSeg A B)) (Fmult (DSeg A B) (DSeg A B)))\n F0
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.

*****
H0 : eq (Fmult (Fplus F1 F1) (Fmult (DSeg A B) (DSeg A B))) F0
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
IsoleVar (A ** B) H0.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.

*****
H0 : eq (DSeg A B) (Fdiv (Fdiv F0 (Fplus F1 F1)) (DSeg A B))
H2 : not (eq (DSeg A B) F0)
H1 : not (eq (Fplus F1 F1) F0)
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
replace (0 / 2 / A ** B) with 0 in *.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.
replace (0 / 2 / A ** B) with 0 in *.

*****
H0 : eq (DSeg A B) F0
H2 : not (eq (DSeg A B) F0)
H1 : not (eq (Fplus F1 F1) F0)
H : not (eq A B)
A,B : Point
*****
eq A B
+++++
auto with Geom.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.
replace (0 / 2 / A ** B) with 0 in *.

*****
H0 : eq (DSeg A B) (Fdiv (Fdiv F0 (Fplus F1 F1)) (DSeg A B))
H2 : not (eq (DSeg A B) F0)
H1 : not (eq (Fplus F1 F1) F0)
H : not (eq A B)
A,B : Point
*****
eq F0 (Fdiv (Fdiv F0 (Fplus F1 F1)) (DSeg A B))
+++++
field.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.
replace (0 / 2 / A ** B) with 0 in *.
field.

*****
H0 : eq (DSeg A B) (Fdiv (Fdiv F0 (Fplus F1 F1)) (DSeg A B))
H2 : not (eq (DSeg A B) F0)
H1 : not (eq (Fplus F1 F1) F0)
H : not (eq A B)
A,B : Point
*****
and (not (eq (Fplus F1 F1) F0)) (not (eq (DSeg A B) F0))
+++++
split.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.
replace (0 / 2 / A ** B) with 0 in *.
field.
split.

*****
H0 : eq (DSeg A B) (Fdiv (Fdiv F0 (Fplus F1 F1)) (DSeg A B))
H2 : not (eq (DSeg A B) F0)
H1 : not (eq (Fplus F1 F1) F0)
H : not (eq A B)
A,B : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.
replace (0 / 2 / A ** B) with 0 in *.
field.
split.

*****
H0 : eq (DSeg A B) (Fdiv (Fdiv F0 (Fplus F1 F1)) (DSeg A B))
H2 : not (eq (DSeg A B) F0)
H1 : not (eq (Fplus F1 F1) F0)
H : not (eq A B)
A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.

*****
H1 : not (eq (Fplus F1 F1) F0)
H0 : eq (Fmult (Fplus F1 F1) (Fmult (DSeg A B) (DSeg A B))) F0
H : not (eq A B)
A,B : Point
*****
not (eq (DSeg A B) F0)
+++++
auto with Geom.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).
unfold Py in *.
uniformize_dir_seg.
basic_simpl.
replace (A ** B * A ** B + A ** B * A ** B) with (2*(A ** B * A ** B)) in * by ring.
IsoleVar (A ** B) H0.

*****
H0 : eq (Fmult (Fplus F1 F1) (Fmult (DSeg A B) (DSeg A B))) F0
H : not (eq A B)
A,B : Point
*****
not (eq (Fplus F1 F1) F0)
+++++
auto with Geom.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).

*****
H1 : eq A B
H0 : eq (Py B A B) F0
H : not (eq A B)
A,B : Point
*****
False
+++++
intuition.
-----
Lemma not_perp_to_itself : forall A B, A <> B ->~ perp A B A B.
Proof.
intros.
unfold perp in *.
unfold Py4 in *.
basic_simpl.
intro.
IsoleVar (Py B A B) H0.
basic_simpl.
assert (A=B).

*****

*****

+++++
Qed.
-----
Lemma parallel_not_perp : forall A B C D,\n  parallel A B C D ->\n  A <> B -> C <> D ->\n  ~ perp A B C D.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D) (_ : not (eq A B)) (_ : not (eq C D)), not (perp A B C D)
+++++
Proof.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.

*****

*****
forall (A B C D : Point) (_ : parallel A B C D) (_ : not (eq A B)) (_ : not (eq C D)), not (perp A B C D)
+++++
intros.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.

*****
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
not (perp A B C D)
+++++
intro.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.

*****
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
False
+++++
assert (perp C D C D).
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).

*****
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
perp C D C D
+++++
apply (perp_para_perp A B C D C D).
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).
apply (perp_para_perp A B C D C D).

*****
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq A B)
+++++
assumption.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).
apply (perp_para_perp A B C D C D).

*****
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
perp A B C D
+++++
assumption.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).
apply (perp_para_perp A B C D C D).

*****
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
parallel A B C D
+++++
assumption.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).

*****
H3 : perp C D C D
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
False
+++++
apply (not_perp_to_itself C D).
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).
apply (not_perp_to_itself C D).

*****
H3 : perp C D C D
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
not (eq C D)
+++++
auto.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).
apply (not_perp_to_itself C D).

*****
H3 : perp C D C D
H2 : perp A B C D
H1 : not (eq C D)
H0 : not (eq A B)
H : parallel A B C D
A,B,C,D : Point
*****
perp C D C D
+++++
auto.
-----
Lemma parallel_not_perp : forall A B C D, parallel A B C D -> A <> B -> C <> D -> ~ perp A B C D.
Proof.
intros.
intro.
assert (perp C D C D).

*****

*****

+++++
Qed.
-----
Lemma l_25_a : forall A B P Q Y,\n  P<>Q -> Q<>Y -> Py Q A B <> 0 ->\n on_inter_line_perp Y A P Q A B ->\n P**Y / Q**Y = Py P A B / Py Q A B.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.

*****

*****
forall (A B P Q Y : Point) (_ : not (eq P Q)) (_ : not (eq Q Y)) (_ : not (eq (Py Q A B) F0)) (_ : on_inter_line_perp Y A P Q A B), eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
Proof.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.

*****

*****
forall (A B P Q Y : Point) (_ : not (eq P Q)) (_ : not (eq Q Y)) (_ : not (eq (Py Q A B) F0)) (_ : on_inter_line_perp Y A P Q A B), eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
intros.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.

*****
H2 : on_inter_line_perp Y A P Q A B
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
unfold on_inter_line_perp in *.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.

*****
H2 : and (Col Y P Q) (and (perp Y A A B) (not (perp A B P Q)))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
use H2.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
assert (A<>B).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq A B)
+++++
intro.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
intro.

*****
H2 : eq A B
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
False
+++++
subst.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
intro.
subst.

*****
H5 : perp Y B B B
H6 : not (perp B B P Q)
H3 : Col Y P Q
H1 : not (eq (Py Q B B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
False
+++++
basic_simpl.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
intro.
subst.
basic_simpl.

*****
H5 : perp Y B B B
H6 : not (perp B B P Q)
H3 : Col Y P Q
H1 : not (eq F0 F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
False
+++++
intuition.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).

*****
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
elim (proj_ex P A B H2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).

*****
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
forall (x : Point) (_ : on_foot x P A B), eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
intros P1 HP1.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.

*****
HP1 : on_foot P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
unfold on_foot in *.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.

*****
HP1 : and (perp P1 P A B) (and (Col P1 A B) (not (eq A B)))
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
use HP1.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.

*****
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
elim (proj_ex Q A B H2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).

*****
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
forall (x : Point) (_ : on_foot x Q A B), eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
intros P2 HP2.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.

*****
HP2 : on_foot P2 Q A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
unfold on_foot in *.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.

*****
HP2 : and (perp P2 Q A B) (and (Col P2 A B) (not (eq A B)))
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
use HP2.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.

*****
H12 : not (eq A B)
H11 : Col P2 A B
H7 : perp P2 Q A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
assert (Pa:=H5).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).

*****
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
H7 : perp P2 Q A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
assert (Pb:=H4).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).

*****
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
H7 : perp P2 Q A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
assert (Pc:=H7).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).

*****
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
H7 : perp P2 Q A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : perp P1 P A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
unfold perp in H4, H5, H7.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.

*****
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
H7 : eq (Py4 P2 A Q B) F0
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : eq (Py4 P1 A P B) F0
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py4 Y A A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
unfold Py4 in H4, H5, H7.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.

*****
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
H7 : eq (Fminus (Py P2 A B) (Py Q A B)) F0
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
H4 : eq (Fminus (Py P1 A B) (Py P A B)) F0
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Fminus (Py Y A B) (Py A A B)) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
IsoleVar (Py P A B) H4.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.

*****
H4 : eq (Py P A B) (Fminus (Py P1 A B) F0)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
H7 : eq (Fminus (Py P2 A B) (Py Q A B)) F0
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Fminus (Py Y A B) (Py A A B)) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
IsoleVar (Py Q A B) H7.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.

*****
H7 : eq (Py Q A B) (Fminus (Py P2 A B) F0)
H4 : eq (Py P A B) (Fminus (Py P1 A B) F0)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Fminus (Py Y A B) (Py A A B)) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
basic_simpl.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
+++++
rewrite H4.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P1 A B) (Py Q A B))
+++++
rewrite H7.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P1 A B) (Py P2 A B))
+++++
rewrite col_pyth.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A P1)) (DSeg A B)) (Py P2 A B))
+++++
idtac.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A P1)) (DSeg A B)) (Py P2 A B))
+++++
assert (A<>P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq A P2)
+++++
intro.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
intro.

*****
H10 : eq A P2
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
False
+++++
subst.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
intro.
subst.

*****
H8 : Col P1 P2 B
H9 : not (eq P2 B)
H5 : eq (Py Y P2 B) F0
H6 : not (perp P2 B P Q)
H2 : not (eq P2 B)
H3 : Col Y P Q
H1 : not (eq (Py Q P2 B) F0)
H11 : Col P2 P2 B
H12 : not (eq P2 B)
Pa : perp Y P2 P2 B
Pb : perp P1 P P2 B
Pc : perp P2 Q P2 B
H4 : eq (Py P P2 B) (Py P1 P2 B)
P1 : Point
H7 : eq (Py Q P2 B) (Py P2 P2 B)
P2 : Point
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
False
+++++
basic_simpl.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
intro.
subst.
basic_simpl.

*****
H8 : Col P1 P2 B
H9 : not (eq P2 B)
H5 : eq (Py Y P2 B) F0
H6 : not (perp P2 B P Q)
H2 : not (eq P2 B)
H3 : Col Y P Q
H1 : not (eq (Py Q P2 B) F0)
H11 : Col P2 P2 B
H12 : not (eq P2 B)
Pa : perp Y P2 P2 B
Pb : perp P1 P P2 B
Pc : perp P2 Q P2 B
H4 : eq (Py P P2 B) (Py P1 P2 B)
P1 : Point
H7 : eq (Py Q P2 B) F0
P2 : Point
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
False
+++++
intuition.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).

*****
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A P1)) (DSeg A B)) (Py P2 A B))
+++++
rewrite col_pyth.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.

*****
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A P1)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg A P2)) (DSeg A B)))
+++++
idtac.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.

*****
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fmult (Fmult (Fplus F1 F1) (DSeg A P1)) (DSeg A B)) (Fmult (Fmult (Fplus F1 F1) (DSeg A P2)) (DSeg A B)))
+++++
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).

*****
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg A P1) (DSeg A P2))
+++++
assert (parallel P P1 Y A).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).

*****
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
parallel P P1 Y A
+++++
assert (T:=perp_perp_para Y A A B P1 P H12 Pa Pb).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (T:=perp_perp_para Y A A B P1 P H12 Pa Pb).

*****
T : parallel Y A P1 P
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
parallel P P1 Y A
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).

*****
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg A P1) (DSeg A P2))
+++++
assert (parallel Y A Q P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).

*****
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
parallel Y A Q P2
+++++
apply (perp_perp_para Y A A B Q P2 H12 Pa).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
apply (perp_perp_para Y A A B Q P2 H12 Pa).

*****
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
perp Q P2 A B
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).

*****
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg A P1) (DSeg A P2))
+++++
cases_equality A Y.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.

*****
H15 : eq A Y
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg A P1) (DSeg A P2))
+++++
subst.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.

*****
H11 : Col P2 Y B
H12 : not (eq Y B)
Pa : perp Y Y Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
H13 : parallel P P1 Y Y
H14 : parallel Y Y Q P2
P2 : Point
H8 : Col P1 Y B
H9 : not (eq Y B)
P1 : Point
H5 : eq (Py Y Y B) F0
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
clear H13 H14 Pa H5 H9 H12.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.

*****
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
assert (parallel P1 P P2 Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).

*****
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
parallel P1 P P2 Q
+++++
apply (perp_perp_para P1 P Y B P2 Q H2 Pb Pc).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).

*****
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
cases_col Y Q P2.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.

*****
H9 : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
rename H9 into HCol.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
assert (parallel P Q P2 Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
parallel P Q P2 Q
+++++
unfold parallel.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S4 P P2 Q Q) F0
+++++
unfold S4.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fplus (S P P2 Q) (S P Q Q)) F0
+++++
basic_simpl.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S P P2 Q) F0
+++++
assert (Col Q P P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Q P P2
+++++
apply (col_trans_1 Q Y P P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).
apply (col_trans_1 Q Y P P2).

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq Q Y)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).
apply (col_trans_1 Q Y P P2).

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Q Y P
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).
apply (col_trans_1 Q Y P P2).

*****
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Q Y P2
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).

*****
H9 : Col Q P P2
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S P P2 Q) F0
+++++
assert (Col P P2 Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).
assert (Col P P2 Q).

*****
H9 : Col Q P P2
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col P P2 Q
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
unfold parallel.
unfold S4.
basic_simpl.
assert (Col Q P P2).
assert (Col P P2 Q).

*****
H12 : Col P P2 Q
H9 : Col Q P P2
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S P P2 Q) F0
+++++
auto.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).

*****
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
cases_equality P2 Q.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.

*****
H12 : eq P2 Q
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
subst.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.

*****
H11 : Col Q Y B
H5 : parallel P1 P Q Q
HCol : Col Y Q Q
H9 : parallel P Q Q Q
Pb : perp P1 P Y B
Pc : perp Q Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H7 : eq (Py Q Y B) (Py Q Y B)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
clear H9 H5 H7 Pc.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.

*****
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
assert (Col Y P B).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).

*****
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y P B
+++++
apply (col_trans_1 Y Q P B).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
apply (col_trans_1 Y Q P B).

*****
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq Y Q)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
apply (col_trans_1 Y Q P B).

*****
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y Q P
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
apply (col_trans_1 Y Q P B).

*****
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y Q B
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
assert (parallel P1 P Y B).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
parallel P1 P Y B
+++++
cut (parallel Y B P1 P).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
forall _ : parallel Y B P1 P, parallel P1 P Y B
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
parallel Y B P1 P
+++++
unfold parallel.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S4 Y P1 B P) F0
+++++
unfold S4.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fplus (S Y P1 B) (S Y B P)) F0
+++++
assert (Col Y B P).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).

*****
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y B P
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).

*****
H7 : Col Y B P
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fplus (S Y P1 B) (S Y B P)) F0
+++++
idtac.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).
idtac.

*****
H7 : Col Y B P
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fplus (S Y P1 B) (S Y B P)) F0
+++++
rewrite H7.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).
idtac.
rewrite H7.

*****
H7 : Col Y B P
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fplus (S Y P1 B) F0) F0
+++++
basic_simpl.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).
idtac.
rewrite H7.
basic_simpl.

*****
H7 : Col Y B P
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S Y P1 B) F0
+++++
assert (Col Y P1 B).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).
idtac.
rewrite H7.
basic_simpl.
assert (Col Y P1 B).

*****
H7 : Col Y B P
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y P1 B
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cut (parallel Y B P1 P).
unfold parallel.
unfold S4.
assert (Col Y B P).
idtac.
rewrite H7.
basic_simpl.
assert (Col Y P1 B).

*****
H9 : Col Y P1 B
H7 : Col Y B P
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (S Y P1 B) F0
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).

*****
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
cases_equality P1 P.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.

*****
H9 : eq P1 P
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
subst.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
subst.

*****
H7 : parallel P P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
H4 : eq (Py P Y B) (Py P Y B)
Pb : perp P P Y B
H10 : not (eq Y Q)
H8 : Col P Y B
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P) (DSeg Y Q))
+++++
uniformize_dir_seg.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
subst.
uniformize_dir_seg.

*****
H7 : parallel P P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
H4 : eq (Py P Y B) (Py P Y B)
Pb : perp P P Y B
H10 : not (eq Y Q)
H8 : Col P Y B
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fopp (DSeg P Y)) (Fopp (DSeg Q Y)))
+++++
field.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
subst.
uniformize_dir_seg.
field.

*****
H7 : parallel P P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
H4 : eq (Py P Y B) (Py P Y B)
Pb : perp P P Y B
H10 : not (eq Y Q)
H8 : Col P Y B
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
and (not (eq (Fopp (DSeg Q Y)) F0)) (not (eq (DSeg Q Y) F0))
+++++
split.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
subst.
uniformize_dir_seg.
field.
split.

*****
H7 : parallel P P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
H4 : eq (Py P Y B) (Py P Y B)
Pb : perp P P Y B
H10 : not (eq Y Q)
H8 : Col P Y B
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq (Fopp (DSeg Q Y)) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
subst.
uniformize_dir_seg.
field.
split.

*****
H7 : parallel P P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
H4 : eq (Py P Y B) (Py P Y B)
Pb : perp P P Y B
H10 : not (eq Y Q)
H8 : Col P Y B
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq (DSeg Q Y) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.

*****
H9 : not (eq P1 P)
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
cut False.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
cut False.

*****
H9 : not (eq P1 P)
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
forall _ : False, eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y Q))
+++++
intuition.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
cut False.

*****
H9 : not (eq P1 P)
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
False
+++++
apply parallel_not_perp in H7.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
cut False.
apply parallel_not_perp in H7.

*****
H9 : not (eq P1 P)
H7 : not (perp P1 P Y B)
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
False
+++++
intuition.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
cut False.
apply parallel_not_perp in H7.

*****
H9 : not (eq P1 P)
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq P1 P)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
subst.
clear H9 H5 H7 Pc.
assert (Col Y P B).
assert (parallel P1 P Y B).
cases_equality P1 P.
cut False.
apply parallel_not_perp in H7.

*****
H9 : not (eq P1 P)
H7 : parallel P1 P Y B
H5 : Col Y P B
H11 : Col Q Y B
HCol : Col Y Q Q
Pb : perp P1 P Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H10 : not (eq Y Q)
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq Y B)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.

*****
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
assert (perp P Q Y B).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).

*****
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
perp P Q Y B
+++++
apply (perp_para_perp P2 Q Y B P Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).
apply (perp_para_perp P2 Q Y B P Q).

*****
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq P2 Q)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).
apply (perp_para_perp P2 Q Y B P Q).

*****
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
perp P2 Q Y B
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).
apply (perp_para_perp P2 Q Y B P Q).

*****
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
parallel P2 Q P Q
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).

*****
H13 : perp P Q Y B
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
assert (perp Y B P Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).
assert (perp Y B P Q).

*****
H13 : perp P Q Y B
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
perp Y B P Q
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).
assert (perp Y B P Q).

*****
H14 : perp Y B P Q
H13 : perp P Q Y B
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
idtac.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
rename H9 into HCol.
assert (parallel P Q P2 Q).
cases_equality P2 Q.
assert (perp P Q Y B).
assert (perp Y B P Q).
idtac.

*****
H14 : perp Y B P Q
H13 : perp P Q Y B
H12 : not (eq P2 Q)
H9 : parallel P Q P2 Q
HCol : Col Y Q P2
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
intuition.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Y P) (DSeg Y Q)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
apply (thales_2 Y Q P P2 P1).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (Col Y Q P2)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y Q P
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y P2 P1
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).
auto with Geom.

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y P2 P1
+++++
apply (col_trans_1 Y B P2 P1).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).
auto with Geom.
apply (col_trans_1 Y B P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq Y B)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).
auto with Geom.
apply (col_trans_1 Y B P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y B P2
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).
auto with Geom.
apply (col_trans_1 Y B P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
Col Y B P1
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
apply (thales_2 Y Q P P2 P1).

*****
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
parallel Q P2 P P1
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).

*****
H12 : eq (Fdiv (DSeg Y P) (DSeg Y Q)) (Fdiv (DSeg Y P1) (DSeg Y P2))
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P1) (DSeg Y P2))
+++++
rewrite <- H12.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
rewrite <- H12.

*****
H12 : eq (Fdiv (DSeg Y P) (DSeg Y Q)) (Fdiv (DSeg Y P1) (DSeg Y P2))
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg Y P) (DSeg Y Q))
+++++
uniformize_dir_seg.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
rewrite <- H12.
uniformize_dir_seg.

*****
H12 : eq (Fdiv (Fopp (DSeg P Y)) (Fopp (DSeg Q Y)))\n (Fdiv (DSeg Y P1) (DSeg Y P2))
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Fopp (DSeg P Y)) (Fopp (DSeg Q Y)))
+++++
field.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
rewrite <- H12.
uniformize_dir_seg.
field.

*****
H12 : eq (Fdiv (Fopp (DSeg P Y)) (Fopp (DSeg Q Y)))\n (Fdiv (DSeg Y P1) (DSeg Y P2))
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
and (not (eq (Fopp (DSeg Q Y)) F0)) (not (eq (DSeg Q Y) F0))
+++++
split.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
rewrite <- H12.
uniformize_dir_seg.
field.
split.

*****
H12 : eq (Fdiv (Fopp (DSeg P Y)) (Fopp (DSeg Q Y)))\n (Fdiv (DSeg Y P1) (DSeg Y P2))
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq (Fopp (DSeg Q Y)) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
subst.
clear H13 H14 Pa H5 H9 H12.
assert (parallel P1 P P2 Q).
cases_col Y Q P2.
assert (Y ** P / Y ** Q = Y ** P1 / Y ** P2).
rewrite <- H12.
uniformize_dir_seg.
field.
split.

*****
H12 : eq (Fdiv (Fopp (DSeg P Y)) (Fopp (DSeg Q Y)))\n (Fdiv (DSeg Y P1) (DSeg Y P2))
H9 : not (Col Y Q P2)
H5 : parallel P1 P P2 Q
H11 : Col P2 Y B
Pb : perp P1 P Y B
Pc : perp P2 Q Y B
H4 : eq (Py P Y B) (Py P1 Y B)
H7 : eq (Py Q Y B) (Py P2 Y B)
H10 : not (eq Y P2)
P2 : Point
H8 : Col P1 Y B
P1 : Point
H6 : not (perp Y B P Q)
H2 : not (eq Y B)
H3 : Col Y P Q
H1 : not (eq (Py Q Y B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
B,P,Q,Y : Point
*****
not (eq (DSeg Q Y) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (DSeg A P1) (DSeg A P2))
+++++
rewrite (l1_25 P Y Q P1 A P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P1 A) (DSeg P2 A)) (Fdiv (DSeg A P1) (DSeg A P2))
+++++
uniformize_dir_seg.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
uniformize_dir_seg.

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P1 A) (DSeg P2 A)) (Fdiv (Fopp (DSeg P1 A)) (Fopp (DSeg P2 A)))
+++++
field.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
uniformize_dir_seg.
field.

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
and (not (eq (Fopp (DSeg P2 A)) F0)) (not (eq (DSeg P2 A) F0))
+++++
solve_conds.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
uniformize_dir_seg.
field.
solve_conds.

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fopp (DSeg P2 A)) F0)
+++++
cut (P2**A<>0).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
uniformize_dir_seg.
field.
solve_conds.
cut (P2**A<>0).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
forall _ : not (eq (DSeg P2 A) F0), not (eq (Fopp (DSeg P2 A)) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
uniformize_dir_seg.
field.
solve_conds.
cut (P2**A<>0).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg P2 A) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
uniformize_dir_seg.
field.
solve_conds.

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg P2 A) F0)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (Col Q Y A)
+++++
intro.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
False
+++++
assert (per B A Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
per B A Q
+++++
apply (perp_col_perp B A Y Q).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
apply (perp_col_perp B A Y Q).

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq A Y)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
apply (perp_col_perp B A Y Q).

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
per B A Y
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
apply (perp_col_perp B A Y Q).
auto with Geom.

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
per B A Y
+++++
unfold per.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
apply (perp_col_perp B A Y Q).
auto with Geom.
unfold per.

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Py B A Y) F0
+++++
replace (Py B A Y) with (Py Y A B) by auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
apply (perp_col_perp B A Y Q).
auto with Geom.
unfold per.
replace (Py B A Y) with (Py Y A B) by auto with Geom.

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Py Y A B) F0
+++++
auto.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
apply (perp_col_perp B A Y Q).

*****
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col A Y Q
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).

*****
H17 : per B A Q
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
False
+++++
unfold per in H17.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
unfold per in H17.

*****
H17 : eq (Py B A Q) F0
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
False
+++++
replace (Py B A Q) with (Py Q A B) in H17 by auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
intro.
assert (per B A Q).
unfold per in H17.
replace (Py B A Q) with (Py Q A B) in H17 by auto with Geom.

*****
H17 : eq (Py Q A B) F0
H16 : Col Q Y A
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
False
+++++
intuition.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col P Y Q
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col P1 A P2
+++++
assert (Col A P1 P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
assert (Col A P1 P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col A P1 P2
+++++
apply (col_trans_1 A B P1 P2).
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
assert (Col A P1 P2).
apply (col_trans_1 A B P1 P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq A B)
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
assert (Col A P1 P2).
apply (col_trans_1 A B P1 P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col A B P1
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
assert (Col A P1 P2).
apply (col_trans_1 A B P1 P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col A B P2
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).
assert (Col A P1 P2).

*****
H16 : Col A P1 P2
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col P1 A P2
+++++
auto with Geom.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
parallel P P1 Y A
+++++
auto.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.
idtac.
replace (2 * A ** P1 * A ** B / (2 * A ** P2 * A ** B)) with (A**P1/A**P2) by (field;repeat split;auto with Geom).
assert (parallel P P1 Y A).
assert (parallel Y A Q P2).
cases_equality A Y.
rewrite (l1_25 P Y Q P1 A P2).

*****
H15 : not (eq A Y)
H14 : parallel Y A Q P2
H13 : parallel P P1 Y A
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
parallel Y A Q P2
+++++
auto.
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.
idtac.
assert (A<>P2).
rewrite col_pyth.

*****
H10 : not (eq A P2)
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col P2 A B
+++++
assumption .
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).
elim (proj_ex P A B H2).
intros P1 HP1.
unfold on_foot in *.
use HP1.
elim (proj_ex Q A B H2).
intros P2 HP2.
unfold on_foot in *.
use HP2.
assert (Pa:=H5).
assert (Pb:=H4).
assert (Pc:=H7).
unfold perp in H4, H5, H7.
unfold Py4 in H4, H5, H7.
IsoleVar (Py P A B) H4.
IsoleVar (Py Q A B) H7.
basic_simpl.
rewrite H4.
rewrite H7.
rewrite col_pyth.

*****
H7 : eq (Py Q A B) (Py P2 A B)
H4 : eq (Py P A B) (Py P1 A B)
Pc : perp P2 Q A B
Pb : perp P1 P A B
Pa : perp Y A A B
H12 : not (eq A B)
H11 : Col P2 A B
P2 : Point
H9 : not (eq A B)
H8 : Col P1 A B
P1 : Point
H2 : not (eq A B)
H6 : not (perp A B P Q)
H5 : eq (Py Y A B) F0
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
Col P1 A B
+++++
assumption .
-----
Lemma l_25_a : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / Q**Y = Py P A B / Py Q A B.
Proof.
intros.
unfold on_inter_line_perp in *.
use H2.
assert (A<>B).

*****

*****

+++++
Qed.
-----
Lemma l_25_b : forall A B P Q Y,\n  P<>Q -> Q<>Y -> Py Q A B <> 0 ->\n on_inter_line_perp Y A P Q A B ->\n P**Y / P**Q = Py P A B / Py4 P A Q B.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.

*****

*****
forall (A B P Q Y : Point) (_ : not (eq P Q)) (_ : not (eq Q Y)) (_ : not (eq (Py Q A B) F0)) (_ : on_inter_line_perp Y A P Q A B), eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
Proof.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.

*****

*****
forall (A B P Q Y : Point) (_ : not (eq P Q)) (_ : not (eq Q Y)) (_ : not (eq (Py Q A B) F0)) (_ : on_inter_line_perp Y A P Q A B), eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
intros.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.

*****
H2 : on_inter_line_perp Y A P Q A B
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).

*****
T : eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
H2 : on_inter_line_perp Y A P Q A B
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
unfold on_inter_line_perp in *.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.

*****
T : eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
H2 : and (Col Y P Q) (and (perp Y A A B) (not (perp A B P Q)))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
use H2.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q Y)) (DSeg Q Y))\n (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg P Y) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (Fplus (DSeg P Q) (DSeg Q Y)) (DSeg P Q)) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fplus (Fdiv (DSeg Q Y) (DSeg P Q)) F1) (Fdiv (Py P A B) (Py4 P A Q B))
+++++
unfold Py4.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fplus (Fdiv (DSeg Q Y) (DSeg P Q)) F1) (Fdiv (Py P A B) (Fminus (Py P A B) (Py Q A B)))
+++++
IsoleVar (Py P A B) T.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fplus (Fdiv (DSeg Q Y) (DSeg P Q)) F1) (Fdiv (Py P A B) (Fminus (Py P A B) (Py Q A B)))
+++++
rewrite T.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fplus (Fdiv (DSeg Q Y) (DSeg P Q)) F1) (Fdiv (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1)) (Fminus (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1)) (Py Q A B)))
+++++
field.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
and (not (eq (DSeg Q Y) F0)) (and (not (eq (Fminus (Fmult (Py Q A B) (Fplus (DSeg P Q) (DSeg Q Y))) (Fmult (Py Q A B) (DSeg Q Y))) F0)) (not (eq (DSeg P Q) F0)))
+++++
repeat split.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg Q Y) F0)
+++++
auto with Geom.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fminus (Fmult (Py Q A B) (Fplus (DSeg P Q) (DSeg Q Y))) (Fmult (Py Q A B) (DSeg Q Y))) F0)
+++++
auto with Geom.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fminus (Fmult (Py Q A B) (Fplus (DSeg P Q) (DSeg Q Y))) (Fmult (Py Q A B) (DSeg Q Y))) F0)
+++++
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fmult (Py Q A B) (DSeg P Q)) F0)
+++++
apply nonzeromult.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.
apply nonzeromult.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Py Q A B) F0)
+++++
auto.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.
apply nonzeromult.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg P Q) F0)
+++++
auto with Geom.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg P Q) F0)
+++++
auto with Geom.
-----
Lemma l_25_b : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> P**Y / P**Q = Py P A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****

*****

+++++
Qed.
-----
Lemma l_25_c : forall A B P Q Y,\n  P<>Q -> Q<>Y -> Py Q A B <> 0 ->\n on_inter_line_perp Y A P Q A B ->\n Q**Y / P**Q = Py Q A B / Py4 P A Q B.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.

*****

*****
forall (A B P Q Y : Point) (_ : not (eq P Q)) (_ : not (eq Q Y)) (_ : not (eq (Py Q A B) F0)) (_ : on_inter_line_perp Y A P Q A B), eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
Proof.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.

*****

*****
forall (A B P Q Y : Point) (_ : not (eq P Q)) (_ : not (eq Q Y)) (_ : not (eq (Py Q A B) F0)) (_ : on_inter_line_perp Y A P Q A B), eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
intros.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.

*****
H2 : on_inter_line_perp Y A P Q A B
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).

*****
T : eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
H2 : on_inter_line_perp Y A P Q A B
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
unfold on_inter_line_perp in *.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.

*****
T : eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
H2 : and (Col Y P Q) (and (perp Y A A B) (not (perp A B P Q)))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
use H2.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fdiv (DSeg P Y) (DSeg Q Y)) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fdiv (Fplus (DSeg P Q) (DSeg Q Y)) (DSeg Q Y))\n (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Py4 P A Q B))
+++++
unfold Py4.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.

*****
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
T : eq (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1) (Fdiv (Py P A B) (Py Q A B))
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Fminus (Py P A B) (Py Q A B)))
+++++
IsoleVar (Py P A B) T.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Fminus (Py P A B) (Py Q A B)))
+++++
rewrite T.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
eq (Fdiv (DSeg Q Y) (DSeg P Q)) (Fdiv (Py Q A B) (Fminus (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1)) (Py Q A B)))
+++++
field.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
and (not (eq (DSeg Q Y) F0)) (and (not (eq (Fminus (Fmult (Py Q A B) (Fplus (DSeg P Q) (DSeg Q Y))) (Fmult (Py Q A B) (DSeg Q Y))) F0)) (not (eq (DSeg P Q) F0)))
+++++
repeat split.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg Q Y) F0)
+++++
auto with Geom.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fminus (Fmult (Py Q A B) (Fplus (DSeg P Q) (DSeg Q Y))) (Fmult (Py Q A B) (DSeg Q Y))) F0)
+++++
auto with Geom.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fminus (Fmult (Py Q A B) (Fplus (DSeg P Q) (DSeg Q Y))) (Fmult (Py Q A B) (DSeg Q Y))) F0)
+++++
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Fmult (Py Q A B) (DSeg P Q)) F0)
+++++
apply nonzeromult.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.
apply nonzeromult.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (Py Q A B) F0)
+++++
auto.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.
auto with Geom.
replace (Py Q A B * (P ** Q + Q ** Y) - Py Q A B * Q ** Y) with (Py Q A B * (P ** Q)) by ring.
apply nonzeromult.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg P Q) F0)
+++++
auto with Geom.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****
T : eq (Py P A B)\n (Fmult (Py Q A B) (Fplus (Fdiv (DSeg P Q) (DSeg Q Y)) F1))
H6 : not (perp A B P Q)
H5 : perp Y A A B
H3 : Col Y P Q
H1 : not (eq (Py Q A B) F0)
H0 : not (eq Q Y)
H : not (eq P Q)
A,B,P,Q,Y : Point
*****
not (eq (DSeg P Q) F0)
+++++
auto with Geom.
-----
Lemma l_25_c : forall A B P Q Y, P<>Q -> Q<>Y -> Py Q A B <> 0 -> on_inter_line_perp Y A P Q A B -> Q**Y / P**Q = Py Q A B / Py4 P A Q B.
Proof.
intros.
assert (T:= l_25_a A B P Q Y H H0 H1 H2).
unfold on_inter_line_perp in *.
use H2.
replace (P**Y) with (P**Q + Q**Y) in T by auto with Geom.
replace ((P ** Q + Q ** Y) / Q ** Y) with (P**Q/Q**Y + 1) in T by (field;auto with Geom).
replace (P**Y) with (P**Q + Q**Y) by auto with Geom.
replace ((P ** Q + Q ** Y) / P ** Q) with (Q**Y/P**Q + 1) by (field;auto with Geom).
unfold Py4.
IsoleVar (Py P A B) T.
rewrite T.
field.
repeat split.

*****

*****

+++++
Qed.
-----
