Require Import GeoCoq.Axioms.continuity_axioms.
-----
Require Import GeoCoq.Tarski_dev.Annexes.circles.
-----
Section Dedekind_circle_circle.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma circle_circle_aux : (forall A B C D P Q,\n  OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B ->\n  OS A C P Q \/ (Col P A C /\ ~ Col Q A C) \/ (~ Col P A C /\ Col Q A C ) ->\n  exists Z : Tpoint, OnCircle Z A B /\ OnCircle Z C D) ->\n  circle_circle.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B) (_ : or (OS A C P Q) (or (and (Col P A C) (not (Col Q A C))) (and (not (Col P A C)) (Col Q A C)))), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D)), circle_circle
+++++
Proof.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B) (_ : or (OS A C P Q) (or (and (Col P A C) (not (Col Q A C))) (and (not (Col P A C)) (Col Q A C)))), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D)), circle_circle
+++++
intro Haux.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.

*****
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
circle_circle
+++++
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\ OnCircle Z C D).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).

*****
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B) (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D)), circle_circle
+++++
-
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-

*****
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B) (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D)), circle_circle
+++++
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.

*****
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HQ' : exists Q', OnCircle Q' C D /\ OutCircle Q' A B /\ Col Q' A C).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).

*****
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q' : Tpoint => and (OnCircle Q' C D) (and (OutCircle Q' A B) (Col Q' A C)))
+++++
destruct (segment_construction A C C D) as [Q' []].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
destruct (segment_construction A C C D) as [Q' []].

*****
H0 : Cong C Q' C D
H : Bet A C Q'
Q' : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Q' : Tpoint => and (OnCircle Q' C D) (and (OutCircle Q' A B) (Col Q' A C)))
+++++
exists Q'.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
destruct (segment_construction A C C D) as [Q' []].
exists Q'.

*****
H0 : Cong C Q' C D
H : Bet A C Q'
Q' : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
and (OnCircle Q' C D) (and (OutCircle Q' A B) (Col Q' A C))
+++++
repeat split; Col.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
destruct (segment_construction A C C D) as [Q' []].
exists Q'.
repeat split; Col.

*****
H0 : Cong C Q' C D
H : Bet A C Q'
Q' : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircle Q' A B
+++++
apply le_transitivity with A Q; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
destruct (segment_construction A C C D) as [Q' []].
exists Q'.
repeat split; Col.
apply le_transitivity with A Q; trivial.

*****
H0 : Cong C Q' C D
H : Bet A C Q'
Q' : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Q A Q'
+++++
apply triangle_inequality with C; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
destruct (segment_construction A C C D) as [Q' []].
exists Q'.
repeat split; Col.
apply le_transitivity with A Q; trivial.
apply triangle_inequality with C; trivial.

*****
H0 : Cong C Q' C D
H : Bet A C Q'
Q' : Tpoint
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Q C Q'
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).

*****
HQ' : ex\n (fun Q' : Tpoint =>\n and (OnCircle Q' C D) (and (OutCircle Q' A B) (Col Q' A C)))
HQOut : OutCircle Q A B
HPIn : InCircle P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
clear dependent Q.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.

*****
HQ' : ex\n (fun Q' : Tpoint =>\n and (OnCircle Q' C D) (and (OutCircle Q' A B) (Col Q' A C)))
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HQ' as [Q [HQOn [HQOut HCol]]].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].

*****
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (cong_dec A P A B).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).

*****
H : Cong A P A B
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists P; split; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.

*****
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (cong_dec A B A Q).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).

*****
H0 : Cong A B A Q
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists Q; Circle.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.

*****
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HPInS : InCircleS P A B) by (split; trivial).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).

*****
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).

*****
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (A <> C).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).

*****
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro; subst C.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
intro; subst C.

*****
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A A
HQOut : OutCircle Q A B
HQOn : OnCircle Q A D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P A D
A,B,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (not_and_lt A B A P); split; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
intro; subst C.
apply (not_and_lt A B A P); split; trivial.

*****
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A A
HQOut : OutCircle Q A B
HQOn : OnCircle Q A D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P A D
A,B,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A B A P
+++++
apply (cong2_lt__lt A B A Q); Cong.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
intro; subst C.
apply (not_and_lt A B A P); split; trivial.
apply (cong2_lt__lt A B A Q); Cong.

*****
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A A
HQOut : OutCircle Q A B
HQOn : OnCircle Q A D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P A D
A,B,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A P
+++++
apply cong_transitivity with A D; Cong.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).

*****
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (C <> D).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).

*****
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C D)
+++++
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.

*****
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].

*****
H3 : Col P A C
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].

*****
HR2 : Cong C R C D
HR1 : Per A C R
R : Tpoint
H3 : Col P A C
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert_diffs.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.

*****
H5 : not (eq A R)
H4 : not (eq C R)
HR2 : Cong C R C D
HR1 : Per A C R
R : Tpoint
H3 : Col P A C
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply per_not_col in HR1; auto.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.

*****
H5 : not (eq A R)
H4 : not (eq C R)
HR2 : Cong C R C D
HR1 : not (Col A C R)
R : Tpoint
H3 : Col P A C
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (circle_cases A B R) as [HOn|HNOn].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].

*****
HOn : OnCircle R A B
H5 : not (eq A R)
H4 : not (eq C R)
HR2 : Cong C R C D
HR1 : not (Col A C R)
R : Tpoint
H3 : Col P A C
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists R; split; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.

*****
HNOn : or (InCircleS R A B) (OutCircleS R A B)
H5 : not (eq A R)
H4 : not (eq C R)
HR2 : Cong C R C D
HR1 : not (Col A C R)
R : Tpoint
H3 : Col P A C
H2 : not (eq C D)
H1 : not (eq A C)
HQOutS : OutCircleS Q A B
HPInS : InCircleS P A B
H0 : not (Cong A B A Q)
H : not (Cong A P A B)
HCol : Col Q A C
HQOut : OutCircle Q A B
HQOn : OnCircle Q C D
Q : Tpoint
HPIn : InCircle P A B
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
Haux' : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.

*****

*****

+++++
-
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-

*****
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B) (_ : Coplanar A C P Q) (_ : or (not (Col P A C)) (not (Col Q A C))), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.

*****
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (col_dec P A C) as [HCol|HNCol].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].

*****
HCol : Col P A C
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HDij.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct HDij.

*****
HCol : Col P A C
H : not (Col P A C)
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
contradiction.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct HDij.
contradiction.

*****
HCol : Col P A C
H : not (Col Q A C)
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply Haux with P Q; auto.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].

*****
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (col_dec Q A C).
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).

*****
H : Col Q A C
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply Haux with P Q; auto.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.

*****
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].

*****
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (l10_2_existence A C P) as [P' HP'].
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].

*****
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert_diffs.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
apply Haux with P' Q; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle P' C D
+++++
apply cong_transitivity with C P; trivial.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P' C P
+++++
apply cong_commutativity, (is_image_col_cong A C); Col.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircleS P' A B
+++++
apply cong2_lt__lt with A P A B; Cong.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.
apply cong2_lt__lt with A P A B; Cong.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A P A P'
+++++
apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.
apply cong2_lt__lt with A P A B; Cong.
apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (OS A C P' Q) (or (and (Col P' A C) (not (Col Q A C))) (and (not (Col P' A C)) (Col Q A C)))
+++++
left.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.
apply cong2_lt__lt with A P A B; Cong.
apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.
left.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C P' Q
+++++
exists P; split; Side.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.
apply cong2_lt__lt with A P A B; Cong.
apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.
left.
exists P; split; Side.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A C P' P
+++++
apply l10_14; auto.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.
apply cong2_lt__lt with A P A B; Cong.
apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.
left.
exists P; split; Side.
apply l10_14; auto.

*****
H13 : not (eq P Q)
H9 : not (eq P C)
H7 : not (eq P A)
H6 : not (eq Q C)
H3 : not (eq A C)
H4 : not (eq Q A)
HP' : Reflect P' P A C
P' : Tpoint
H0 : TS A C P Q
H : not (Col Q A C)
HNCol : not (Col P A C)
HDij : or (not (Col P A C)) (not (Col Q A C))
HCop : Coplanar A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
Haux : forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) \n (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B)\n (_ : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))),\nex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P' P)
+++++
intro; subst; apply HNCol, l10_8, HP'.
-----
Lemma circle_circle_aux : (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> OS A C P Q \\/ (Col P A C /\\ ~ Col Q A C) \\/ (~ Col P A C /\\ Col Q A C ) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D) -> circle_circle.
Proof.
intro Haux.
cut (forall A B C D P Q, OnCircle P C D -> OnCircle Q C D -> InCircleS P A B -> OutCircleS Q A B -> Coplanar A C P Q -> (~ Col P A C \\/ ~ Col Q A C) -> exists Z : Tpoint, OnCircle Z A B /\\ OnCircle Z C D).
-
intros Haux' A B C D P Q HPOn HQOn HPIn HQOut.
assert (HQ' : exists Q', OnCircle Q' C D /\\ OutCircle Q' A B /\\ Col Q' A C).
clear dependent Q.
destruct HQ' as [Q [HQOn [HQOut HCol]]].
destruct (cong_dec A P A B).
exists P; split; trivial.
destruct (cong_dec A B A Q).
exists Q; Circle.
assert (HPInS : InCircleS P A B) by (split; trivial).
assert (HQOutS : OutCircleS Q A B) by (split; trivial).
assert (A <> C).
assert (C <> D).
intro; treat_equalities; apply (not_and_lt A C A B); split; trivial.
destruct (col_dec P A C); [|apply Haux' with P Q; Cop].
destruct (exists_cong_per A C C D) as [R [HR1 HR2]].
assert_diffs.
apply per_not_col in HR1; auto.
destruct (circle_cases A B R) as [HOn|HNOn].
exists R; split; trivial.
destruct HNOn; [apply Haux' with R Q|apply Haux' with P R]; Col; Cop.
-
intros A B C D P Q HPOn HQOn HPIn HQOut HCop HDij.
destruct (col_dec P A C) as [HCol|HNCol].
destruct (col_dec Q A C).
apply Haux with P Q; auto.
destruct (cop__one_or_two_sides A C P Q); trivial; [|apply Haux with P Q; auto].
destruct (l10_2_existence A C P) as [P' HP'].
assert_diffs.
apply Haux with P' Q; trivial.
apply cong_transitivity with C P; trivial.
apply cong_commutativity, (is_image_col_cong A C); Col.
apply cong2_lt__lt with A P A B; Cong.
apply cong_symmetry, cong_commutativity, (is_image_col_cong A C); Col.
left.
exists P; split; Side.
apply l10_14; auto.
intro; subst; apply HNCol, l10_8, HP'.

*****

*****

+++++
Qed.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : first_order_dedekind, circle_circle
+++++
Proof.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : first_order_dedekind, circle_circle
+++++
intro dedekind.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.

*****
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
circle_circle
+++++
apply circle_circle_aux.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.

*****
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A B C D P Q : Tpoint) (_ : OnCircle P C D) (_ : OnCircle Q C D) (_ : InCircleS P A B) (_ : OutCircleS Q A B) (_ : or (OS A C P Q) (or (and (Col P A C) (not (Col Q A C))) (and (not (Col P A C)) (Col Q A C)))), ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.

*****
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (A <> C).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).

*****
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq A C)
+++++
intro; subst C.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
intro; subst C.

*****
HDij : or (OS A A P Q)\n (or (and (Col P A A) (not (Col Q A A)))\n (and (not (Col P A A)) (Col Q A A)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (not_and_lt A B A P); split; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
intro; subst C.
apply (not_and_lt A B A P); split; trivial.

*****
HDij : or (OS A A P Q)\n (or (and (Col P A A) (not (Col Q A A)))\n (and (not (Col P A A)) (Col Q A A)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A B A P
+++++
apply (cong2_lt__lt A B A Q); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
intro; subst C.
apply (not_and_lt A B A P); split; trivial.
apply (cong2_lt__lt A B A Q); Cong.

*****
HDij : or (OS A A P Q)\n (or (and (Col P A A) (not (Col Q A A)))\n (and (not (Col P A A)) (Col Q A A)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HPOn : OnCircle P A D
HQOn : OnCircle Q A D
A,B,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong A Q A P
+++++
apply cong_transitivity with A D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).

*****
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).

*****
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (C <> D) by (intro; treat_equalities; auto).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).

*****
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).

*****
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q) (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P)) (_ : not (eq Y Q)), OS A C X Y
+++++
intros X Y; intros.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.

*****
H7 : not (eq Y Q)
H6 : not (eq Y P)
H5 : not (eq X Q)
H4 : not (eq X P)
H3 : Bet P Y Q
H2 : Bet P X Q
X,Y : Tpoint
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C X Y
+++++
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].

*****
H7 : not (eq Y Q)
H6 : not (eq Y P)
H5 : not (eq X Q)
H4 : not (eq X P)
H3 : Bet P Y Q
H2 : Bet P X Q
X,Y : Tpoint
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C X Y
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].
-

*****
H7 : not (eq Y Q)
H6 : not (eq Y P)
H5 : not (eq X Q)
H4 : not (eq X P)
H3 : Bet P Y Q
H2 : Bet P X Q
X,Y : Tpoint
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C X Y
+++++
apply one_side_transitivity with P; [apply one_side_symmetry|]; apply l9_17 with Q; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].
-
apply one_side_transitivity with P; [apply one_side_symmetry|]; apply l9_17 with Q; trivial.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].
-
apply one_side_transitivity with P; [apply one_side_symmetry|]; apply l9_17 with Q; trivial.
-

*****
H7 : not (eq Y Q)
H6 : not (eq Y P)
H5 : not (eq X Q)
H4 : not (eq X P)
H3 : Bet P Y Q
H2 : Bet P X Q
X,Y : Tpoint
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HQ : not (Col Q A C)
HP : Col P A C
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C X Y
+++++
apply one_side_transitivity with Q; [apply one_side_symmetry|]; apply out_one_side_1 with P; Col; apply l6_6, bet_out; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].
-
apply one_side_transitivity with P; [apply one_side_symmetry|]; apply l9_17 with Q; trivial.
-
apply one_side_transitivity with Q; [apply one_side_symmetry|]; apply out_one_side_1 with P; Col; apply l6_6, bet_out; auto.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
intros X Y; intros.
destruct HDij as [HOS|[[HP HQ]|[HQ HP]]].
-
apply one_side_transitivity with P; [apply one_side_symmetry|]; apply l9_17 with Q; trivial.
-
apply one_side_transitivity with Q; [apply one_side_symmetry|]; apply out_one_side_1 with P; Col; apply l6_6, bet_out; auto.
-

*****
H7 : not (eq Y Q)
H6 : not (eq Y P)
H5 : not (eq X Q)
H4 : not (eq X P)
H3 : Bet P Y Q
H2 : Bet P X Q
X,Y : Tpoint
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HP : Col Q A C
HQ : not (Col P A C)
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS A C X Y
+++++
apply one_side_transitivity with P; [apply one_side_symmetry|]; apply out_one_side_1 with Q; Col; apply l6_6, bet_out; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).

*****
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).

*****
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
+++++
intros X Y HX HY HTS.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.

*****
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
absurd (TS A C P Q).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).

*****
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS A C P Q)
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-

*****
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (TS A C P Q)
+++++
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].

*****
H2 : TS A C P Q
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HNCol : not (Col Q A C)
HCol : Col P A C
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (two_sides_not_col A C P Q); Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
apply (two_sides_not_col A C P Q); Col.

*****
H2 : TS A C P Q
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HCol : Col Q A C
HNCol : not (Col P A C)
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (two_sides_not_col A C Q P); Col; Side.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
apply (two_sides_not_col A C P Q); Col.
apply (two_sides_not_col A C Q P); Col; Side.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
apply (two_sides_not_col A C P Q); Col.
apply (two_sides_not_col A C Q P); Col; Side.
-

*****
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A C P Q
+++++
destruct (eq_dec_points P X); destruct (eq_dec_points Q Y); treat_equalities; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
apply (two_sides_not_col A C P Q); Col.
apply (two_sides_not_col A C Q P); Col; Side.
-
destruct (eq_dec_points P X); destruct (eq_dec_points Q Y); treat_equalities; trivial.

*****
H3 : not (eq Q Y)
HTS : TS A C P Y
HX : Bet P Y Q
Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A C P Q
+++++
apply bet_ts__ts with Y; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
apply (two_sides_not_col A C P Q); Col.
apply (two_sides_not_col A C Q P); Col; Side.
-
destruct (eq_dec_points P X); destruct (eq_dec_points Q Y); treat_equalities; trivial.
apply bet_ts__ts with Y; trivial.

*****
H2 : not (eq P X)
HY : Bet P X Q
HTS : TS A C X Q
X : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A C P Q
+++++
apply l9_2, bet_ts__ts with X; Side; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
intros X Y HX HY HTS.
absurd (TS A C P Q).
-
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [apply l9_9_bis; trivial|intro..].
apply (two_sides_not_col A C P Q); Col.
apply (two_sides_not_col A C Q P); Col; Side.
-
destruct (eq_dec_points P X); destruct (eq_dec_points Q Y); treat_equalities; trivial.
apply bet_ts__ts with Y; trivial.
apply l9_2, bet_ts__ts with X; Side; Between.

*****
H3 : not (eq Q Y)
H2 : not (eq P X)
HTS : TS A C X Y
HY : Bet P X Y
HX : Bet P Y Q
X,Y : Tpoint
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS A C P Q
+++++
apply bet_ts__ts with Y; trivial; apply l9_2, bet_ts__ts with X; Side; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).

*****
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HLta : LtA A C P A C Q).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).

*****
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA A C P A C Q
+++++
apply t18_19; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
apply t18_19; Cong.

*****
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq C Q)
+++++
intro; treat_equalities; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
apply t18_19; Cong.
intro; treat_equalities; auto.

*****
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Q C P
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
apply t18_19; Cong.
intro; treat_equalities; auto.
apply cong_transitivity with C D; Cong.

*****
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt P A Q A
+++++
apply lt_comm, lt_transitivity with A B; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).

*****
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HNCol1 : ~ Col P Q C).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).

*****
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P Q C)
+++++
intro.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
intro.

*****
H2 : Col P Q C
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [|apply HNCol; assert_diffs; ColR..].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
intro.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [|apply HNCol; assert_diffs; ColR..].

*****
H2 : Col P Q C
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS' : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HLta as [_ HNCongA].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
intro.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [|apply HNCol; assert_diffs; ColR..].
destruct HLta as [_ HNCongA].

*****
H2 : Col P Q C
HNCongA : not (CongA A C P A C Q)
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS' : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HNCongA, out2__conga.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
intro.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [|apply HNCol; assert_diffs; ColR..].
destruct HLta as [_ HNCongA].
apply HNCongA, out2__conga.

*****
H2 : Col P Q C
HNCongA : not (CongA A C P A C Q)
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS' : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C A A
+++++
apply out_trivial; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
intro.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]]; [|apply HNCol; assert_diffs; ColR..].
destruct HLta as [_ HNCongA].
apply HNCongA, out2__conga.
apply out_trivial; auto.

*****
H2 : Col P Q C
HNCongA : not (CongA A C P A C Q)
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS' : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C Q P
+++++
apply col_one_side_out with A; Col; Side.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).

*****
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).

*****
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y)) (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D) (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
+++++
intros X Y X0 Y0; intros.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A X0 A Y0
+++++
apply t18_18 with C C; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Y0 C X0
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA X0 C A Y0 C A
+++++
apply lta_comm, (conga_preserves_lta A C X A C Y).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C X A C X0
+++++
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
CongA A C Y A C Y0
+++++
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA A C X A C Y
+++++
split.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A C X A C Y
+++++
apply inangle__lea.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle X A C Y
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle X A C Y
+++++
apply l11_24, in_angle_trans with P.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle X Y C P
+++++
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P Y C A
+++++
apply in_angle_trans2 with Q.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle Y Q C P
+++++
repeat split; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X : Tpoint => and (Bet Q X P) (or (eq X C) (Out C X Y)))
+++++
exists Y; split; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (eq Y C) (Out C Y Y)
+++++
right; apply out_trivial; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P Q C A
+++++
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS' : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P Q C A
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HOS' : OS A C P Q
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P Q C A
+++++
apply l11_24, lea_in_angle; Lea; Side.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HNCol : not (Col Q A C)
HCol : Col P A C
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P Q C A
+++++
apply out341__inangle; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HNCol : not (Col Q A C)
HCol : Col P A C
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out C A P
+++++
apply not_bet_out; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HNCol : not (Col Q A C)
HCol : Col P A C
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet A C P)
+++++
intro; apply (lta__nlea A C P A C Q); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.
intro; apply (lta__nlea A C P A C Q); trivial.

*****
H10 : Bet A C P
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HNCol : not (Col Q A C)
HCol : Col P A C
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A C Q A C P
+++++
apply l11_31_2; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.
intro; apply (lta__nlea A C P A C Q); trivial.
apply l11_31_2; auto.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.
intro; apply (lta__nlea A C P A C Q); trivial.
apply l11_31_2; auto.
-

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HCol : Col Q A C
HNCol : not (Col P A C)
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle P Q C A
+++++
apply in_angle_line; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.
intro; apply (lta__nlea A C P A C Q); trivial.
apply l11_31_2; auto.
-
apply in_angle_line; auto.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HCol : Col Q A C
HNCol : not (Col P A C)
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet Q C A
+++++
apply between_symmetry, not_out_bet; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.
intro; apply (lta__nlea A C P A C Q); trivial.
apply l11_31_2; auto.
-
apply in_angle_line; auto.
apply between_symmetry, not_out_bet; Col.

*****
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HCol : Col Q A C
HNCol : not (Col P A C)
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Out C A Q)
+++++
intro; apply (lta__nlea A C P A C Q); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
apply inangle__lea.
assert_diffs.
apply l11_24, in_angle_trans with P.
repeat split; auto; exists X; split; Between; right; apply out_trivial; auto.
apply in_angle_trans2 with Q.
repeat split; auto.
exists Y; split; Between.
right; apply out_trivial; auto.
destruct HDij as [HOS'|[[HCol HNCol]|[HNCol HCol]]].
-
apply l11_24, lea_in_angle; Lea; Side.
-
apply out341__inangle; auto.
apply not_bet_out; Col.
intro; apply (lta__nlea A C P A C Q); trivial.
apply l11_31_2; auto.
-
apply in_angle_line; auto.
apply between_symmetry, not_out_bet; Col.
intro; apply (lta__nlea A C P A C Q); trivial.

*****
H10 : Out C A Q
H16 : not (eq X0 C)
H15 : not (eq X C)
H13 : not (eq Y0 C)
H12 : not (eq Y C)
H9 : not (eq P Y)
H14 : not (eq P C)
H11 : not (eq Q C)
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HCol : Col Q A C
HNCol : not (Col P A C)
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA A C Q A C P
+++++
apply l11_31_1; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.

*****
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (CongA A C X A C Y)
+++++
intro.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.

*****
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (conga_cop__or_out_ts A C X Y); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.

*****
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A C X Y
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-

*****
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A C X Y
+++++
assert (Col P Q X) by ColR.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-
assert (Col P Q X) by ColR.

*****
H10 : Col P Q X
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar A C X Y
+++++
apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-
assert (Col P Q X) by ColR.
apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].

*****
H10 : Col P Q X
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q C A
+++++
destruct HDij as [|[[]|[]]]; Cop.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-
assert (Col P Q X) by ColR.
apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].
destruct HDij as [|[[]|[]]]; Cop.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-
assert (Col P Q X) by ColR.
apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].
destruct HDij as [|[[]|[]]]; Cop.
-

*****
H10 : Out C X Y
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
absurd (X = Y); trivial; apply (l6_21 P Q C X); ColR.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-
assert (Col P Q X) by ColR.
apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].
destruct HDij as [|[[]|[]]]; Cop.
-
absurd (X = Y); trivial; apply (l6_21 P Q C X); ColR.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
intros X Y X0 Y0; intros.
apply t18_18 with C C; Cong.
apply cong_transitivity with C D; Cong.
apply lta_comm, (conga_preserves_lta A C X A C Y).
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
apply out2__conga; [apply out_trivial|apply l6_6]; auto.
split.
intro.
destruct (conga_cop__or_out_ts A C X Y); trivial.
-
assert (Col P Q X) by ColR.
apply coplanar_pseudo_trans with P Q C; [assumption| |Cop..].
destruct HDij as [|[[]|[]]]; Cop.
-
absurd (X = Y); trivial; apply (l6_21 P Q C X); ColR.
-

*****
H10 : TS A C X Y
H9 : CongA A C X A C Y
H8 : Bet P X Y
H7 : Out C Y Y0
H6 : OnCircle Y0 C D
H5 : Out C X X0
H4 : OnCircle X0 C D
H3 : not (eq X Y)
H2 : Bet P Y Q
X,Y,X0,Y0 : Tpoint
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (HNTS X Y); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).

*****
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HR : exists R, forall X Y, (Bet P X Q /\ (exists X0, OnCircle X0 C D /\ Out C X X0 /\ InCircle X0 A B)) -> (Bet P Y Q /\ (exists Y0, OnCircle Y0 C D /\ Out C Y Y0 /\ OutCircle Y0 A B)) -> Bet X R Y).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).

*****
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun R : Tpoint => forall (X Y : Tpoint) (_ : and (Bet P X Q) (ex (fun X0 : Tpoint => and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))))) (_ : and (Bet P Y Q) (ex (fun Y0 : Tpoint => and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))))), Bet X R Y)
+++++
apply dedekind; [repeat constructor..|].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].

*****
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun A0 : Tpoint => forall (X Y : Tpoint) (_ : and (Bet P X Q) (ex (fun X0 : Tpoint => and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))))) (_ : and (Bet P Y Q) (ex (fun Y0 : Tpoint => and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))))), Bet A0 X Y)
+++++
exists P.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.

*****
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (X Y : Tpoint) (_ : and (Bet P X Q) (ex (fun X0 : Tpoint => and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))))) (_ : and (Bet P Y Q) (ex (fun Y0 : Tpoint => and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))))), Bet P X Y
+++++
intros X Y [HX [X0]] [HY [Y0]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].

*****
H3 : and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))
Y0 : Tpoint
HY : Bet P Y Q
H2 : and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P X Y
+++++
destruct (l5_3 P X Y Q); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.

*****
H4 : Bet P Y X
H3 : and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))
Y0 : Tpoint
HY : Bet P Y Q
H2 : and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P X Y
+++++
destruct (eq_dec_points X Y).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.
destruct (eq_dec_points X Y).

*****
H5 : eq X Y
H4 : Bet P Y X
H3 : and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))
Y0 : Tpoint
HY : Bet P Y Q
H2 : and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P X Y
+++++
subst; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.
destruct (eq_dec_points X Y).
subst; Between.

*****
H5 : not (eq X Y)
H4 : Bet P Y X
H3 : and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))
Y0 : Tpoint
HY : Bet P Y Q
H2 : and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P X Y
+++++
exfalso.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.
destruct (eq_dec_points X Y).
subst; Between.
exfalso.

*****
H5 : not (eq X Y)
H4 : Bet P Y X
H3 : and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B))
Y0 : Tpoint
HY : Bet P Y Q
H2 : and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B))
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
spliter.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.
destruct (eq_dec_points X Y).
subst; Between.
exfalso.
spliter.

*****
H5 : not (eq X Y)
H4 : Bet P Y X
H7 : OutCircle Y0 A B
H6 : Out C Y Y0
H3 : OnCircle Y0 C D
Y0 : Tpoint
HY : Bet P Y Q
H9 : InCircle X0 A B
H8 : Out C X X0
H2 : OnCircle X0 C D
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (lt__nle A Y0 A X0).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.
destruct (eq_dec_points X Y).
subst; Between.
exfalso.
spliter.
apply (lt__nle A Y0 A X0).

*****
H5 : not (eq X Y)
H4 : Bet P Y X
H7 : OutCircle Y0 A B
H6 : Out C Y Y0
H3 : OnCircle Y0 C D
Y0 : Tpoint
HY : Bet P Y Q
H9 : InCircle X0 A B
H8 : Out C X X0
H2 : OnCircle X0 C D
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A Y0 A X0
+++++
apply (Haux Y X); auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
apply dedekind; [repeat constructor..|].
exists P.
intros X Y [HX [X0]] [HY [Y0]].
destruct (l5_3 P X Y Q); trivial.
destruct (eq_dec_points X Y).
subst; Between.
exfalso.
spliter.
apply (lt__nle A Y0 A X0).
apply (Haux Y X); auto.

*****
H5 : not (eq X Y)
H4 : Bet P Y X
H7 : OutCircle Y0 A B
H6 : Out C Y Y0
H3 : OnCircle Y0 C D
Y0 : Tpoint
HY : Bet P Y Q
H9 : InCircle X0 A B
H8 : Out C X X0
H2 : OnCircle X0 C D
X0 : Tpoint
HX : Bet P X Q
X,Y : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A X0 A Y0
+++++
apply le_transitivity with A B; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).

*****
HR : ex\n (fun R : Tpoint =>\n forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D)\n (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \n Bet X R Y)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HP : exists X0, OnCircle X0 C D /\ Out C P X0 /\ InCircle X0 A B).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).

*****
HR : ex\n (fun R : Tpoint =>\n forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D)\n (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \n Bet X R Y)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X0 : Tpoint => and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
+++++
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.

*****
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : ex\n (fun R : Tpoint =>\n forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D)\n (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \n Bet X R Y)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HQ : exists Y0, OnCircle Y0 C D /\ Out C Q Y0 /\ OutCircle Y0 A B).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).

*****
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : ex\n (fun R : Tpoint =>\n forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D)\n (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \n Bet X R Y)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y0 : Tpoint => and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
+++++
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.

*****
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : ex\n (fun R : Tpoint =>\n forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D)\n (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \n Bet X R Y)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct HR as [R HR].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].

*****
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (HBet : Bet P R Q) by (apply HR; split; Between).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).

*****
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
assert (R <> C) by (intro; subst; apply HNCol1; Col).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).

*****
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.

*****
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Z : Tpoint => and (OnCircle Z A B) (OnCircle Z C D))
+++++
exists Z; split; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.

*****
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
assert (A <> B) by (apply (lt_diff A P), HPIn).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).

*****
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OnCircle Z A B
+++++
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.

*****
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-

*****
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Q <> R).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).

*****
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Q R)
+++++
intro; subst R.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
intro; subst R.

*****
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C Q Z
HZ1 : OnCircle Z C D
Z : Tpoint
HBet : Bet P Q Q
H2 : not (eq Q C)
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X Q Y
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Q = Z) by (apply (onc2_out__eq C D); trivial).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
intro; subst R.
assert (Q = Z) by (apply (onc2_out__eq C D); trivial).

*****
H4 : eq Q Z
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C Q Z
HZ1 : OnCircle Z C D
Z : Tpoint
HBet : Bet P Q Q
H2 : not (eq Q C)
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X Q Y
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
intro; subst R.
assert (Q = Z) by (apply (onc2_out__eq C D); trivial).
subst.

*****
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C Z Z
HZ1 : OnCircle Z C D
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Z Y0) (OutCircle Y0 A B)))
H2 : not (eq Z C)
HBet : Bet P Z Z
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HOS : forall (X Y : Tpoint) (_ : Bet P X Z) (_ : Bet P Y Z)\n (_ : not (eq X P)) (_ : not (eq X Z)) (_ : not (eq Y P))\n (_ : not (eq Y Z)), OS A C X Y
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Z) (_ : Bet P X Y), not (TS A C X Y)
HLta : LtA A C P A C Z
HNCol1 : not (Col P Z C)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Z) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Z)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Z)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X Z Y
H1 : not (eq C D)
H0 : not (eq P Z)
H : not (eq A C)
HQOut : OutCircleS Z A B
HDij : or (OS A C P Z)\n (or (and (Col P A C) (not (Col Z A C)))\n (and (not (Col P A C)) (Col Z A C)))
HPIn : InCircleS P A B
HQOn : OnCircle Z C D
Z : Tpoint
HPOn : OnCircle P C D
A,B,C,D,P : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply outcs__ninc in HQOut; Circle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).

*****
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).

*****
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HT : exists T, OnCircle T A B /\ Bet A Z T).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).

*****
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (OnCircle T A B) (Bet A Z T))
+++++
destruct (eq_dec_points Z A).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct (eq_dec_points Z A).

*****
H5 : eq Z A
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (OnCircle T A B) (Bet A Z T))
+++++
subst; exists B; split; Circle; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct (eq_dec_points Z A).
subst; exists B; split; Circle; Between.

*****
H5 : not (eq Z A)
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (OnCircle T A B) (Bet A Z T))
+++++
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct (eq_dec_points Z A).
subst; exists B; split; Circle; Between.
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
H5 : not (eq Z A)
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun T : Tpoint => and (OnCircle T A B) (Bet A Z T))
+++++
exists T; split; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct (eq_dec_points Z A).
subst; exists B; split; Circle; Between.
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
exists T; split; trivial.

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
H5 : not (eq Z A)
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A Z T
+++++
apply l6_13_1; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct (eq_dec_points Z A).
subst; exists B; split; Circle; Between.
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
exists T; split; trivial.
apply l6_13_1; trivial.

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
H5 : not (eq Z A)
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A Z A T
+++++
apply (l5_6 A Z A B); Cong; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).

*****
HT : ex (fun T : Tpoint => and (OnCircle T A B) (Bet A Z T))
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HT as [T [HT1 HT2]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].

*****
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (T <> Z).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).

*****
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T Z)
+++++
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.

*****
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.

*****
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.

*****
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).

*****
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.

*****
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HLt : Lt C X0 C I).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).

*****
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C X0 C I
+++++
destruct (l11_46 I Z C) as [_ HLt]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
destruct (l11_46 I Z C) as [_ HLt]; auto.

*****
HLt : Lt Z C I C
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C X0 C I
+++++
apply (cong2_lt__lt Z C I C); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
destruct (l11_46 I Z C) as [_ HLt]; auto.
apply (cong2_lt__lt Z C I C); trivial.

*****
HLt : Lt Z C I C
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong Z C C X0
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
destruct (l11_46 I Z C) as [_ HLt]; auto.
apply (cong2_lt__lt Z C I C); trivial.
apply cong_transitivity with C D; Cong.

*****
HLt : Lt Z C I C
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong I C C I
+++++
Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).

*****
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).

*****
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).

*****
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HLt1 : Lt X0 Z I Z).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).

*****
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt X0 Z I Z
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert_diffs.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt X0 Z I Z
+++++
destruct (l11_46 I X0 Z); auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert_diffs.
destruct (l11_46 I X0 Z); auto.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Per I X0 Z) (Obtuse I X0 Z)
+++++
right.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert_diffs.
destruct (l11_46 I X0 Z); auto.
right.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse I X0 Z
+++++
apply acute_bet__obtuse with C; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert_diffs.
destruct (l11_46 I X0 Z); auto.
right.
apply acute_bet__obtuse with C; auto.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C X0 I
+++++
apply l6_13_1; [apply l6_6|]; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert_diffs.
destruct (l11_46 I X0 Z); auto.
right.
apply acute_bet__obtuse with C; auto.
apply l6_13_1; [apply l6_6|]; Le.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute C X0 Z
+++++
assert_diffs; apply cong__acute; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert_diffs.
destruct (l11_46 I X0 Z); auto.
right.
apply acute_bet__obtuse with C; auto.
apply l6_13_1; [apply l6_6|]; Le.
assert_diffs; apply cong__acute; auto.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C X0 C Z
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).

*****
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HX0In : InCircleS X0 A B).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).

*****
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircleS X0 A B
+++++
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].

*****
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le Z X0 Z T
+++++
apply (l5_6 X0 Z I Z); Cong; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.

*****
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircleS X0 A B
+++++
assert (HMT : M <> T).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).

*****
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq M T)
+++++
intro.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
intro.

*****
H11 : eq M T
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (nlt Z M).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
intro.
apply (nlt Z M).

*****
H11 : eq M T
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt Z M Z M
+++++
apply (cong2_lt__lt X0 Z I Z); trivial; [|subst M; apply cong_transitivity with T Z]; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).

*****
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InCircleS X0 A B
+++++
apply le1234_lt__lt with A M.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.

*****
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A X0 A M
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-

*****
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A X0 A M
+++++
apply triangle_inequality with Z; Cong; eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-
apply triangle_inequality with Z; Cong; eBetween.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-
apply triangle_inequality with Z; Cong; eBetween.
-

*****
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A M A B
+++++
apply (cong2_lt__lt A M A T); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-
apply triangle_inequality with Z; Cong; eBetween.
-
apply (cong2_lt__lt A M A T); Cong.

*****
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A M A T
+++++
assert (Bet A M T) by eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-
apply triangle_inequality with Z; Cong; eBetween.
-
apply (cong2_lt__lt A M A T); Cong.
assert (Bet A M T) by eBetween.

*****
H11 : Bet A M T
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A M A T
+++++
split; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-
apply triangle_inequality with Z; Cong; eBetween.
-
apply (cong2_lt__lt A M A T); Cong.
assert (Bet A M T) by eBetween.
split; Le.

*****
H11 : Bet A M T
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong A M A T)
+++++
intro.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
destruct (le_bet Z T Z X0) as [M [HM1 HM2]].
apply (l5_6 X0 Z I Z); Cong; Le.
assert (HMT : M <> T).
apply le1234_lt__lt with A M.
-
apply triangle_inequality with Z; Cong; eBetween.
-
apply (cong2_lt__lt A M A T); Cong.
assert (Bet A M T) by eBetween.
split; Le.
intro.

*****
H14 : Cong A M A T
H11 : Bet A M T
HMT : not (eq M T)
HM2 : Cong Z M Z X0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HMT, (between_cong A); assumption.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).

*****
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HX : InAngle X0 R C Q).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle X0 R C Q
+++++
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle X0 Z C Q
+++++
apply lea_in_angle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA Z C X0 Z C Q
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA Z C X0 Z C Q
+++++
apply t18_19; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Q C X0
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Z C Z
+++++
Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt X0 Z Q Z
+++++
apply le3456_lt__lt with I Z; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le I Z Q Z
+++++
apply (l5_6 T Z Q Z); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z Q Z
+++++
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).

*****
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z Q Z
+++++
destruct (eq_dec_points A Z).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).

*****
H11 : eq A Z
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z Q Z
+++++
subst; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.

*****
H11 : not (eq A Z)
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z Q Z
+++++
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.

*****
HM2 : Cong A M A Q
HM1 : Bet A T M
M : Tpoint
H11 : not (eq A Z)
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z Q Z
+++++
assert (Bet A Z M) by eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.

*****
H14 : Bet A Z M
HM2 : Cong A M A Q
HM1 : Bet A T M
M : Tpoint
H11 : not (eq A Z)
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z Q Z
+++++
apply le_transitivity with M Z.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.

*****
H14 : Bet A Z M
HM2 : Cong A M A Q
HM1 : Bet A T M
M : Tpoint
H11 : not (eq A Z)
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z M Z
+++++
apply bet__le2313; eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.

*****
H14 : Bet A Z M
HM2 : Cong A M A Q
HM1 : Bet A T M
M : Tpoint
H11 : not (eq A Z)
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le M Z Q Z
+++++
apply le_comm, (triangle_reverse_inequality A); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.

*****
H14 : Bet A Z M
HM2 : Cong A M A Q
HM1 : Bet A T M
M : Tpoint
H11 : not (eq A Z)
HLe : Le A T A Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A Z M
+++++
apply bet_out; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply bet_out; auto.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply bet_out; auto.
-

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Z C Q X0
+++++
apply invert_one_side, col_one_side with R; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply bet_out; auto.
-
apply invert_one_side, col_one_side with R; Col.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C R Q X0
+++++
apply one_side_transitivity with I; Side.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply bet_out; auto.
-
apply invert_one_side, col_one_side with R; Col.
apply one_side_transitivity with I; Side.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C R I X0
+++++
apply out_one_side; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
apply l11_25 with X0 Z Q; try (apply out_trivial); auto.
apply lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z Q Z); Cong.
assert (HLe : Le A T A Q) by (apply (l5_6 A B A Q); Cong; Le).
destruct (eq_dec_points A Z).
subst; Le.
destruct (l5_5_1 A T A Q) as [M [HM1 HM2]]; trivial.
assert (Bet A Z M) by eBetween.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply bet_out; auto.
-
apply invert_one_side, col_one_side with R; Col.
apply one_side_transitivity with I; Side.
apply out_one_side; trivial.

*****
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (not (Col C R I)) (not (Col C R X0))
+++++
left; apply one_side_not_col123 with Q; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).

*****
HX : InAngle X0 R C Q
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].

*****
HX2 : eq X C
HX1 : Bet R X Q
X : Tpoint
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst; apply HNCol2; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.

*****
HX2 : Out C X X0
HX1 : Bet R X Q
X : Tpoint
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (X = R).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).

*****
HX2 : Out C X X0
HX1 : Bet R X Q
X : Tpoint
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq X R
+++++
apply between_equality with Q; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.

*****
HX2 : Out C X X0
HX1 : Bet R X Q
X : Tpoint
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet X R Q
+++++
apply HR; split; [eBetween|..]; Between.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.

*****
HX2 : Out C X X0
HX1 : Bet R X Q
X : Tpoint
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun X0 : Tpoint => and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))
+++++
exists X0; repeat (split; Circle).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).

*****
H11 : eq X R
HX2 : Out C X X0
HX1 : Bet R X Q
X : Tpoint
H17 : not (eq X0 C)
H15 : not (eq X0 Z)
HX0In : InCircleS X0 A B
HLt1 : Lt X0 Z I Z
HNCol4 : not (Col I X0 Z)
H10 : not (eq X0 I)
HLt : Lt C X0 C I
HX0Out : Out C I X0
HX0On : OnCircle X0 C D
X0 : Tpoint
HNCol3 : not (Col I Z C)
H16 : not (eq R I)
H13 : not (eq Z C)
H8 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A T)
H12 : not (eq P C)
H9 : not (eq C Q)
HI3 : OS C R I Q
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT2 : Bet A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C Q R)
H4 : not (eq Q R)
Habs : InCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst; apply HNCol4; ColR.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-

*****
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (P <> R).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).

*****
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P R)
+++++
intro; subst R.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
intro; subst R.

*****
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C P Z
HZ1 : OnCircle Z C D
Z : Tpoint
HBet : Bet P P Q
H2 : not (eq P C)
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X P Y
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (P = Z) by (apply (onc2_out__eq C D); trivial).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
intro; subst R.
assert (P = Z) by (apply (onc2_out__eq C D); trivial).

*****
H4 : eq P Z
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C P Z
HZ1 : OnCircle Z C D
Z : Tpoint
HBet : Bet P P Q
H2 : not (eq P C)
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X P Y
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
intro; subst R.
assert (P = Z) by (apply (onc2_out__eq C D); trivial).
subst.

*****
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C Z Z
HZ1 : OnCircle Z C D
H2 : not (eq Z C)
HBet : Bet Z Z Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HOS : forall (X Y : Tpoint) (_ : Bet Z X Q) (_ : Bet Z Y Q)\n (_ : not (eq X Z)) (_ : not (eq X Q)) (_ : not (eq Y Z))\n (_ : not (eq Y Q)), OS A C X Y
HNTS : forall (X Y : Tpoint) (_ : Bet Z Y Q) (_ : Bet Z X Y), not (TS A C X Y)
HLta : LtA A C Z A C Q
HNCol1 : not (Col Z Q C)
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet Z Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet Z X Y), Lt A X0 A Y0
HR : forall (X Y : Tpoint)\n (_ : and (Bet Z X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet Z Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X Z Y
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C Z X0) (InCircle X0 A B)))
H1 : not (eq C D)
H0 : not (eq Z Q)
H : not (eq A C)
HDij : or (OS A C Z Q)\n (or (and (Col Z A C) (not (Col Q A C)))\n (and (not (Col Z A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS Z A B
HQOn : OnCircle Q C D
HPOn : OnCircle Z C D
A,B,C,D,Q,Z : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply incs__noutc in HPIn; Circle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).

*****
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).

*****
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.

*****
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq Z A)
+++++
apply (lt_diff A B), lt_right_comm, Habs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HT3 : Bet A T Z).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet A T Z
+++++
apply l6_13_1.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
apply l6_13_1.

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A T Z
+++++
apply l6_6, HT2.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
apply l6_13_1.
apply l6_6, HT2.

*****
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A T A Z
+++++
apply (l5_6 A B A Z); Cong; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).

*****
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (T <> Z).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).

*****
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T Z)
+++++
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.

*****
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.

*****
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.

*****
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).

*****
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.

*****
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HLt : Lt C Y0 C I).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).

*****
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C Y0 C I
+++++
destruct (l11_46 I Z C) as [_ HLt]; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
destruct (l11_46 I Z C) as [_ HLt]; auto.

*****
HLt : Lt Z C I C
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt C Y0 C I
+++++
apply (cong2_lt__lt Z C I C); trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
destruct (l11_46 I Z C) as [_ HLt]; auto.
apply (cong2_lt__lt Z C I C); trivial.

*****
HLt : Lt Z C I C
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong Z C C Y0
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
destruct (l11_46 I Z C) as [_ HLt]; auto.
apply (cong2_lt__lt Z C I C); trivial.
apply cong_transitivity with C D; Cong.

*****
HLt : Lt Z C I C
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong I C C I
+++++
Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).

*****
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).

*****
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).

*****
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HLt1 : Lt Y0 Z I Z).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).

*****
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt Y0 Z I Z
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert_diffs.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt Y0 Z I Z
+++++
destruct (l11_46 I Y0 Z); auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert_diffs.
destruct (l11_46 I Y0 Z); auto.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (Per I Y0 Z) (Obtuse I Y0 Z)
+++++
right.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert_diffs.
destruct (l11_46 I Y0 Z); auto.
right.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse I Y0 Z
+++++
apply acute_bet__obtuse with C; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert_diffs.
destruct (l11_46 I Y0 Z); auto.
right.
apply acute_bet__obtuse with C; auto.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet C Y0 I
+++++
apply l6_13_1; [apply l6_6|]; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert_diffs.
destruct (l11_46 I Y0 Z); auto.
right.
apply acute_bet__obtuse with C; auto.
apply l6_13_1; [apply l6_6|]; Le.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute C Y0 Z
+++++
assert_diffs; apply cong__acute; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert_diffs.
destruct (l11_46 I Y0 Z); auto.
right.
apply acute_bet__obtuse with C; auto.
apply l6_13_1; [apply l6_6|]; Le.
assert_diffs; apply cong__acute; auto.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Y0 C Z
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).

*****
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HY0OutC : OutCircleS Y0 A B).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).

*****
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircleS Y0 A B
+++++
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].

*****
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le Z Y0 Z T
+++++
apply (l5_6 Y0 Z I Z); Cong; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.

*****
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircleS Y0 A B
+++++
assert (HTM : T <> M).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).

*****
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq T M)
+++++
intro.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
intro.

*****
H12 : eq T M
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply (nlt Z M).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
intro.
apply (nlt Z M).

*****
H12 : eq T M
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt Z M Z M
+++++
apply (cong2_lt__lt Y0 Z I Z); trivial; [|subst M; apply cong_transitivity with T Z]; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).

*****
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OutCircleS Y0 A B
+++++
apply le3456_lt__lt with A M.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.

*****
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A B A M
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-

*****
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A B A M
+++++
apply (cong2_lt__lt A T A M); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.

*****
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A T A M
+++++
assert (Bet A T M) by eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.
assert (Bet A T M) by eBetween.

*****
H12 : Bet A T M
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt A T A M
+++++
split; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.
assert (Bet A T M) by eBetween.
split; Le.

*****
H12 : Bet A T M
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Cong A T A M)
+++++
intro.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.
assert (Bet A T M) by eBetween.
split; Le.
intro.

*****
H15 : Cong A T A M
H12 : Bet A T M
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
apply HTM, (between_cong A); assumption.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.
assert (Bet A T M) by eBetween.
split; Le.
intro.
apply HTM, (between_cong A); assumption.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.
assert (Bet A T M) by eBetween.
split; Le.
intro.
apply HTM, (between_cong A); assumption.
-

*****
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A M A Y0
+++++
apply (triangle_reverse_inequality Z); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
destruct (le_bet Z T Z Y0) as [M [HM1 HM2]].
apply (l5_6 Y0 Z I Z); Cong; Le.
assert (HTM : T <> M).
apply le3456_lt__lt with A M.
-
apply (cong2_lt__lt A T A M); Cong.
assert (Bet A T M) by eBetween.
split; Le.
intro.
apply HTM, (between_cong A); assumption.
-
apply (triangle_reverse_inequality Z); Cong.

*****
HTM : not (eq T M)
HM2 : Cong Z M Z Y0
HM1 : Bet Z M T
M : Tpoint
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Z A M
+++++
assert_diffs; apply l6_6, bet_out; eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).

*****
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert_diffs.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (HY : InAngle Y0 P C R).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle Y0 P C R
+++++
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
InAngle Y0 P C Z
+++++
apply l11_24, lea_in_angle.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA Z C Y0 Z C P
+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA Z C Y0 Z C P
+++++
apply t18_19; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C P C Y0
+++++
apply cong_transitivity with C D; Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Cong C Z C Z
+++++
Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Lt Y0 Z P Z
+++++
apply le3456_lt__lt with I Z; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le I Z P Z
+++++
apply (l5_6 T Z P Z); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z P Z
+++++
destruct (le_bet A T A P) as [M [HM1 HM2]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le A P A T
+++++
apply (l5_6 A P A B); Cong; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.

*****
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z P Z
+++++
assert (Bet A M Z) by eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.

*****
H12 : Bet A M Z
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z P Z
+++++
destruct (eq_dec_points M A).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).

*****
H15 : eq M A
H12 : Bet A M Z
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z P Z
+++++
treat_equalities; Le.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.

*****
H15 : not (eq M A)
H12 : Bet A M Z
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z P Z
+++++
apply le_transitivity with M Z.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.

*****
H15 : not (eq M A)
H12 : Bet A M Z
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le T Z M Z
+++++
apply bet__le2313; eBetween.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.

*****
H15 : not (eq M A)
H12 : Bet A M Z
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Le M Z P Z
+++++
apply le_comm, (triangle_reverse_inequality A); Cong.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.

*****
H15 : not (eq M A)
H12 : Bet A M Z
HM2 : Cong A M A P
HM1 : Bet A M T
M : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out A Z M
+++++
apply l6_6, bet_out; auto.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply l6_6, bet_out; auto.

*****

*****

+++++
-
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply l6_6, bet_out; auto.
-

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS Z C P Y0
+++++
apply invert_one_side, col_one_side with R; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply l6_6, bet_out; auto.
-
apply invert_one_side, col_one_side with R; Col.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C R P Y0
+++++
apply one_side_transitivity with I; Side.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply l6_6, bet_out; auto.
-
apply invert_one_side, col_one_side with R; Col.
apply one_side_transitivity with I; Side.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C R I Y0
+++++
apply out_one_side; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
apply l11_25 with Y0 P Z; try (apply out_trivial); auto.
apply l11_24, lea_in_angle.
-
apply t18_19; auto.
apply cong_transitivity with C D; Cong.
Cong.
apply le3456_lt__lt with I Z; trivial.
apply (l5_6 T Z P Z); Cong.
destruct (le_bet A T A P) as [M [HM1 HM2]].
apply (l5_6 A P A B); Cong; Le.
assert (Bet A M Z) by eBetween.
destruct (eq_dec_points M A).
treat_equalities; Le.
apply le_transitivity with M Z.
apply bet__le2313; eBetween.
apply le_comm, (triangle_reverse_inequality A); Cong.
apply l6_6, bet_out; auto.
-
apply invert_one_side, col_one_side with R; Col.
apply one_side_transitivity with I; Side.
apply out_one_side; trivial.

*****
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
or (not (Col C R I)) (not (Col C R Y0))
+++++
left; apply one_side_not_col123 with P; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).

*****
HY : InAngle Y0 P C R
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].

*****
HY2 : eq Y C
HY1 : Bet P Y R
Y : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst; apply HNCol2; Col.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
subst; apply HNCol2; Col.

*****
HY2 : Out C Y Y0
HY1 : Bet P Y R
Y : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
assert (Y = R).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
subst; apply HNCol2; Col.
assert (Y = R).

*****
HY2 : Out C Y Y0
HY1 : Bet P Y R
Y : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq Y R
+++++
apply between_equality with P; apply between_symmetry; trivial.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
subst; apply HNCol2; Col.
assert (Y = R).
apply between_equality with P; apply between_symmetry; trivial.

*****
HY2 : Out C Y Y0
HY1 : Bet P Y R
Y : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Bet P R Y
+++++
apply HR; split; [Between..| |]; [eBetween|].
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
subst; apply HNCol2; Col.
assert (Y = R).
apply between_equality with P; apply between_symmetry; trivial.
apply HR; split; [Between..| |]; [eBetween|].

*****
HY2 : Out C Y Y0
HY1 : Bet P Y R
Y : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun Y0 : Tpoint => and (OnCircle Y0 C D) (and (Out C Y Y0) (OutCircle Y0 A B)))
+++++
exists Y0; repeat (split; Circle).
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
subst; apply HNCol2; Col.
assert (Y = R).
apply between_equality with P; apply between_symmetry; trivial.
apply HR; split; [Between..| |]; [eBetween|].
exists Y0; repeat (split; Circle).

*****
H12 : eq Y R
HY2 : Out C Y Y0
HY1 : Bet P Y R
Y : Tpoint
H18 : not (eq Y0 C)
H16 : not (eq Y0 Z)
HY0OutC : OutCircleS Y0 A B
HLt1 : Lt Y0 Z I Z
HNCol4 : not (Col I Y0 Z)
H11 : not (eq Y0 I)
HLt : Lt C Y0 C I
HY0Out : Out C I Y0
HY0On : OnCircle Y0 C D
Y0 : Tpoint
HNCol3 : not (Col I Z C)
H17 : not (eq R I)
H14 : not (eq Z C)
H13 : not (eq T A)
H10 : not (eq I C)
H7 : not (eq I Z)
H6 : not (eq A Z)
H8 : not (eq Q C)
H9 : not (eq C P)
HI3 : OS C R I P
HI2 : Cong I Z T Z
HI1 : Per I Z C
I : Tpoint
H5 : not (eq T Z)
HT3 : Bet A T Z
HT2 : Out A Z T
HT1 : OnCircle T A B
T : Tpoint
HNCol2 : not (Col C P R)
H4 : not (eq P R)
Habs : OutCircleS Z A B
H3 : not (eq A B)
HZ2 : Out C R Z
HZ1 : OnCircle Z C D
Z : Tpoint
H2 : not (eq R C)
HBet : Bet P R Q
HQ : ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D) (and (Out C Q Y0) (OutCircle Y0 A B)))
HP : ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C P X0) (InCircle X0 A B)))
HR : forall (X Y : Tpoint)\n (_ : and (Bet P X Q)\n (ex\n (fun X0 : Tpoint =>\n and (OnCircle X0 C D) (and (Out C X X0) (InCircle X0 A B)))))\n (_ : and (Bet P Y Q)\n (ex\n (fun Y0 : Tpoint =>\n and (OnCircle Y0 C D)\n (and (Out C Y Y0) (OutCircle Y0 A B))))), \nBet X R Y
R : Tpoint
Haux : forall (X Y X0 Y0 : Tpoint) (_ : Bet P Y Q) (_ : not (eq X Y))\n (_ : OnCircle X0 C D) (_ : Out C X X0) (_ : OnCircle Y0 C D)\n (_ : Out C Y Y0) (_ : Bet P X Y), Lt A X0 A Y0
HNCol1 : not (Col P Q C)
HLta : LtA A C P A C Q
HNTS : forall (X Y : Tpoint) (_ : Bet P Y Q) (_ : Bet P X Y), not (TS A C X Y)
HOS : forall (X Y : Tpoint) (_ : Bet P X Q) (_ : Bet P Y Q)\n (_ : not (eq X P)) (_ : not (eq X Q)) (_ : not (eq Y P))\n (_ : not (eq Y Q)), OS A C X Y
H1 : not (eq C D)
H0 : not (eq P Q)
H : not (eq A C)
HDij : or (OS A C P Q)\n (or (and (Col P A C) (not (Col Q A C)))\n (and (not (Col P A C)) (Col Q A C)))
HQOut : OutCircleS Q A B
HPIn : InCircleS P A B
HQOn : OnCircle Q C D
HPOn : OnCircle P C D
A,B,C,D,P,Q : Tpoint
dedekind : first_order_dedekind
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
False
+++++
subst; apply HNCol4; ColR.
-----
Lemma fod__circle_circle : first_order_dedekind -> circle_circle.
Proof.
intro dedekind.
apply circle_circle_aux.
intros A B C D P Q HPOn HQOn HPIn HQOut HDij.
assert (A <> C).
assert (P <> Q) by (intro; apply (not_and_lt A P A B); subst; split; trivial).
assert (C <> D) by (intro; treat_equalities; auto).
assert (HOS : forall X Y, Bet P X Q -> Bet P Y Q -> X <> P -> X <> Q -> Y <> P -> Y <> Q -> OS A C X Y).
assert (HNTS : forall X Y, Bet P Y Q -> Bet P X Y -> ~ TS A C X Y).
assert (HLta : LtA A C P A C Q).
assert (HNCol1 : ~ Col P Q C).
assert (Haux : forall X Y X0 Y0, Bet P Y Q -> X <> Y -> OnCircle X0 C D -> Out C X X0 -> OnCircle Y0 C D -> Out C Y Y0 -> Bet P X Y -> Lt A X0 A Y0).
assert (HR : exists R, forall X Y, (Bet P X Q /\\ (exists X0, OnCircle X0 C D /\\ Out C X X0 /\\ InCircle X0 A B)) -> (Bet P Y Q /\\ (exists Y0, OnCircle Y0 C D /\\ Out C Y Y0 /\\ OutCircle Y0 A B)) -> Bet X R Y).
assert (HP : exists X0, OnCircle X0 C D /\\ Out C P X0 /\\ InCircle X0 A B).
exists P; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
assert (HQ : exists Y0, OnCircle Y0 C D /\\ Out C Q Y0 /\\ OutCircle Y0 A B).
exists Q; repeat (split; Circle); apply out_trivial; assert_diffs; auto.
destruct HR as [R HR].
assert (HBet : Bet P R Q) by (apply HR; split; Between).
assert (R <> C) by (intro; subst; apply HNCol1; Col).
destruct (onc_exists C D R) as [Z [HZ1 HZ2]]; auto.
exists Z; split; trivial.
assert (A <> B) by (apply (lt_diff A P), HPIn).
destruct (circle_cases A B Z) as [|[Habs|Habs]]; trivial; exfalso.
-
assert (Q <> R).
assert (HNCol2 : ~ Col C Q R) by (intro; apply HNCol1; ColR).
assert (HT : exists T, OnCircle T A B /\\ Bet A Z T).
destruct HT as [T [HT1 HT2]].
assert (T <> Z).
intro; subst; apply incs__noutc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z Q T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [X0 [HX0On HX0Out]]; auto.
assert (HLt : Lt C X0 C I).
assert (X0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I X0 Z) by (intro; apply (one_side_not_col123 C R I Q); ColR).
assert (HLt1 : Lt X0 Z I Z).
assert (HX0In : InCircleS X0 A B).
assert_diffs.
assert (HX : InAngle X0 R C Q).
destruct HX as [_ [_ [_ [X [HX1 [HX2|HX2]]]]]].
subst; apply HNCol2; Col.
assert (X = R).
apply between_equality with Q; trivial.
apply HR; split; [eBetween|..]; Between.
exists X0; repeat (split; Circle).
subst; apply HNCol4; ColR.
-
assert (P <> R).
assert (HNCol2 : ~ Col C P R) by (intro; apply HNCol1; ColR).
destruct (onc_exists A B Z) as [T [HT1 HT2]]; auto.
apply (lt_diff A B), lt_right_comm, Habs.
assert (HT3 : Bet A T Z).
assert (T <> Z).
intro; subst; apply outcs__ninc in Habs; apply Habs; Circle.
destruct (ex_per_cong C R Z P T Z) as [I [HI1 [HI2 HI3]]]; Col.
assert_diffs.
assert (HNCol3 : ~ Col I Z C) by (apply per_not_col; auto).
destruct (onc_exists C D I) as [Y0 [HY0On HY0Out]]; auto.
assert (HLt : Lt C Y0 C I).
assert (Y0 <> I) by (intro; apply (nlt C I); subst; assumption).
assert (HNCol4 : ~ Col I Y0 Z) by (intro; apply (one_side_not_col123 C R I P); ColR).
assert (HLt1 : Lt Y0 Z I Z).
assert (HY0OutC : OutCircleS Y0 A B).
assert_diffs.
assert (HY : InAngle Y0 P C R).
destruct HY as [_ [_ [_ [Y [HY1 [HY2|HY2]]]]]].
subst; apply HNCol2; Col.
assert (Y = R).
apply between_equality with P; apply between_symmetry; trivial.
apply HR; split; [Between..| |]; [eBetween|].
exists Y0; repeat (split; Circle).
subst; apply HNCol4; ColR.

*****

*****

+++++
Qed.
-----
End Dedekind_circle_circle.
-----
