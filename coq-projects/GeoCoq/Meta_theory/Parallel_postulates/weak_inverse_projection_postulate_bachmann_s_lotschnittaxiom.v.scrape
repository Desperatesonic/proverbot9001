Require Import GeoCoq.Axioms.parallel_postulates.
-----
Require Import GeoCoq.Tarski_dev.Annexes.suma.
-----
Require Import GeoCoq.Tarski_dev.Ch12_parallel.
-----
Section weak_inverse_projection_postulate_bachmann_s_lotschnittaxiom.
-----
Context `{TnEQD:Tarski_neutral_dimensionless_with_decidable_point_equality}.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom :\n  weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : weak_inverse_projection_postulate, bachmann_s_lotschnittaxiom
+++++
Proof.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.

*****
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : weak_inverse_projection_postulate, bachmann_s_lotschnittaxiom
+++++
intro hrap.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.

*****
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
bachmann_s_lotschnittaxiom
+++++
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\ Col D1 D2 I).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall _ : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint) (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2) (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I)), bachmann_s_lotschnittaxiom
+++++
clear hrap; intro lotschnitt.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.

*****
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
bachmann_s_lotschnittaxiom
+++++
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.

*****
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
destruct (eq_dec_points P P1).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
destruct (eq_dec_points P P1).

*****
H : eq P P1
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
subst; exists R; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
destruct (eq_dec_points P P1).
subst; exists R; Col.

*****
H : not (eq P P1)
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
destruct (eq_dec_points R R1).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
destruct (eq_dec_points P P1).
subst; exists R; Col.
destruct (eq_dec_points R R1).

*****
H0 : eq R R1
H : not (eq P P1)
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
subst; exists P; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
destruct (eq_dec_points P P1).
subst; exists R; Col.
destruct (eq_dec_points R R1).
subst; exists P; Col.

*****
H0 : not (eq R R1)
H : not (eq P P1)
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
assert (HNCol : ~ Col P Q R) by (apply per_not_col; auto).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
destruct (eq_dec_points P P1).
subst; exists R; Col.
destruct (eq_dec_points R R1).
subst; exists P; Col.
assert (HNCol : ~ Col P Q R) by (apply per_not_col; auto).

*****
HNCol : not (Col P Q R)
H0 : not (eq R R1)
H : not (eq P P1)
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
destruct (lotschnitt P Q Q R P P1 R R1 Q P R) as [S [HS1 HS2]]; Col; Perp; Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
clear hrap; intro lotschnitt.
intros P Q R P1 R1 HPQ HQR HPerQ HPerP HPerR HCop1 HCop2.
destruct (eq_dec_points P P1).
subst; exists R; Col.
destruct (eq_dec_points R R1).
subst; exists P; Col.
assert (HNCol : ~ Col P Q R) by (apply per_not_col; auto).
destruct (lotschnitt P Q Q R P P1 R R1 Q P R) as [S [HS1 HS2]]; Col; Perp; Cop.

*****
HS2 : Col R R1 S
HS1 : Col P P1 S
S : Tpoint
HNCol : not (Col P Q R)
H0 : not (eq R R1)
H : not (eq P P1)
HCop2 : Coplanar P Q R R1
HCop1 : Coplanar P Q R P1
HPerR : Per Q R R1
HPerP : Per Q P P1
HPerQ : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
P,Q,R,P1,R1 : Tpoint
lotschnitt : forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint)\n (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2)\n (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC)\n (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD)\n (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2)\n (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2)\n (_ : not (Col IAB IAC IBD)),\nex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun S : Tpoint => and (Col P P1 S) (Col R R1 S))
+++++
exists S; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD : Tpoint) (_ : Perp A1 A2 B1 B2) (_ : Perp A1 A2 C1 C2) (_ : Perp B1 B2 D1 D2) (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.

*****
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
forall (_ : Col A1 A2 IAB) (_ : Col B1 B2 IAB) (_ : Col A1 A2 IAC) (_ : Col C1 C2 IAC) (_ : Col B1 B2 IBD) (_ : Col D1 D2 IBD) (_ : Coplanar IAB IAC IBD C1) (_ : Coplanar IAB IAC IBD C2) (_ : Coplanar IAB IAC IBD D1) (_ : Coplanar IAB IAC IBD D2) (_ : not (Col IAB IAC IBD)), ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.

*****
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IAC A1) by (assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).

*****
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IAC A2) by (assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).

*****
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IBD B1) by (assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).

*****
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Col IAB IBD B2) by (assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).

*****
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD A1) by Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.

*****
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD A2) by Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.

*****
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD B1) by Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.

*****
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Coplanar IAB IAC IBD B2) by Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNC2 : ~ Col A1 A2 D1).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col A1 A2 D1)
+++++
apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD; Col; try (intro; apply HNC1; assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
apply par_strict_not_col_1 with D2; apply par_not_col_strict with IBD; Col; try (intro; apply HNC1; assert_diffs; ColR).

*****
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par A1 A2 D1 D2
+++++
apply l12_9 with B1 B2; Perp; CopR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNC3 : ~ Col B1 B2 C1).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col B1 B2 C1)
+++++
apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC; Col; try (intro; apply HNC1; assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
apply par_strict_not_col_1 with C2; apply par_not_col_strict with IAC; Col; try (intro; apply HNC1; assert_diffs; ColR).

*****
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par B1 B2 C1 C2
+++++
apply l12_9 with A1 A2; Perp; CopR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).

*****
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HParA : Par_strict A1 A2 D1 D2).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).

*****
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict A1 A2 D1 D2
+++++
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.

*****
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HParB : Par_strict B1 B2 C1 C2).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).

*****
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Par_strict B1 B2 C1 C2
+++++
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.

*****
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).

*****
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).

*****
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).

*****
HNCol5 : not (Col IAB C1 C2)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).

*****
HNCol6 : not (Col IAB D1 D2)
HNCol5 : not (Col IAB C1 C2)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).

*****
HPQ : not (eq IAC IAB)
HNCol6 : not (Col IAB D1 D2)
HNCol5 : not (Col IAB C1 C2)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).

*****
HQR : not (eq IAB IBD)
HPQ : not (eq IAC IAB)
HNCol6 : not (Col IAB D1 D2)
HNCol5 : not (Col IAB C1 C2)
HNCol4 : not (Col IBD A1 A2)
HNCol3 : not (Col IAC B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar IAB IAC IBD B2
H5 : Coplanar IAB IAC IBD B1
H4 : Coplanar IAB IAC IBD A2
H3 : Coplanar IAB IAC IBD A1
H2 : Col IAB IBD B2
H1 : Col IAB IBD B1
H0 : Col IAB IAC A2
H : Col IAB IAC A1
HNC1 : not (Col IAB IAC IBD)
HCop4 : Coplanar IAB IAC IBD D2
HCop3 : Coplanar IAB IAC IBD D1
HCop2 : Coplanar IAB IAC IBD C2
HCop1 : Coplanar IAB IAC IBD C1
HCol6 : Col D1 D2 IBD
HCol5 : Col B1 B2 IBD
HCol4 : Col C1 C2 IAC
HCol3 : Col A1 A2 IAC
HCol2 : Col B1 B2 IAB
HCol1 : Col A1 A2 IAB
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,IAB,IAC,IBD : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
rename IAB into Q; rename IAC into P; rename IBD into R.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.

*****
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (Per P Q R).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).

*****
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per P Q R
+++++
apply perp_per_2; apply perp_col2 with A1 A2; Col; apply perp_sym; apply perp_col2 with B1 B2; Col; Perp.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).

*****
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).

*****
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.

*****
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HSuma : SumA P Q M P Q M P Q R).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).

*****
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA P Q M P Q M P Q R
+++++
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.

*****
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HAcute : Acute P Q M).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).

*****
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute P Q M
+++++
apply nbet_sams_suma__acute with P Q R; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.

*****
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Bet P Q R)
+++++
intro HBet; apply HNCol7; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.
intro HBet; apply HNCol7; Col.

*****
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q M P Q M
+++++
destruct (sams_dec P Q M P Q M); trivial.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.
intro HBet; apply HNCol7; Col.
destruct (sams_dec P Q M P Q M); trivial.

*****
H8 : not (SAMS P Q M P Q M)
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q M P Q M
+++++
assert_diffs.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.
intro HBet; apply HNCol7; Col.
destruct (sams_dec P Q M P Q M); trivial.
assert_diffs.

*****
H9 : not (eq M Q)
H29 : not (eq A1 D1)
H25 : not (eq A2 D1)
H27 : not (eq B1 C1)
H23 : not (eq B2 C1)
H24 : not (eq P B2)
H20 : not (eq B1 B2)
H22 : not (eq P B1)
H21 : not (eq R A2)
H17 : not (eq A1 A2)
H19 : not (eq R A1)
H18 : not (eq Q C2)
H13 : not (eq C1 C2)
H16 : not (eq Q C1)
H15 : not (eq Q D2)
H11 : not (eq D1 D2)
H12 : not (eq Q D1)
H14 : not (eq P R)
H8 : not (SAMS P Q M P Q M)
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SAMS P Q M P Q M
+++++
exfalso; apply (lea__nlta P Q M P Q R).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.
intro HBet; apply HNCol7; Col.
destruct (sams_dec P Q M P Q M); trivial.
assert_diffs.
exfalso; apply (lea__nlta P Q M P Q R).

*****
H9 : not (eq M Q)
H29 : not (eq A1 D1)
H25 : not (eq A2 D1)
H27 : not (eq B1 C1)
H23 : not (eq B2 C1)
H24 : not (eq P B2)
H20 : not (eq B1 B2)
H22 : not (eq P B1)
H21 : not (eq R A2)
H17 : not (eq A1 A2)
H19 : not (eq R A1)
H18 : not (eq Q C2)
H13 : not (eq C1 C2)
H16 : not (eq Q C1)
H15 : not (eq Q D2)
H11 : not (eq D1 D2)
H12 : not (eq Q D1)
H14 : not (eq P R)
H8 : not (SAMS P Q M P Q M)
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LeA P Q M P Q R
+++++
exists M; split; CongA.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.
intro HBet; apply HNCol7; Col.
destruct (sams_dec P Q M P Q M); trivial.
assert_diffs.
exfalso; apply (lea__nlta P Q M P Q R).
exists M; split; CongA.

*****
H9 : not (eq M Q)
H29 : not (eq A1 D1)
H25 : not (eq A2 D1)
H27 : not (eq B1 C1)
H23 : not (eq B2 C1)
H24 : not (eq P B2)
H20 : not (eq B1 B2)
H22 : not (eq P B1)
H21 : not (eq R A2)
H17 : not (eq A1 A2)
H19 : not (eq R A1)
H18 : not (eq Q C2)
H13 : not (eq C1 C2)
H16 : not (eq Q C1)
H15 : not (eq Q D2)
H11 : not (eq D1 D2)
H12 : not (eq Q D1)
H14 : not (eq P R)
H8 : not (SAMS P Q M P Q M)
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
LtA P Q R P Q M
+++++
apply obtuse_per__lta; trivial.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
apply nbet_sams_suma__acute with P Q R; auto.
intro HBet; apply HNCol7; Col.
destruct (sams_dec P Q M P Q M); trivial.
assert_diffs.
exfalso; apply (lea__nlta P Q M P Q R).
exists M; split; CongA.
apply obtuse_per__lta; trivial.

*****
H9 : not (eq M Q)
H29 : not (eq A1 D1)
H25 : not (eq A2 D1)
H27 : not (eq B1 C1)
H23 : not (eq B2 C1)
H24 : not (eq P B2)
H20 : not (eq B1 B2)
H22 : not (eq P B1)
H21 : not (eq R A2)
H17 : not (eq A1 A2)
H19 : not (eq R A1)
H18 : not (eq Q C2)
H13 : not (eq C1 C2)
H16 : not (eq Q C1)
H15 : not (eq Q D2)
H11 : not (eq D1 D2)
H12 : not (eq Q D1)
H14 : not (eq P R)
H8 : not (SAMS P Q M P Q M)
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Obtuse P Q M
+++++
apply nsams__obtuse; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).

*****
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HC3 : exists C3, Col C1 C2 C3 /\ OS P Q R C3).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).

*****
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (OS P Q R C3))
+++++
destruct (diff_col_ex3 C1 C2 P) as [C0]; Col; spliter.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct (diff_col_ex3 C1 C2 P) as [C0]; Col; spliter.

*****
H11 : Col C1 C2 C0
H10 : not (eq P C0)
H9 : not (eq C2 C0)
H8 : not (eq C1 C0)
C0 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (OS P Q R C3))
+++++
destruct (cop_not_par_same_side P Q C0 P P R) as [C3 []]; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct (diff_col_ex3 C1 C2 P) as [C0]; Col; spliter.
destruct (cop_not_par_same_side P Q C0 P P R) as [C3 []]; Col.

*****
H11 : Col C1 C2 C0
H10 : not (eq P C0)
H9 : not (eq C2 C0)
H8 : not (eq C1 C0)
C0 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col P Q C0)
+++++
intro; apply HNCol5; ColR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct (diff_col_ex3 C1 C2 P) as [C0]; Col; spliter.
destruct (cop_not_par_same_side P Q C0 P P R) as [C3 []]; Col.
intro; apply HNCol5; ColR.

*****
H11 : Col C1 C2 C0
H10 : not (eq P C0)
H9 : not (eq C2 C0)
H8 : not (eq C1 C0)
C0 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q C0 R
+++++
assert (Coplanar P Q R C0); [|Cop].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct (diff_col_ex3 C1 C2 P) as [C0]; Col; spliter.
destruct (cop_not_par_same_side P Q C0 P P R) as [C3 []]; Col.
intro; apply HNCol5; ColR.
assert (Coplanar P Q R C0); [|Cop].

*****
H11 : Col C1 C2 C0
H10 : not (eq P C0)
H9 : not (eq C2 C0)
H8 : not (eq C1 C0)
C0 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q R C0
+++++
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct (diff_col_ex3 C1 C2 P) as [C0]; Col; spliter.
destruct (cop_not_par_same_side P Q C0 P P R) as [C3 []]; Col.
intro; apply HNCol5; ColR.
assert (Coplanar P Q R C0); [|Cop].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.

*****
H13 : OS P Q R C3
H12 : Col C0 P C3
C3 : Tpoint
H11 : Col C1 C2 C0
H10 : not (eq P C0)
H9 : not (eq C2 C0)
H8 : not (eq C1 C0)
C0 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun C3 : Tpoint => and (Col C1 C2 C3) (OS P Q R C3))
+++++
exists C3; split; trivial; ColR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).

*****
HC3 : ex (fun C3 : Tpoint => and (Col C1 C2 C3) (OS P Q R C3))
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct HC3 as [C3 [HCol7 HOS1]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].

*****
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.

*****
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q P P
+++++
apply out_trivial; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.

*****
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq P C3)
+++++
assert_diffs; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.

*****
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per Q P C3
+++++
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].

*****
HP3 : forall (U V : Tpoint) (_ : Col U A1 A2) (_ : Col V C1 C2), Per U P' V
HP2 : Col P' C1 C2
HP1 : Col P' A1 A2
P' : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per Q P C3
+++++
assert (P = P'); [|treat_equalities; apply HP3; Col].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].

*****
HP3 : forall (U V : Tpoint) (_ : Col U A1 A2) (_ : Col V C1 C2), Per U P' V
HP2 : Col P' C1 C2
HP1 : Col P' A1 A2
P' : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq P P'
+++++
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.

*****
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q M C3
+++++
assert (Coplanar P Q R M) by Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.

*****
H8 : Coplanar P Q R M
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q M C3
+++++
assert (Coplanar P Q R C3); [|CopR].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].

*****
H8 : Coplanar P Q R M
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q R C3
+++++
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.

*****
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HD3 : exists D3, Col D1 D2 D3 /\ OS R Q P D3).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).

*****
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D3 : Tpoint => and (Col D1 D2 D3) (OS R Q P D3))
+++++
destruct (diff_col_ex3 D1 D2 R) as [D0]; Col; spliter.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct (diff_col_ex3 D1 D2 R) as [D0]; Col; spliter.

*****
H11 : Col D1 D2 D0
H10 : not (eq R D0)
H9 : not (eq D2 D0)
H8 : not (eq D1 D0)
D0 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D3 : Tpoint => and (Col D1 D2 D3) (OS R Q P D3))
+++++
destruct (cop_not_par_same_side R Q D0 R R P) as [D3 []]; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct (diff_col_ex3 D1 D2 R) as [D0]; Col; spliter.
destruct (cop_not_par_same_side R Q D0 R R P) as [D3 []]; Col.

*****
H11 : Col D1 D2 D0
H10 : not (eq R D0)
H9 : not (eq D2 D0)
H8 : not (eq D1 D0)
D0 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (Col R Q D0)
+++++
intro; apply HNCol6; ColR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct (diff_col_ex3 D1 D2 R) as [D0]; Col; spliter.
destruct (cop_not_par_same_side R Q D0 R R P) as [D3 []]; Col.
intro; apply HNCol6; ColR.

*****
H11 : Col D1 D2 D0
H10 : not (eq R D0)
H9 : not (eq D2 D0)
H8 : not (eq D1 D0)
D0 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar R Q D0 P
+++++
assert (Coplanar P Q R D0); [|CopR].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct (diff_col_ex3 D1 D2 R) as [D0]; Col; spliter.
destruct (cop_not_par_same_side R Q D0 R R P) as [D3 []]; Col.
intro; apply HNCol6; ColR.
assert (Coplanar P Q R D0); [|CopR].

*****
H11 : Col D1 D2 D0
H10 : not (eq R D0)
H9 : not (eq D2 D0)
H8 : not (eq D1 D0)
D0 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q R D0
+++++
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct (diff_col_ex3 D1 D2 R) as [D0]; Col; spliter.
destruct (cop_not_par_same_side R Q D0 R R P) as [D3 []]; Col.
intro; apply HNCol6; ColR.
assert (Coplanar P Q R D0); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.

*****
H13 : OS R Q P D3
H12 : Col D0 R D3
D3 : Tpoint
H11 : Col D1 D2 D0
H10 : not (eq R D0)
H9 : not (eq D2 D0)
H8 : not (eq D1 D0)
D0 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun D3 : Tpoint => and (Col D1 D2 D3) (OS R Q P D3))
+++++
exists D3; split; trivial; ColR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).

*****
HD3 : ex (fun D3 : Tpoint => and (Col D1 D2 D3) (OS R Q P D3))
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct HD3 as [D3 [HCol8 HOS2]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Acute R Q M
+++++
apply (acute_conga__acute P Q M); CongA.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
SumA R Q M R Q M R Q P
+++++
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Out Q R R
+++++
apply out_trivial; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
not (eq R D3)
+++++
assert_diffs; auto.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per Q R D3
+++++
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].

*****
HR3 : forall (U V : Tpoint) (_ : Col U B1 B2) (_ : Col V D1 D2), Per U R' V
HR2 : Col R' D1 D2
HR1 : Col R' B1 B2
R' : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Per Q R D3
+++++
assert (R = R'); [|treat_equalities; apply HR3; Col].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].

*****
HR3 : forall (U V : Tpoint) (_ : Col U B1 B2) (_ : Col V D1 D2), Per U R' V
HR2 : Col R' D1 D2
HR1 : Col R' B1 B2
R' : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
eq R R'
+++++
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.

*****
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar R Q M D3
+++++
assert (Coplanar P Q R M) by Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.

*****
H8 : Coplanar P Q R M
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar R Q M D3
+++++
assert (Coplanar P Q R D3); [|CopR].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].

*****
H8 : Coplanar P Q R M
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
Coplanar P Q R D3
+++++
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.

*****
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).

*****
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).

*****
HCol9 : Col C1 C2 S
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).

*****
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (col_dec C1 C2 T).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).

*****
H8 : Col C1 C2 T
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
exists T; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.

*****
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct (col_dec D1 D2 S).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).

*****
H9 : Col D1 D2 S
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
exists S; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HOut : Out Q S T
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
-
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HTS : TS C1 C2 R T).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C1 C2 R T
+++++
apply l9_8_2 with Q.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS C1 C2 Q T
+++++
repeat split; Col; exists S; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS C1 C2 Q R
+++++
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.

*****
HTS : TS C1 C2 R T
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert_diffs.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.

*****
H43 : not (eq Q C3)
H37 : not (eq P C3)
H41 : not (eq Q D3)
H33 : not (eq R D3)
H39 : not (eq R T)
H36 : not (eq C2 R)
H35 : not (eq C1 R)
H11 : not (eq M Q)
H34 : not (eq A1 D1)
H30 : not (eq A2 D1)
H32 : not (eq B1 C1)
H28 : not (eq B2 C1)
H29 : not (eq P B2)
H25 : not (eq B1 B2)
H27 : not (eq P B1)
H26 : not (eq R A2)
H17 : not (eq A1 A2)
H23 : not (eq R A1)
H24 : not (eq Q C2)
H20 : not (eq Q C1)
H22 : not (eq Q D2)
H19 : not (eq Q D1)
H21 : not (eq P R)
H18 : not (eq C1 T)
H14 : not (eq C2 T)
H16 : not (eq C1 C2)
H15 : not (eq D1 S)
H12 : not (eq D2 S)
H13 : not (eq D1 D2)
HTS : TS C1 C2 R T
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct HTS as [_ [_ [I [HI1 HI2]]]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].

*****
H43 : not (eq Q C3)
H37 : not (eq P C3)
H41 : not (eq Q D3)
H33 : not (eq R D3)
H39 : not (eq R T)
H36 : not (eq C2 R)
H35 : not (eq C1 R)
H11 : not (eq M Q)
H34 : not (eq A1 D1)
H30 : not (eq A2 D1)
H32 : not (eq B1 C1)
H28 : not (eq B2 C1)
H29 : not (eq P B2)
H25 : not (eq B1 B2)
H27 : not (eq P B1)
H26 : not (eq R A2)
H17 : not (eq A1 A2)
H23 : not (eq R A1)
H24 : not (eq Q C2)
H20 : not (eq Q C1)
H22 : not (eq Q D2)
H19 : not (eq Q D1)
H21 : not (eq P R)
H18 : not (eq C1 T)
H14 : not (eq C2 T)
H16 : not (eq C1 C2)
H15 : not (eq D1 S)
H12 : not (eq D2 S)
H13 : not (eq D1 D2)
HI2 : Bet R I T
HI1 : Col I C1 C2
I : Tpoint
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q S T
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
exists I; split; ColR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.

*****

*****

+++++
-
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert (HTS : TS D1 D2 P S).
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-
assert (HTS : TS D1 D2 P S).

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS D1 D2 P S
+++++
apply l9_8_2 with Q.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-
assert (HTS : TS D1 D2 P S).
apply l9_8_2 with Q.

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
TS D1 D2 Q S
+++++
repeat split; Col; exists T; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-
assert (HTS : TS D1 D2 P S).
apply l9_8_2 with Q.
repeat split; Col; exists T; Col.

*****
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
OS D1 D2 Q P
+++++
apply l12_6, par_strict_col2_par_strict with A1 A2; Par; Col.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-
assert (HTS : TS D1 D2 P S).
apply l9_8_2 with Q.
repeat split; Col; exists T; Col.
apply l12_6, par_strict_col2_par_strict with A1 A2; Par; Col.

*****
HTS : TS D1 D2 P S
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
assert_diffs.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-
assert (HTS : TS D1 D2 P S).
apply l9_8_2 with Q.
repeat split; Col; exists T; Col.
apply l12_6, par_strict_col2_par_strict with A1 A2; Par; Col.
assert_diffs.

*****
H43 : not (eq Q C3)
H37 : not (eq P C3)
H41 : not (eq Q D3)
H33 : not (eq R D3)
H39 : not (eq P S)
H36 : not (eq D2 P)
H35 : not (eq D1 P)
H11 : not (eq M Q)
H34 : not (eq A1 D1)
H30 : not (eq A2 D1)
H32 : not (eq B1 C1)
H28 : not (eq B2 C1)
H29 : not (eq P B2)
H25 : not (eq B1 B2)
H27 : not (eq P B1)
H26 : not (eq R A2)
H17 : not (eq A1 A2)
H23 : not (eq R A1)
H24 : not (eq Q C2)
H20 : not (eq Q C1)
H22 : not (eq Q D2)
H19 : not (eq Q D1)
H21 : not (eq P R)
H18 : not (eq C1 T)
H14 : not (eq C2 T)
H16 : not (eq C1 C2)
H15 : not (eq D1 S)
H12 : not (eq D2 S)
H13 : not (eq D1 D2)
HTS : TS D1 D2 P S
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
destruct HTS as [_ [_ [I [HI1 HI2]]]].
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).
intros A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD HPerpAB HPerpAC HPerpBD.
intros HCol1 HCol2 HCol3 HCol4 HCol5 HCol6 HCop1 HCop2 HCop3 HCop4 HNC1.
assert (Col IAB IAC A1) by (assert_diffs; ColR).
assert (Col IAB IAC A2) by (assert_diffs; ColR).
assert (Col IAB IBD B1) by (assert_diffs; ColR).
assert (Col IAB IBD B2) by (assert_diffs; ColR).
assert (Coplanar IAB IAC IBD A1) by Cop.
assert (Coplanar IAB IAC IBD A2) by Cop.
assert (Coplanar IAB IAC IBD B1) by Cop.
assert (Coplanar IAB IAC IBD B2) by Cop.
assert (HNC2 : ~ Col A1 A2 D1).
assert (HNC3 : ~ Col B1 B2 C1).
assert (HParA : Par_strict A1 A2 D1 D2).
apply par_not_col_strict with D1; Col; apply l12_9 with B1 B2; Perp; CopR.
assert (HParB : Par_strict B1 B2 C1 C2).
apply par_not_col_strict with C1; Col; apply l12_9 with A1 A2; Perp; CopR.
assert (HNCol3 : ~ Col IAC B1 B2) by (apply par_not_col with C1 C2; Par; ColR).
assert (HNCol4 : ~ Col IBD A1 A2) by (apply par_not_col with D1 D2; Par; ColR).
assert (HNCol5 : ~ Col IAB C1 C2) by (apply par_not_col with B1 B2; Par; ColR).
assert (HNCol6 : ~ Col IAB D1 D2) by (apply par_not_col with A1 A2; Par; ColR).
assert (HPQ : IAC <> IAB) by (assert_diffs; auto).
assert (HQR : IAB <> IBD) by (assert_diffs; auto).
rename IAB into Q; rename IAC into P; rename IBD into R.
assert (Per P Q R).
assert (HNCol7 : ~ Col P Q R) by (apply per_not_col; trivial).
destruct (angle_bisector P Q R) as [M [HM1 HM2]]; auto.
assert (HSuma : SumA P Q M P Q M P Q R).
assert_diffs; apply conga3_suma__suma with P Q M M Q R P Q R; CongA; SumA.
assert (HAcute : Acute P Q M).
assert (HC3 : exists C3, Col C1 C2 C3 /\\ OS P Q R C3).
destruct HC3 as [C3 [HCol7 HOS1]].
destruct (hrap P Q M P Q R P C3) as [S [HS1 HS2]]; trivial.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpAC); destruct HP as [P' [_ [_ [HP1 [HP2 HP3]]]]].
assert (P = P'); [|treat_equalities; apply HP3; Col].
elim (perp_not_col2 _ _ _ _ HPerpAC); intro; assert_diffs; [apply l6_21 with A1 A2 C1 C2|apply l6_21 with A1 A2 C2 C1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R C3); [|CopR].
assert_diffs; apply col_cop2__cop with C1 C2; Col; Cop.
assert (HD3 : exists D3, Col D1 D2 D3 /\\ OS R Q P D3).
destruct HD3 as [D3 [HCol8 HOS2]].
destruct (hrap R Q M R Q P R D3) as [T [HT1 HT2]]; Perp.
apply (acute_conga__acute P Q M); CongA.
assert_diffs; apply conga3_suma__suma with P Q M P Q M P Q R; CongA.
apply out_trivial; auto.
assert_diffs; auto.
assert (HP := HPerpBD); destruct HP as [R' [_ [_ [HR1 [HR2 HR3]]]]].
assert (R = R'); [|treat_equalities; apply HR3; Col].
elim (perp_not_col2 _ _ _ _ HPerpBD); intro; assert_diffs; [apply l6_21 with B1 B2 D1 D2|apply l6_21 with B1 B2 D2 D1]; Col.
assert (Coplanar P Q R M) by Cop.
assert (Coplanar P Q R D3); [|CopR].
assert_diffs; apply col_cop2__cop with D1 D2; Col; Cop.
assert (HOut : Out Q S T) by (apply l6_7 with M; trivial; apply l6_6; assumption).
assert (HCol9 : Col C1 C2 S) by (assert_diffs; ColR).
assert (HCol10 : Col D1 D2 T) by (assert_diffs; ColR).
destruct (col_dec C1 C2 T).
exists T; Col.
destruct (col_dec D1 D2 S).
exists S; Col.
destruct HOut as [HSQ [HTQ [HBet|HBet]]].
-
assert (HTS : TS C1 C2 R T).
apply l9_8_2 with Q.
repeat split; Col; exists S; Col.
apply l12_6, par_strict_col2_par_strict with B1 B2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].
exists I; split; ColR.
-
assert (HTS : TS D1 D2 P S).
apply l9_8_2 with Q.
repeat split; Col; exists T; Col.
apply l12_6, par_strict_col2_par_strict with A1 A2; Par; Col.
assert_diffs.
destruct HTS as [_ [_ [I [HI1 HI2]]]].

*****
H43 : not (eq Q C3)
H37 : not (eq P C3)
H41 : not (eq Q D3)
H33 : not (eq R D3)
H39 : not (eq P S)
H36 : not (eq D2 P)
H35 : not (eq D1 P)
H11 : not (eq M Q)
H34 : not (eq A1 D1)
H30 : not (eq A2 D1)
H32 : not (eq B1 C1)
H28 : not (eq B2 C1)
H29 : not (eq P B2)
H25 : not (eq B1 B2)
H27 : not (eq P B1)
H26 : not (eq R A2)
H17 : not (eq A1 A2)
H23 : not (eq R A1)
H24 : not (eq Q C2)
H20 : not (eq Q C1)
H22 : not (eq Q D2)
H19 : not (eq Q D1)
H21 : not (eq P R)
H18 : not (eq C1 T)
H14 : not (eq C2 T)
H16 : not (eq C1 C2)
H15 : not (eq D1 S)
H12 : not (eq D2 S)
H13 : not (eq D1 D2)
HI2 : Bet P I S
HI1 : Col I D1 D2
I : Tpoint
H9 : not (Col D1 D2 S)
H8 : not (Col C1 C2 T)
HCol10 : Col D1 D2 T
HCol9 : Col C1 C2 S
HBet : Bet Q T S
HTQ : not (eq T Q)
HSQ : not (eq S Q)
HT2 : Col R D3 T
HT1 : Out Q M T
T : Tpoint
HOS2 : OS R Q P D3
HCol8 : Col D1 D2 D3
D3 : Tpoint
HS2 : Col P C3 S
HS1 : Out Q M S
S : Tpoint
HOS1 : OS P Q R C3
HCol7 : Col C1 C2 C3
C3 : Tpoint
HAcute : Acute P Q M
HSuma : SumA P Q M P Q M P Q R
HM2 : CongA M Q P M Q R
HM1 : InAngle M P Q R
M : Tpoint
HNCol7 : not (Col P Q R)
H7 : Per P Q R
HQR : not (eq Q R)
HPQ : not (eq P Q)
HNCol6 : not (Col Q D1 D2)
HNCol5 : not (Col Q C1 C2)
HNCol4 : not (Col R A1 A2)
HNCol3 : not (Col P B1 B2)
HParB : Par_strict B1 B2 C1 C2
HParA : Par_strict A1 A2 D1 D2
HNC3 : not (Col B1 B2 C1)
HNC2 : not (Col A1 A2 D1)
H6 : Coplanar Q P R B2
H5 : Coplanar Q P R B1
H4 : Coplanar Q P R A2
H3 : Coplanar Q P R A1
H2 : Col Q R B2
H1 : Col Q R B1
H0 : Col Q P A2
H : Col Q P A1
HNC1 : not (Col Q P R)
HCop4 : Coplanar Q P R D2
HCop3 : Coplanar Q P R D1
HCop2 : Coplanar Q P R C2
HCop1 : Coplanar Q P R C1
HCol6 : Col D1 D2 R
HCol5 : Col B1 B2 R
HCol4 : Col C1 C2 P
HCol3 : Col A1 A2 P
HCol2 : Col B1 B2 Q
HCol1 : Col A1 A2 Q
HPerpBD : Perp B1 B2 D1 D2
HPerpAC : Perp A1 A2 C1 C2
HPerpAB : Perp A1 A2 B1 B2
A1,A2,B1,B2,C1,C2,D1,D2,Q,P,R : Tpoint
hrap : weak_inverse_projection_postulate
TnEQD : Tarski_neutral_dimensionless_with_decidable_point_equality Tn
Tn : Tarski_neutral_dimensionless
*****
ex (fun I : Tpoint => and (Col C1 C2 I) (Col D1 D2 I))
+++++
exists I; split; ColR.
-----
Lemma weak_inverse_projection_postulate__bachmann_s_lotschnittaxiom : weak_inverse_projection_postulate -> bachmann_s_lotschnittaxiom.
Proof.
intro hrap.
cut (forall A1 A2 B1 B2 C1 C2 D1 D2 IAB IAC IBD, Perp A1 A2 B1 B2 -> Perp A1 A2 C1 C2 -> Perp B1 B2 D1 D2 -> Col A1 A2 IAB -> Col B1 B2 IAB -> Col A1 A2 IAC -> Col C1 C2 IAC -> Col B1 B2 IBD -> Col D1 D2 IBD -> Coplanar IAB IAC IBD C1 -> Coplanar IAB IAC IBD C2 -> Coplanar IAB IAC IBD D1 -> Coplanar IAB IAC IBD D2 -> ~ Col IAB IAC IBD -> exists I, Col C1 C2 I /\\ Col D1 D2 I).

*****

*****

+++++
Qed.
-----
End weak_inverse_projection_postulate_bachmann_s_lotschnittaxiom.
-----
