From Coq Require Import BinNat.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Require Import Fset.
-----
Require Import Mapaxioms.
-----
Require Import Mapsubset.
-----
Require Import Mapcard.
-----
Require Import Mapcanon.
-----
Require Import Mapc.
-----
From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
From Coq Require Import List.
-----
From Coq Require Import Arith.
-----
Require Import Mapiter.
-----
Require Import Mapfold.
-----
Section MapLists.
-----
Fixpoint ad_in_list (a:ad) (l:list ad) {struct l} : bool :=\n    match l with\n    | nil => false\n    | a' :: l' => orb (Neqb a a') (ad_in_list a l')\n    end.
-----
Fixpoint ad_list_stutters (l:list ad) : bool :=\n    match l with\n    | nil => false\n    | a :: l' => orb (ad_in_list a l') (ad_list_stutters l')\n    end.
-----
Lemma ad_in_list_forms_circuit :\n   forall (x:ad) (l:list ad),\n     ad_in_list x l = true ->\n     {l1 : list ad &  {l2 : list ad | l = l1 ++ x :: l2}}.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.

*****

*****
forall (x : ad) (l : list ad) (_ : eq (ad_in_list x l) true), sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l (app l1 (cons x l2))))
+++++
Proof.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.

*****

*****
forall (x : ad) (l : list ad) (_ : eq (ad_in_list x l) true), sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l (app l1 (cons x l2))))
+++++
simple induction l.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.

*****
l : list ad
x : ad
*****
forall _ : eq (ad_in_list x nil) true, sigT (fun l1 : list ad => sig (fun l2 : list ad => eq nil (app l1 (cons x l2))))
+++++
intro.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intro.

*****
H : eq (ad_in_list x nil) true
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq nil (app l1 (cons x l2))))
+++++
discriminate H.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.

*****
l : list ad
x : ad
*****
forall (a : ad) (l : list ad) (_ : forall _ : eq (ad_in_list x l) true, sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l (app l1 (cons x l2))))) (_ : eq (ad_in_list x (cons a l)) true), sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l) (app l1 (cons x l2))))
+++++
intros.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_in_list x (cons a l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
elim (sumbool_of_bool (Neqb x a)).
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).

*****
H0 : eq (ad_in_list x (cons a l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
forall _ : eq (N.eqb x a) true, sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
intro H1.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H1.

*****
H1 : eq (N.eqb x a) true
H0 : eq (ad_in_list x (cons a l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
simpl in H0.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H1.
simpl in H0.

*****
H1 : eq (N.eqb x a) true
H0 : eq (orb (N.eqb x a) (ad_in_list x l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
split with (nil (A:=ad)).
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H1.
simpl in H0.
split with (nil (A:=ad)).

*****
H1 : eq (N.eqb x a) true
H0 : eq (orb (N.eqb x a) (ad_in_list x l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sig (fun l2 : list ad => eq (cons a l0) (app nil (cons x l2)))
+++++
split with l0.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H1.
simpl in H0.
split with (nil (A:=ad)).
split with l0.

*****
H1 : eq (N.eqb x a) true
H0 : eq (orb (N.eqb x a) (ad_in_list x l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
eq (cons a l0) (app nil (cons x l0))
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H1.
simpl in H0.
split with (nil (A:=ad)).
split with l0.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb x a) true
H0 : eq (orb (N.eqb x a) (ad_in_list x l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
eq (cons a l0) (app nil (cons a l0))
+++++
reflexivity.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).

*****
H0 : eq (ad_in_list x (cons a l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
forall _ : eq (N.eqb x a) false, sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
intro H2.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.

*****
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x (cons a l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
simpl in H0.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.

*****
H2 : eq (N.eqb x a) false
H0 : eq (orb (N.eqb x a) (ad_in_list x l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
rewrite H2 in H0.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.

*****
H2 : eq (N.eqb x a) false
H0 : eq (orb false (ad_in_list x l0)) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
simpl in H0.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.

*****
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
elim (H H0).
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).

*****
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
forall (x0 : list ad) (_ : sig (fun l2 : list ad => eq l0 (app x0 (cons x l2)))), sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
intros l'1 H3.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).
intros l'1 H3.

*****
H3 : sig (fun l2 : list ad => eq l0 (app l'1 (cons x l2)))
l'1 : list ad
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app l1 (cons x l2))))
+++++
split with (a :: l'1).
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).
intros l'1 H3.
split with (a :: l'1).

*****
H3 : sig (fun l2 : list ad => eq l0 (app l'1 (cons x l2)))
l'1 : list ad
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sig (fun l2 : list ad => eq (cons a l0) (app (cons a l'1) (cons x l2)))
+++++
elim H3.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).
intros l'1 H3.
split with (a :: l'1).
elim H3.

*****
H3 : sig (fun l2 : list ad => eq l0 (app l'1 (cons x l2)))
l'1 : list ad
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
forall (x0 : list ad) (_ : eq l0 (app l'1 (cons x x0))), sig (fun l2 : list ad => eq (cons a l0) (app (cons a l'1) (cons x l2)))
+++++
intros l2 H4.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).
intros l'1 H3.
split with (a :: l'1).
elim H3.
intros l2 H4.

*****
H4 : eq l0 (app l'1 (cons x l2))
l2 : list ad
H3 : sig (fun l2 : list ad => eq l0 (app l'1 (cons x l2)))
l'1 : list ad
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
sig (fun l2 : list ad => eq (cons a l0) (app (cons a l'1) (cons x l2)))
+++++
split with l2.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).
intros l'1 H3.
split with (a :: l'1).
elim H3.
intros l2 H4.
split with l2.

*****
H4 : eq l0 (app l'1 (cons x l2))
l2 : list ad
H3 : sig (fun l2 : list ad => eq l0 (app l'1 (cons x l2)))
l'1 : list ad
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
eq (cons a l0) (app (cons a l'1) (cons x l2))
+++++
rewrite H4.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.
intros.
elim (sumbool_of_bool (Neqb x a)).
intro H2.
simpl in H0.
rewrite H2 in H0.
simpl in H0.
elim (H H0).
intros l'1 H3.
split with (a :: l'1).
elim H3.
intros l2 H4.
split with l2.
rewrite H4.

*****
H4 : eq l0 (app l'1 (cons x l2))
l2 : list ad
H3 : sig (fun l2 : list ad => eq l0 (app l'1 (cons x l2)))
l'1 : list ad
H2 : eq (N.eqb x a) false
H0 : eq (ad_in_list x l0) true
H : forall _ : eq (ad_in_list x l0) true,\nsigT\n (fun l1 : list ad =>\n sig (fun l2 : list ad => eq l0 (app l1 (cons x l2))))
l0 : list ad
a : ad
l : list ad
x : ad
*****
eq (cons a (app l'1 (cons x l2))) (app (cons a l'1) (cons x l2))
+++++
reflexivity.
-----
Lemma ad_in_list_forms_circuit : forall (x:ad) (l:list ad), ad_in_list x l = true -> {l1 : list ad & {l2 : list ad | l = l1 ++ x :: l2}}.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_has_circuit :\n   forall l:list ad,\n     ad_list_stutters l = true ->\n     {x : ad & \n     {l0 : list ad & \n     {l1 : list ad &  {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.

*****

*****
forall (l : list ad) (_ : eq (ad_list_stutters l) true), sigT (fun x : ad => sigT (fun l0 : list ad => sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l (app l0 (cons x (app l1 (cons x l2))))))))
+++++
Proof.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.

*****

*****
forall (l : list ad) (_ : eq (ad_list_stutters l) true), sigT (fun x : ad => sigT (fun l0 : list ad => sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l (app l0 (cons x (app l1 (cons x l2))))))))
+++++
simple induction l.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.

*****
l : list ad
*****
forall _ : eq (ad_list_stutters nil) true, sigT (fun x : ad => sigT (fun l0 : list ad => sigT (fun l1 : list ad => sig (fun l2 : list ad => eq nil (app l0 (cons x (app l1 (cons x l2))))))))
+++++
intro.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intro.

*****
H : eq (ad_list_stutters nil) true
l : list ad
*****
sigT (fun x : ad => sigT (fun l0 : list ad => sigT (fun l1 : list ad => sig (fun l2 : list ad => eq nil (app l0 (cons x (app l1 (cons x l2))))))))
+++++
discriminate H.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall _ : eq (ad_list_stutters l) true, sigT (fun x : ad => sigT (fun l0 : list ad => sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l (app l0 (cons x (app l1 (cons x l2))))))))) (_ : eq (ad_list_stutters (cons a l)) true), sigT (fun x : ad => sigT (fun l0 : list ad => sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l) (app l0 (cons x (app l1 (cons x l2))))))))
+++++
intros.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_list_stutters (cons a l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
simpl in H0.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
elim (orb_true_elim _ _ H0).
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_in_list a l0) true, sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
intro H1.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
split with a.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons a (app l2 (cons a l3)))))))
+++++
split with (nil (A:=ad)).
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (app nil (cons a (app l1 (cons a l2))))))
+++++
simpl in |- *.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (cons a (app l1 (cons a l2)))))
+++++
elim (ad_in_list_forms_circuit a l0 H1).
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall (x : list ad) (_ : sig (fun l2 : list ad => eq l0 (app x (cons a l2)))), sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (cons a (app l1 (cons a l2)))))
+++++
intros l1 H2.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).
intros l1 H2.

*****
H2 : sig (fun l2 : list ad => eq l0 (app l1 (cons a l2)))
l1 : list ad
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l1 : list ad => sig (fun l2 : list ad => eq (cons a l0) (cons a (app l1 (cons a l2)))))
+++++
split with l1.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).
intros l1 H2.
split with l1.

*****
H2 : sig (fun l2 : list ad => eq l0 (app l1 (cons a l2)))
l1 : list ad
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sig (fun l2 : list ad => eq (cons a l0) (cons a (app l1 (cons a l2))))
+++++
elim H2.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).
intros l1 H2.
split with l1.
elim H2.

*****
H2 : sig (fun l2 : list ad => eq l0 (app l1 (cons a l2)))
l1 : list ad
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall (x : list ad) (_ : eq l0 (app l1 (cons a x))), sig (fun l2 : list ad => eq (cons a l0) (cons a (app l1 (cons a l2))))
+++++
intros l2 H3.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).
intros l1 H2.
split with l1.
elim H2.
intros l2 H3.

*****
H3 : eq l0 (app l1 (cons a l2))
l2 : list ad
H2 : sig (fun l2 : list ad => eq l0 (app l1 (cons a l2)))
l1 : list ad
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sig (fun l2 : list ad => eq (cons a l0) (cons a (app l1 (cons a l2))))
+++++
split with l2.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).
intros l1 H2.
split with l1.
elim H2.
intros l2 H3.
split with l2.

*****
H3 : eq l0 (app l1 (cons a l2))
l2 : list ad
H2 : sig (fun l2 : list ad => eq l0 (app l1 (cons a l2)))
l1 : list ad
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
eq (cons a l0) (cons a (app l1 (cons a l2)))
+++++
rewrite H3.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
split with a.
split with (nil (A:=ad)).
simpl in |- *.
elim (ad_in_list_forms_circuit a l0 H1).
intros l1 H2.
split with l1.
elim H2.
intros l2 H3.
split with l2.
rewrite H3.

*****
H3 : eq l0 (app l1 (cons a l2))
l2 : list ad
H2 : sig (fun l2 : list ad => eq l0 (app l1 (cons a l2)))
l1 : list ad
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
eq (cons a (app l1 (cons a l2))) (cons a (app l1 (cons a l2)))
+++++
reflexivity.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_list_stutters l0) true, sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
intro H1.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
elim (H H1).
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall (x : ad) (_ : sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))))), sigT (fun x0 : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x0 (app l2 (cons x0 l3))))))))
+++++
intros x H2.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.

*****
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun x : ad => sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3))))))))
+++++
split with x.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.

*****
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3)))))))
+++++
elim H2.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.

*****
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall (x0 : list ad) (_ : sigT (fun l1 : list ad => sig (fun l2 : list ad => eq l0 (app x0 (cons x (app l1 (cons x l2))))))), sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3)))))))
+++++
intros l1 H3.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.

*****
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l1 : list ad => sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app l1 (cons x (app l2 (cons x l3)))))))
+++++
split with (a :: l1).
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).

*****
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3))))))
+++++
elim H3.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.

*****
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall (x0 : list ad) (_ : sig (fun l2 : list ad => eq l0 (app l1 (cons x (app x0 (cons x l2)))))), sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3))))))
+++++
intros l2 H4.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.
intros l2 H4.

*****
H4 : sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))
l2 : list ad
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sigT (fun l2 : list ad => sig (fun l3 : list ad => eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3))))))
+++++
split with l2.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.
intros l2 H4.
split with l2.

*****
H4 : sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))
l2 : list ad
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sig (fun l3 : list ad => eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3)))))
+++++
elim H4.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.
intros l2 H4.
split with l2.
elim H4.

*****
H4 : sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))
l2 : list ad
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
forall (x0 : list ad) (_ : eq l0 (app l1 (cons x (app l2 (cons x x0))))), sig (fun l3 : list ad => eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3)))))
+++++
intros l3 H5.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.
intros l2 H4.
split with l2.
elim H4.
intros l3 H5.

*****
H5 : eq l0 (app l1 (cons x (app l2 (cons x l3))))
l3 : list ad
H4 : sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))
l2 : list ad
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
sig (fun l3 : list ad => eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3)))))
+++++
split with l3.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.
intros l2 H4.
split with l2.
elim H4.
intros l3 H5.
split with l3.

*****
H5 : eq l0 (app l1 (cons x (app l2 (cons x l3))))
l3 : list ad
H4 : sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))
l2 : list ad
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
eq (cons a l0) (app (cons a l1) (cons x (app l2 (cons x l3))))
+++++
rewrite H5.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.
intros.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
elim (H H1).
intros x H2.
split with x.
elim H2.
intros l1 H3.
split with (a :: l1).
elim H3.
intros l2 H4.
split with l2.
elim H4.
intros l3 H5.
split with l3.
rewrite H5.

*****
H5 : eq l0 (app l1 (cons x (app l2 (cons x l3))))
l3 : list ad
H4 : sig (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3)))))
l2 : list ad
H3 : sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad => eq l0 (app l1 (cons x (app l2 (cons x l3))))))
l1 : list ad
H2 : sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3)))))))
x : ad
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nsigT\n (fun x : ad =>\n sigT\n (fun l1 : list ad =>\n sigT\n (fun l2 : list ad =>\n sig\n (fun l3 : list ad =>\n eq l0 (app l1 (cons x (app l2 (cons x l3))))))))
l0 : list ad
a : ad
l : list ad
*****
eq (cons a (app l1 (cons x (app l2 (cons x l3))))) (app (cons a l1) (cons x (app l2 (cons x l3))))
+++++
reflexivity.
-----
Lemma ad_list_stutters_has_circuit : forall l:list ad, ad_list_stutters l = true -> {x : ad & {l0 : list ad & {l1 : list ad & {l2 : list ad | l = l0 ++ x :: l1 ++ x :: l2}}}}.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Fixpoint Elems (l:list ad) : FSet :=\n    match l with\n    | nil => M0 unit\n    | a :: l' => MapPut _ (Elems l') a tt\n    end.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).

*****

*****
forall l : list ad, mapcanon unit (Elems l)
+++++
Proof.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.

*****

*****
forall l : list ad, mapcanon unit (Elems l)
+++++
simple induction l.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.
simple induction l.

*****
l : list ad
*****
mapcanon unit (Elems nil)
+++++
exact (M0_canon unit).
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : mapcanon unit (Elems l)), mapcanon unit (Elems (cons a l))
+++++
intros.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.
simple induction l.
intros.

*****
H : mapcanon unit (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems (cons a l0))
+++++
simpl in |- *.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H : mapcanon unit (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (MapPut unit (Elems l0) a tt)
+++++
apply MapPut_canon.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.
simple induction l.
intros.
simpl in |- *.
apply MapPut_canon.

*****
H : mapcanon unit (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems l0)
+++++
assumption.
-----
Lemma Elems_canon : forall l:list ad, mapcanon _ (Elems l).
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma Elems_app :\n   forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').

*****

*****
forall l l' : list ad, eq (Elems (app l l')) (FSetUnion (Elems l) (Elems l'))
+++++
Proof.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.

*****

*****
forall l l' : list ad, eq (Elems (app l l')) (FSetUnion (Elems l) (Elems l'))
+++++
simple induction l.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.

*****
l : list ad
*****
forall l' : list ad, eq (Elems (app nil l')) (FSetUnion (Elems nil) (Elems l'))
+++++
trivial.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall l' : list ad, eq (Elems (app l l')) (FSetUnion (Elems l) (Elems l'))) (l' : list ad), eq (Elems (app (cons a l) l')) (FSetUnion (Elems (cons a l)) (Elems l'))
+++++
intros.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (Elems (app (cons a l0) l')) (FSetUnion (Elems (cons a l0)) (Elems l'))
+++++
simpl in |- *.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (MapPut unit (Elems (app l0 l')) a tt) (FSetUnion (MapPut unit (Elems l0) a tt) (Elems l'))
+++++
rewrite (MapPut_as_Merge_c unit (Elems l0)).
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (MapPut unit (Elems (app l0 l')) a tt) (FSetUnion (MapMerge unit (Elems l0) (M1 unit a tt)) (Elems l'))
+++++
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (MapMerge unit (Elems (app l0 l')) (M1 unit a tt)) (FSetUnion (MapMerge unit (Elems l0) (M1 unit a tt)) (Elems l'))
+++++
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (Elems (app l0 l')) (M1 unit a tt)) (FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l'))
+++++
rewrite FSetUnion_comm_c.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (M1 unit a tt) (Elems (app l0 l'))) (FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l'))
+++++
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (M1 unit a tt) (Elems (app l0 l'))) (FSetUnion (FSetUnion (M1 unit a tt) (Elems l0)) (Elems l'))
+++++
rewrite FSetUnion_assoc_c.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).
rewrite FSetUnion_assoc_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (M1 unit a tt) (Elems (app l0 l'))) (FSetUnion (M1 unit a tt) (FSetUnion (Elems l0) (Elems l')))
+++++
rewrite (H l').
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).
rewrite FSetUnion_assoc_c.
rewrite (H l').

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (M1 unit a tt) (FSetUnion (Elems l0) (Elems l'))) (FSetUnion (M1 unit a tt) (FSetUnion (Elems l0) (Elems l')))
+++++
reflexivity.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).
rewrite FSetUnion_assoc_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (M1 unit a tt)
+++++
apply M1_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).
rewrite FSetUnion_assoc_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems l0)
+++++
apply Elems_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).
rewrite FSetUnion_assoc_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems l')
+++++
apply Elems_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems l0)
+++++
apply Elems_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.
rewrite (FSetUnion_comm_c (Elems l0) (M1 unit a tt)).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (M1 unit a tt)
+++++
apply M1_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems (app l0 l'))
+++++
apply Elems_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).
change (FSetUnion (Elems (l0 ++ l')) (M1 unit a tt) = FSetUnion (FSetUnion (Elems l0) (M1 unit a tt)) (Elems l')) in |- *.
rewrite FSetUnion_comm_c.

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (M1 unit a tt)
+++++
apply M1_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite (MapPut_as_Merge_c unit (Elems (l0 ++ l'))).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems (app l0 l'))
+++++
apply Elems_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).

*****
l' : list ad
H : forall l' : list ad,\neq (Elems (app l0 l')) (FSetUnion (Elems l0) (Elems l'))
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems l0)
+++++
apply Elems_canon.
-----
Lemma Elems_app : forall l l':list ad, Elems (l ++ l') = FSetUnion (Elems l) (Elems l').
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.

*****

*****
forall l : list ad, eq (Elems (rev l)) (Elems l)
+++++
Proof.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.

*****

*****
forall l : list ad, eq (Elems (rev l)) (Elems l)
+++++
simple induction l.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.

*****
l : list ad
*****
eq (Elems (rev nil)) (Elems nil)
+++++
trivial.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : eq (Elems (rev l)) (Elems l)), eq (Elems (rev (cons a l))) (Elems (cons a l))
+++++
intros.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
eq (Elems (rev (cons a l0))) (Elems (cons a l0))
+++++
simpl in |- *.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
eq (Elems (app (rev l0) (cons a nil))) (MapPut unit (Elems l0) a tt)
+++++
rewrite Elems_app.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite Elems_app.

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (Elems (rev l0)) (Elems (cons a nil))) (MapPut unit (Elems l0) a tt)
+++++
simpl in |- *.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite Elems_app.
simpl in |- *.

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (Elems (rev l0)) (M1 unit a tt)) (MapPut unit (Elems l0) a tt)
+++++
rewrite (MapPut_as_Merge_c unit (Elems l0)).
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite Elems_app.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (Elems (rev l0)) (M1 unit a tt)) (MapMerge unit (Elems l0) (M1 unit a tt))
+++++
rewrite H.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite Elems_app.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).
rewrite H.

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
eq (FSetUnion (Elems l0) (M1 unit a tt)) (MapMerge unit (Elems l0) (M1 unit a tt))
+++++
reflexivity.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite Elems_app.
simpl in |- *.
rewrite (MapPut_as_Merge_c unit (Elems l0)).

*****
H : eq (Elems (rev l0)) (Elems l0)
l0 : list ad
a : ad
l : list ad
*****
mapcanon unit (Elems l0)
+++++
apply Elems_canon.
-----
Lemma Elems_rev : forall l:list ad, Elems (rev l) = Elems l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_in_elems_in_list :\n   forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.

*****

*****
forall (l : list ad) (a : ad), eq (in_FSet a (Elems l)) (ad_in_list a l)
+++++
Proof.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.

*****

*****
forall (l : list ad) (a : ad), eq (in_FSet a (Elems l)) (ad_in_list a l)
+++++
simple induction l.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.

*****
l : list ad
*****
forall a : ad, eq (in_FSet a (Elems nil)) (ad_in_list a nil)
+++++
trivial.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall a0 : ad, eq (in_FSet a0 (Elems l)) (ad_in_list a0 l)) (a0 : ad), eq (in_FSet a0 (Elems (cons a l))) (ad_in_list a0 (cons a l))
+++++
simpl in |- *.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.
simpl in |- *.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall a0 : ad, eq (in_FSet a0 (Elems l)) (ad_in_list a0 l)) (a0 : ad), eq (in_FSet a0 (MapPut unit (Elems l) a tt)) (orb (N.eqb a0 a) (ad_in_list a0 l))
+++++
unfold in_FSet in |- *.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.
simpl in |- *.
unfold in_FSet in |- *.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall a0 : ad, eq (in_dom unit a0 (Elems l)) (ad_in_list a0 l)) (a0 : ad), eq (in_dom unit a0 (MapPut unit (Elems l) a tt)) (orb (N.eqb a0 a) (ad_in_list a0 l))
+++++
intros.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.
simpl in |- *.
unfold in_FSet in |- *.
intros.

*****
a0 : ad
H : forall a : ad, eq (in_dom unit a (Elems l0)) (ad_in_list a l0)
l0 : list ad
a : ad
l : list ad
*****
eq (in_dom unit a0 (MapPut unit (Elems l0) a tt)) (orb (N.eqb a0 a) (ad_in_list a0 l0))
+++++
rewrite (in_dom_put _ (Elems l0) a tt a0).
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.
simpl in |- *.
unfold in_FSet in |- *.
intros.
rewrite (in_dom_put _ (Elems l0) a tt a0).

*****
a0 : ad
H : forall a : ad, eq (in_dom unit a (Elems l0)) (ad_in_list a l0)
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (in_dom unit a0 (Elems l0))) (orb (N.eqb a0 a) (ad_in_list a0 l0))
+++++
rewrite (H a0).
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.
simpl in |- *.
unfold in_FSet in |- *.
intros.
rewrite (in_dom_put _ (Elems l0) a tt a0).
rewrite (H a0).

*****
a0 : ad
H : forall a : ad, eq (in_dom unit a (Elems l0)) (ad_in_list a l0)
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) (orb (N.eqb a0 a) (ad_in_list a0 l0))
+++++
reflexivity.
-----
Lemma ad_in_elems_in_list : forall (l:list ad) (a:ad), in_FSet a (Elems l) = ad_in_list a l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_not_stutters_card :\n   forall l:list ad,\n     ad_list_stutters l = false -> length l = MapCard _ (Elems l).
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).

*****

*****
forall (l : list ad) (_ : eq (ad_list_stutters l) false), eq (length l) (MapCard unit (Elems l))
+++++
Proof.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.

*****

*****
forall (l : list ad) (_ : eq (ad_list_stutters l) false), eq (length l) (MapCard unit (Elems l))
+++++
simple induction l.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.

*****
l : list ad
*****
forall _ : eq (ad_list_stutters nil) false, eq (length nil) (MapCard unit (Elems nil))
+++++
trivial.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall _ : eq (ad_list_stutters l) false, eq (length l) (MapCard unit (Elems l))) (_ : eq (ad_list_stutters (cons a l)) false), eq (length (cons a l)) (MapCard unit (Elems (cons a l)))
+++++
simpl in |- *.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall _ : eq (ad_list_stutters l) false, eq (length l) (MapCard unit (Elems l))) (_ : eq (orb (ad_in_list a l) (ad_list_stutters l)) false), eq (S (length l)) (MapCard unit (MapPut unit (Elems l) a tt))
+++++
intros.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (S (length l0)) (MapCard unit (MapPut unit (Elems l0) a tt))
+++++
rewrite MapCard_Put_2_conv.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (S (length l0)) (S (MapCard unit (Elems l0)))
+++++
rewrite H.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
rewrite H.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (S (MapCard unit (Elems l0))) (S (MapCard unit (Elems l0)))
+++++
reflexivity.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
rewrite H.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (ad_list_stutters l0) false
+++++
elim (orb_false_elim _ _ H0).
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
rewrite H.
elim (orb_false_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
forall (_ : eq (ad_in_list a l0) false) (_ : eq (ad_list_stutters l0) false), eq (ad_list_stutters l0) false
+++++
trivial.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (MapGet unit (Elems l0) a) None
+++++
elim (sumbool_of_bool (in_FSet a (Elems l0))).
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
elim (sumbool_of_bool (in_FSet a (Elems l0))).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (in_FSet a (Elems l0)) true, eq (MapGet unit (Elems l0) a) None
+++++
rewrite ad_in_elems_in_list.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
elim (sumbool_of_bool (in_FSet a (Elems l0))).
rewrite ad_in_elems_in_list.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_in_list a l0) true, eq (MapGet unit (Elems l0) a) None
+++++
intro H1.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
elim (sumbool_of_bool (in_FSet a (Elems l0))).
rewrite ad_in_elems_in_list.
intro H1.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (MapGet unit (Elems l0) a) None
+++++
rewrite H1 in H0.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
elim (sumbool_of_bool (in_FSet a (Elems l0))).
rewrite ad_in_elems_in_list.
intro H1.
rewrite H1 in H0.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb true (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
eq (MapGet unit (Elems l0) a) None
+++++
discriminate H0.
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite MapCard_Put_2_conv.
elim (sumbool_of_bool (in_FSet a (Elems l0))).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) false
H : forall _ : eq (ad_list_stutters l0) false,\neq (length l0) (MapCard unit (Elems l0))
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (in_FSet a (Elems l0)) false, eq (MapGet unit (Elems l0) a) None
+++++
exact (in_dom_none unit (Elems l0) a).
-----
Lemma ad_list_not_stutters_card : forall l:list ad, ad_list_stutters l = false -> length l = MapCard _ (Elems l).
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.

*****

*****
forall l : list ad, le (MapCard unit (Elems l)) (length l)
+++++
Proof.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.

*****

*****
forall l : list ad, le (MapCard unit (Elems l)) (length l)
+++++
simple induction l.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.

*****
l : list ad
*****
le (MapCard unit (Elems nil)) (length nil)
+++++
trivial.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : le (MapCard unit (Elems l)) (length l)), le (MapCard unit (Elems (cons a l))) (length (cons a l))
+++++
intros.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.
intros.

*****
H : le (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (MapCard unit (Elems (cons a l0))) (length (cons a l0))
+++++
simpl in |- *.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H : le (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
apply le_trans with (m := S (MapCard _ (Elems l0))).
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.
intros.
simpl in |- *.
apply le_trans with (m := S (MapCard _ (Elems l0))).

*****
H : le (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (MapCard unit (MapPut unit (Elems l0) a tt)) (S (MapCard unit (Elems l0)))
+++++
apply MapCard_Put_ub.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.
intros.
simpl in |- *.
apply le_trans with (m := S (MapCard _ (Elems l0))).

*****
H : le (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (S (MapCard unit (Elems l0))) (S (length l0))
+++++
apply le_n_S.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.
intros.
simpl in |- *.
apply le_trans with (m := S (MapCard _ (Elems l0))).
apply le_n_S.

*****
H : le (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (MapCard unit (Elems l0)) (length l0)
+++++
assumption.
-----
Lemma ad_list_card : forall l:list ad, MapCard _ (Elems l) <= length l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_card :\n   forall l:list ad,\n     ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.

*****

*****
forall (l : list ad) (_ : eq (ad_list_stutters l) true), lt (MapCard unit (Elems l)) (length l)
+++++
Proof.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.

*****

*****
forall (l : list ad) (_ : eq (ad_list_stutters l) true), lt (MapCard unit (Elems l)) (length l)
+++++
simple induction l.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.

*****
l : list ad
*****
forall _ : eq (ad_list_stutters nil) true, lt (MapCard unit (Elems nil)) (length nil)
+++++
intro.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intro.

*****
H : eq (ad_list_stutters nil) true
l : list ad
*****
lt (MapCard unit (Elems nil)) (length nil)
+++++
discriminate H.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall _ : eq (ad_list_stutters l) true, lt (MapCard unit (Elems l)) (length l)) (_ : eq (ad_list_stutters (cons a l)) true), lt (MapCard unit (Elems (cons a l))) (length (cons a l))
+++++
intros.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_list_stutters (cons a l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (Elems (cons a l0))) (length (cons a l0))
+++++
simpl in |- *.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H0 : eq (ad_list_stutters (cons a l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
simpl in H0.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
elim (orb_true_elim _ _ H0).
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_in_list a l0) true, lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
intro H1.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
rewrite <- (ad_in_elems_in_list l0 a) in H1.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite <- (ad_in_elems_in_list l0 a) in H1.

*****
H1 : eq (in_FSet a (Elems l0)) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
elim (in_dom_some _ _ _ H1).
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite <- (ad_in_elems_in_list l0 a) in H1.
elim (in_dom_some _ _ _ H1).

*****
H1 : eq (in_FSet a (Elems l0)) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
forall (x : unit) (_ : eq (MapGet unit (Elems l0) a) (Some x)), lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
intros y H2.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite <- (ad_in_elems_in_list l0 a) in H1.
elim (in_dom_some _ _ _ H1).
intros y H2.

*****
H2 : eq (MapGet unit (Elems l0) a) (Some y)
y : unit
H1 : eq (in_FSet a (Elems l0)) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
rewrite (MapCard_Put_1_conv _ _ _ _ tt H2).
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite <- (ad_in_elems_in_list l0 a) in H1.
elim (in_dom_some _ _ _ H1).
intros y H2.
rewrite (MapCard_Put_1_conv _ _ _ _ tt H2).

*****
H2 : eq (MapGet unit (Elems l0) a) (Some y)
y : unit
H1 : eq (in_FSet a (Elems l0)) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (Elems l0)) (S (length l0))
+++++
apply le_lt_trans with (m := length l0).
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite <- (ad_in_elems_in_list l0 a) in H1.
elim (in_dom_some _ _ _ H1).
intros y H2.
rewrite (MapCard_Put_1_conv _ _ _ _ tt H2).
apply le_lt_trans with (m := length l0).

*****
H2 : eq (MapGet unit (Elems l0) a) (Some y)
y : unit
H1 : eq (in_FSet a (Elems l0)) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (MapCard unit (Elems l0)) (length l0)
+++++
apply ad_list_card.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite <- (ad_in_elems_in_list l0 a) in H1.
elim (in_dom_some _ _ _ H1).
intros y H2.
rewrite (MapCard_Put_1_conv _ _ _ _ tt H2).
apply le_lt_trans with (m := length l0).

*****
H2 : eq (MapGet unit (Elems l0) a) (Some y)
y : unit
H1 : eq (in_FSet a (Elems l0)) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (length l0) (S (length l0))
+++++
apply lt_n_Sn.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_list_stutters l0) true, lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
intro H1.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (MapPut unit (Elems l0) a tt)) (S (length l0))
+++++
apply le_lt_trans with (m := S (MapCard _ (Elems l0))).
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
apply le_lt_trans with (m := S (MapCard _ (Elems l0))).

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
le (MapCard unit (MapPut unit (Elems l0) a tt)) (S (MapCard unit (Elems l0)))
+++++
apply MapCard_Put_ub.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
apply le_lt_trans with (m := S (MapCard _ (Elems l0))).

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (S (MapCard unit (Elems l0))) (S (length l0))
+++++
apply lt_n_S.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
apply le_lt_trans with (m := S (MapCard _ (Elems l0))).
apply lt_n_S.

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
lt (MapCard unit (Elems l0)) (length l0)
+++++
apply H.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
apply le_lt_trans with (m := S (MapCard _ (Elems l0))).
apply lt_n_S.
apply H.

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
H : forall _ : eq (ad_list_stutters l0) true,\nlt (MapCard unit (Elems l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (ad_list_stutters l0) true
+++++
assumption.
-----
Lemma ad_list_stutters_card : forall l:list ad, ad_list_stutters l = true -> MapCard _ (Elems l) < length l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_not_stutters_card_conv :\n   forall l:list ad,\n     length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.

*****

*****
forall (l : list ad) (_ : eq (length l) (MapCard unit (Elems l))), eq (ad_list_stutters l) false
+++++
Proof.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.

*****

*****
forall (l : list ad) (_ : eq (length l) (MapCard unit (Elems l))), eq (ad_list_stutters l) false
+++++
intros.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.

*****
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
eq (ad_list_stutters l) false
+++++
elim (sumbool_of_bool (ad_list_stutters l)).
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
forall _ : eq (ad_list_stutters l) true, eq (ad_list_stutters l) false
+++++
intro H0.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.

*****
H0 : eq (ad_list_stutters l) true
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
eq (ad_list_stutters l) false
+++++
cut (MapCard _ (Elems l) < length l).
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.
cut (MapCard _ (Elems l) < length l).

*****
H0 : eq (ad_list_stutters l) true
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
forall _ : lt (MapCard unit (Elems l)) (length l), eq (ad_list_stutters l) false
+++++
intro.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.
cut (MapCard _ (Elems l) < length l).
intro.

*****
H1 : lt (MapCard unit (Elems l)) (length l)
H0 : eq (ad_list_stutters l) true
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
eq (ad_list_stutters l) false
+++++
rewrite H in H1.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.
cut (MapCard _ (Elems l) < length l).
intro.
rewrite H in H1.

*****
H1 : lt (MapCard unit (Elems l)) (MapCard unit (Elems l))
H0 : eq (ad_list_stutters l) true
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
eq (ad_list_stutters l) false
+++++
elim (lt_irrefl _ H1).
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.
cut (MapCard _ (Elems l) < length l).

*****
H0 : eq (ad_list_stutters l) true
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
lt (MapCard unit (Elems l)) (length l)
+++++
exact (ad_list_stutters_card _ H0).
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H : eq (length l) (MapCard unit (Elems l))
l : list ad
*****
forall _ : eq (ad_list_stutters l) false, eq (ad_list_stutters l) false
+++++
trivial.
-----
Lemma ad_list_not_stutters_card_conv : forall l:list ad, length l = MapCard _ (Elems l) -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_card_conv :\n   forall l:list ad,\n     MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.

*****

*****
forall (l : list ad) (_ : lt (MapCard unit (Elems l)) (length l)), eq (ad_list_stutters l) true
+++++
Proof.
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.

*****

*****
forall (l : list ad) (_ : lt (MapCard unit (Elems l)) (length l)), eq (ad_list_stutters l) true
+++++
intros.
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.
intros.

*****
H : lt (MapCard unit (Elems l)) (length l)
l : list ad
*****
eq (ad_list_stutters l) true
+++++
elim (sumbool_of_bool (ad_list_stutters l)).
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H : lt (MapCard unit (Elems l)) (length l)
l : list ad
*****
forall _ : eq (ad_list_stutters l) true, eq (ad_list_stutters l) true
+++++
trivial.
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H : lt (MapCard unit (Elems l)) (length l)
l : list ad
*****
forall _ : eq (ad_list_stutters l) false, eq (ad_list_stutters l) true
+++++
intro H0.
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.

*****
H0 : eq (ad_list_stutters l) false
H : lt (MapCard unit (Elems l)) (length l)
l : list ad
*****
eq (ad_list_stutters l) true
+++++
rewrite (ad_list_not_stutters_card _ H0) in H.
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.
rewrite (ad_list_not_stutters_card _ H0) in H.

*****
H0 : eq (ad_list_stutters l) false
H : lt (MapCard unit (Elems l)) (MapCard unit (Elems l))
l : list ad
*****
eq (ad_list_stutters l) true
+++++
elim (lt_irrefl _ H).
-----
Lemma ad_list_stutters_card_conv : forall l:list ad, MapCard _ (Elems l) < length l -> ad_list_stutters l = true.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****

*****

+++++
Qed.
-----
Lemma ad_in_list_l :\n   forall (l l':list ad) (a:ad),\n     ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.

*****

*****
forall (l l' : list ad) (a : ad) (_ : eq (ad_in_list a l) true), eq (ad_in_list a (app l l')) true
+++++
Proof.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.

*****

*****
forall (l l' : list ad) (a : ad) (_ : eq (ad_in_list a l) true), eq (ad_in_list a (app l l')) true
+++++
simple induction l.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a nil) true), eq (ad_in_list a (app nil l')) true
+++++
intros.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.

*****
H : eq (ad_in_list a nil) true
a : ad
l,l' : list ad
*****
eq (ad_in_list a (app nil l')) true
+++++
discriminate H.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (a0 : ad) (_ : eq (ad_in_list a0 l) true), eq (ad_in_list a0 (app l l')) true) (l' : list ad) (a0 : ad) (_ : eq (ad_in_list a0 (cons a l)) true), eq (ad_in_list a0 (app (cons a l) l')) true
+++++
intros.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_in_list a0 (cons a l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (ad_in_list a0 (app (cons a l0) l')) true
+++++
simpl in |- *.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H0 : eq (ad_in_list a0 (cons a l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
simpl in H0.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.

*****
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
elim (orb_true_elim _ _ H0).
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (N.eqb a0 a) true, eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
intro H1.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
rewrite H1.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite H1.

*****
H1 : eq (N.eqb a0 a) true
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb true (ad_in_list a0 (app l0 l'))) true
+++++
reflexivity.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_in_list a0 l0) true, eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
intro H1.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_in_list a0 l0) true
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
rewrite (H l' a0 H1).
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite (H l' a0 H1).

*****
H1 : eq (ad_in_list a0 l0) true
H0 : eq (orb (N.eqb a0 a) (ad_in_list a0 l0)) true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l0) true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) true) true
+++++
apply orb_b_true.
-----
Lemma ad_in_list_l : forall (l l':list ad) (a:ad), ad_in_list a l = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_app_l :\n   forall l l':list ad,\n     ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters l) true), eq (ad_list_stutters (app l l')) true
+++++
Proof.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters l) true), eq (ad_list_stutters (app l l')) true
+++++
simple induction l.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (_ : eq (ad_list_stutters nil) true), eq (ad_list_stutters (app nil l')) true
+++++
intros.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.

*****
H : eq (ad_list_stutters nil) true
l,l' : list ad
*****
eq (ad_list_stutters (app nil l')) true
+++++
discriminate H.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (_ : eq (ad_list_stutters l) true), eq (ad_list_stutters (app l l')) true) (l' : list ad) (_ : eq (ad_list_stutters (cons a l)) true), eq (ad_list_stutters (app (cons a l) l')) true
+++++
intros.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_list_stutters (cons a l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (ad_list_stutters (app (cons a l0) l')) true
+++++
simpl in |- *.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H0 : eq (ad_list_stutters (cons a l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
simpl in H0.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
elim (orb_true_elim _ _ H0).
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_in_list a l0) true, eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
intro H1.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
rewrite (ad_in_list_l l0 l' a H1).
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite (ad_in_list_l l0 l' a H1).

*****
H1 : eq (ad_in_list a l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb true (ad_list_stutters (app l0 l'))) true
+++++
reflexivity.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).

*****
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
forall _ : eq (ad_list_stutters l0) true, eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
intro H1.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
rewrite (H l' H1).
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
simpl in H0.
elim (orb_true_elim _ _ H0).
intro H1.
rewrite (H l' H1).

*****
H1 : eq (ad_list_stutters l0) true
H0 : eq (orb (ad_in_list a l0) (ad_list_stutters l0)) true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l0) true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) true) true
+++++
apply orb_b_true.
-----
Lemma ad_list_stutters_app_l : forall l l':list ad, ad_list_stutters l = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_in_list_r :\n   forall (l l':list ad) (a:ad),\n     ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.

*****

*****
forall (l l' : list ad) (a : ad) (_ : eq (ad_in_list a l') true), eq (ad_in_list a (app l l')) true
+++++
Proof.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.

*****

*****
forall (l l' : list ad) (a : ad) (_ : eq (ad_in_list a l') true), eq (ad_in_list a (app l l')) true
+++++
simple induction l.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l') true), eq (ad_in_list a (app nil l')) true
+++++
trivial.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (a0 : ad) (_ : eq (ad_in_list a0 l') true), eq (ad_in_list a0 (app l l')) true) (l' : list ad) (a0 : ad) (_ : eq (ad_in_list a0 l') true), eq (ad_in_list a0 (app (cons a l) l')) true
+++++
intros.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_in_list a0 l') true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l') true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (ad_in_list a0 (app (cons a l0) l')) true
+++++
simpl in |- *.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H0 : eq (ad_in_list a0 l') true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l') true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) (ad_in_list a0 (app l0 l'))) true
+++++
rewrite (H l' a0 H0).
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (H l' a0 H0).

*****
H0 : eq (ad_in_list a0 l') true
a0 : ad
l' : list ad
H : forall (l' : list ad) (a : ad) (_ : eq (ad_in_list a l') true),\neq (ad_in_list a (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb a0 a) true) true
+++++
apply orb_b_true.
-----
Lemma ad_in_list_r : forall (l l':list ad) (a:ad), ad_in_list a l' = true -> ad_in_list a (l ++ l') = true.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_app_r :\n   forall l l':list ad,\n     ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters l') true), eq (ad_list_stutters (app l l')) true
+++++
Proof.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters l') true), eq (ad_list_stutters (app l l')) true
+++++
simple induction l.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (_ : eq (ad_list_stutters l') true), eq (ad_list_stutters (app nil l')) true
+++++
trivial.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (_ : eq (ad_list_stutters l') true), eq (ad_list_stutters (app l l')) true) (l' : list ad) (_ : eq (ad_list_stutters l') true), eq (ad_list_stutters (app (cons a l) l')) true
+++++
intros.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.

*****
H0 : eq (ad_list_stutters l') true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l') true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (ad_list_stutters (app (cons a l0) l')) true
+++++
simpl in |- *.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H0 : eq (ad_list_stutters l') true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l') true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) (ad_list_stutters (app l0 l'))) true
+++++
rewrite (H l' H0).
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (H l' H0).

*****
H0 : eq (ad_list_stutters l') true
l' : list ad
H : forall (l' : list ad) (_ : eq (ad_list_stutters l') true),\neq (ad_list_stutters (app l0 l')) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list a (app l0 l')) true) true
+++++
apply orb_b_true.
-----
Lemma ad_list_stutters_app_r : forall l l':list ad, ad_list_stutters l' = true -> ad_list_stutters (l ++ l') = true.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_app_conv_l :\n   forall l l':list ad,\n     ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters (app l l')) false), eq (ad_list_stutters l) false
+++++
Proof.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters (app l l')) false), eq (ad_list_stutters l) false
+++++
intros.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.
intros.

*****
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
eq (ad_list_stutters l) false
+++++
elim (sumbool_of_bool (ad_list_stutters l)).
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
forall _ : eq (ad_list_stutters l) true, eq (ad_list_stutters l) false
+++++
intro H0.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.

*****
H0 : eq (ad_list_stutters l) true
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
eq (ad_list_stutters l) false
+++++
rewrite (ad_list_stutters_app_l l l' H0) in H.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H0.
rewrite (ad_list_stutters_app_l l l' H0) in H.

*****
H0 : eq (ad_list_stutters l) true
H : eq true false
l,l' : list ad
*****
eq (ad_list_stutters l) false
+++++
discriminate H.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
forall _ : eq (ad_list_stutters l) false, eq (ad_list_stutters l) false
+++++
trivial.
-----
Lemma ad_list_stutters_app_conv_l : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_app_conv_r :\n   forall l l':list ad,\n     ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters (app l l')) false), eq (ad_list_stutters l') false
+++++
Proof.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.

*****

*****
forall (l l' : list ad) (_ : eq (ad_list_stutters (app l l')) false), eq (ad_list_stutters l') false
+++++
intros.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.
intros.

*****
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
eq (ad_list_stutters l') false
+++++
elim (sumbool_of_bool (ad_list_stutters l')).
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l')).

*****
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
forall _ : eq (ad_list_stutters l') true, eq (ad_list_stutters l') false
+++++
intro H0.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l')).
intro H0.

*****
H0 : eq (ad_list_stutters l') true
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
eq (ad_list_stutters l') false
+++++
rewrite (ad_list_stutters_app_r l l' H0) in H.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l')).
intro H0.
rewrite (ad_list_stutters_app_r l l' H0) in H.

*****
H0 : eq (ad_list_stutters l') true
H : eq true false
l,l' : list ad
*****
eq (ad_list_stutters l') false
+++++
discriminate H.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l')).

*****
H : eq (ad_list_stutters (app l l')) false
l,l' : list ad
*****
forall _ : eq (ad_list_stutters l') false, eq (ad_list_stutters l') false
+++++
trivial.
-----
Lemma ad_list_stutters_app_conv_r : forall l l':list ad, ad_list_stutters (l ++ l') = false -> ad_list_stutters l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l')).

*****

*****

+++++
Qed.
-----
Lemma ad_in_list_app_1 :\n   forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.

*****

*****
forall (l l' : list ad) (x : ad), eq (ad_in_list x (app l (cons x l'))) true
+++++
Proof.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.

*****

*****
forall (l l' : list ad) (x : ad), eq (ad_in_list x (app l (cons x l'))) true
+++++
simple induction l.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (x : ad), eq (ad_in_list x (app nil (cons x l'))) true
+++++
simpl in |- *.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.
simpl in |- *.

*****
l : list ad
*****
forall (l' : list ad) (x : ad), eq (orb (N.eqb x x) (ad_in_list x l')) true
+++++
intros.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.
simpl in |- *.
intros.

*****
x : ad
l,l' : list ad
*****
eq (orb (N.eqb x x) (ad_in_list x l')) true
+++++
rewrite (Neqb_correct x).
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.
simpl in |- *.
intros.
rewrite (Neqb_correct x).

*****
x : ad
l,l' : list ad
*****
eq (orb true (ad_in_list x l')) true
+++++
reflexivity.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (x : ad), eq (ad_in_list x (app l (cons x l'))) true) (l' : list ad) (x : ad), eq (ad_in_list x (app (cons a l) (cons x l'))) true
+++++
intros.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.
intros.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 (cons x l'))) true
l0 : list ad
a : ad
l : list ad
*****
eq (ad_in_list x (app (cons a l0) (cons x l'))) true
+++++
simpl in |- *.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 (cons x l'))) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb x a) (ad_in_list x (app l0 (cons x l')))) true
+++++
rewrite (H l' x).
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (H l' x).

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 (cons x l'))) true
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb x a) true) true
+++++
apply orb_b_true.
-----
Lemma ad_in_list_app_1 : forall (l l':list ad) (x:ad), ad_in_list x (l ++ x :: l') = true.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_in_list_app :\n   forall (l l':list ad) (x:ad),\n     ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').

*****

*****
forall (l l' : list ad) (x : ad), eq (ad_in_list x (app l l')) (orb (ad_in_list x l) (ad_in_list x l'))
+++++
Proof.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.

*****

*****
forall (l l' : list ad) (x : ad), eq (ad_in_list x (app l l')) (orb (ad_in_list x l) (ad_in_list x l'))
+++++
simple induction l.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (x : ad), eq (ad_in_list x (app nil l')) (orb (ad_in_list x nil) (ad_in_list x l'))
+++++
trivial.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (x : ad), eq (ad_in_list x (app l l')) (orb (ad_in_list x l) (ad_in_list x l'))) (l' : list ad) (x : ad), eq (ad_in_list x (app (cons a l) l')) (orb (ad_in_list x (cons a l)) (ad_in_list x l'))
+++++
intros.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.
intros.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 l')) (orb (ad_in_list x l0) (ad_in_list x l'))
l0 : list ad
a : ad
l : list ad
*****
eq (ad_in_list x (app (cons a l0) l')) (orb (ad_in_list x (cons a l0)) (ad_in_list x l'))
+++++
simpl in |- *.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.
intros.
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 l')) (orb (ad_in_list x l0) (ad_in_list x l'))
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb x a) (ad_in_list x (app l0 l'))) (orb (orb (N.eqb x a) (ad_in_list x l0)) (ad_in_list x l'))
+++++
rewrite <- orb_assoc.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite <- orb_assoc.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 l')) (orb (ad_in_list x l0) (ad_in_list x l'))
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb x a) (ad_in_list x (app l0 l'))) (orb (N.eqb x a) (orb (ad_in_list x l0) (ad_in_list x l')))
+++++
rewrite (H l' x).
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite <- orb_assoc.
rewrite (H l' x).

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (ad_in_list x (app l0 l')) (orb (ad_in_list x l0) (ad_in_list x l'))
l0 : list ad
a : ad
l : list ad
*****
eq (orb (N.eqb x a) (orb (ad_in_list x l0) (ad_in_list x l'))) (orb (N.eqb x a) (orb (ad_in_list x l0) (ad_in_list x l')))
+++++
reflexivity.
-----
Lemma ad_in_list_app : forall (l l':list ad) (x:ad), ad_in_list x (l ++ l') = orb (ad_in_list x l) (ad_in_list x l').
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_in_list_rev :\n   forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.

*****

*****
forall (l : list ad) (x : ad), eq (ad_in_list x (rev l)) (ad_in_list x l)
+++++
Proof.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.

*****

*****
forall (l : list ad) (x : ad), eq (ad_in_list x (rev l)) (ad_in_list x l)
+++++
simple induction l.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.

*****
l : list ad
*****
forall x : ad, eq (ad_in_list x (rev nil)) (ad_in_list x nil)
+++++
trivial.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall x : ad, eq (ad_in_list x (rev l)) (ad_in_list x l)) (x : ad), eq (ad_in_list x (rev (cons a l))) (ad_in_list x (cons a l))
+++++
intros.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.
intros.

*****
x : ad
H : forall x : ad, eq (ad_in_list x (rev l0)) (ad_in_list x l0)
l0 : list ad
a : ad
l : list ad
*****
eq (ad_in_list x (rev (cons a l0))) (ad_in_list x (cons a l0))
+++++
simpl in |- *.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
x : ad
H : forall x : ad, eq (ad_in_list x (rev l0)) (ad_in_list x l0)
l0 : list ad
a : ad
l : list ad
*****
eq (ad_in_list x (app (rev l0) (cons a nil))) (orb (N.eqb x a) (ad_in_list x l0))
+++++
rewrite ad_in_list_app.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_in_list_app.

*****
x : ad
H : forall x : ad, eq (ad_in_list x (rev l0)) (ad_in_list x l0)
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list x (rev l0)) (ad_in_list x (cons a nil))) (orb (N.eqb x a) (ad_in_list x l0))
+++++
rewrite (H x).
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_in_list_app.
rewrite (H x).

*****
x : ad
H : forall x : ad, eq (ad_in_list x (rev l0)) (ad_in_list x l0)
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list x l0) (ad_in_list x (cons a nil))) (orb (N.eqb x a) (ad_in_list x l0))
+++++
simpl in |- *.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_in_list_app.
rewrite (H x).
simpl in |- *.

*****
x : ad
H : forall x : ad, eq (ad_in_list x (rev l0)) (ad_in_list x l0)
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list x l0) (orb (N.eqb x a) false)) (orb (N.eqb x a) (ad_in_list x l0))
+++++
rewrite orb_b_false.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_in_list_app.
rewrite (H x).
simpl in |- *.
rewrite orb_b_false.

*****
x : ad
H : forall x : ad, eq (ad_in_list x (rev l0)) (ad_in_list x l0)
l0 : list ad
a : ad
l : list ad
*****
eq (orb (ad_in_list x l0) (N.eqb x a)) (orb (N.eqb x a) (ad_in_list x l0))
+++++
apply orb_comm.
-----
Lemma ad_in_list_rev : forall (l:list ad) (x:ad), ad_in_list x (rev l) = ad_in_list x l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_has_circuit_stutters :\n   forall (l0 l1 l2:list ad) (x:ad),\n     ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.

*****

*****
forall (l0 l1 l2 : list ad) (x : ad), eq (ad_list_stutters (app l0 (cons x (app l1 (cons x l2))))) true
+++++
Proof.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.

*****

*****
forall (l0 l1 l2 : list ad) (x : ad), eq (ad_list_stutters (app l0 (cons x (app l1 (cons x l2))))) true
+++++
simple induction l0.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.

*****
l0 : list ad
*****
forall (l1 l2 : list ad) (x : ad), eq (ad_list_stutters (app nil (cons x (app l1 (cons x l2))))) true
+++++
simpl in |- *.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.
simpl in |- *.

*****
l0 : list ad
*****
forall (l1 l2 : list ad) (x : ad), eq (orb (ad_in_list x (app l1 (cons x l2))) (ad_list_stutters (app l1 (cons x l2)))) true
+++++
intros.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.
simpl in |- *.
intros.

*****
x : ad
l0,l1,l2 : list ad
*****
eq (orb (ad_in_list x (app l1 (cons x l2))) (ad_list_stutters (app l1 (cons x l2)))) true
+++++
rewrite (ad_in_list_app_1 l1 l2 x).
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.
simpl in |- *.
intros.
rewrite (ad_in_list_app_1 l1 l2 x).

*****
x : ad
l0,l1,l2 : list ad
*****
eq (orb true (ad_list_stutters (app l1 (cons x l2)))) true
+++++
reflexivity.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.

*****
l0 : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l1 l2 : list ad) (x : ad), eq (ad_list_stutters (app l (cons x (app l1 (cons x l2))))) true) (l1 l2 : list ad) (x : ad), eq (ad_list_stutters (app (cons a l) (cons x (app l1 (cons x l2))))) true
+++++
intros.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.
intros.

*****
x : ad
l1,l2 : list ad
H : forall (l1 l2 : list ad) (x : ad),\neq (ad_list_stutters (app l (cons x (app l1 (cons x l2))))) true
l : list ad
a : ad
l0 : list ad
*****
eq (ad_list_stutters (app (cons a l) (cons x (app l1 (cons x l2))))) true
+++++
simpl in |- *.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.
intros.
simpl in |- *.

*****
x : ad
l1,l2 : list ad
H : forall (l1 l2 : list ad) (x : ad),\neq (ad_list_stutters (app l (cons x (app l1 (cons x l2))))) true
l : list ad
a : ad
l0 : list ad
*****
eq (orb (ad_in_list a (app l (cons x (app l1 (cons x l2))))) (ad_list_stutters (app l (cons x (app l1 (cons x l2)))))) true
+++++
rewrite (H l1 l2 x).
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.
intros.
simpl in |- *.
rewrite (H l1 l2 x).

*****
x : ad
l1,l2 : list ad
H : forall (l1 l2 : list ad) (x : ad),\neq (ad_list_stutters (app l (cons x (app l1 (cons x l2))))) true
l : list ad
a : ad
l0 : list ad
*****
eq (orb (ad_in_list a (app l (cons x (app l1 (cons x l2))))) true) true
+++++
apply orb_b_true.
-----
Lemma ad_list_has_circuit_stutters : forall (l0 l1 l2:list ad) (x:ad), ad_list_stutters (l0 ++ x :: l1 ++ x :: l2) = true.
Proof.
simple induction l0.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_prev_l :\n   forall (l l':list ad) (x:ad),\n     ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_in_list x l) true), eq (ad_list_stutters (app l (cons x l'))) true
+++++
Proof.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_in_list x l) true), eq (ad_list_stutters (app l (cons x l'))) true
+++++
intros.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.

*****
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x l'))) true
+++++
elim (ad_in_list_forms_circuit _ _ H).
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).

*****
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
forall (x0 : list ad) (_ : sig (fun l2 : list ad => eq l (app x0 (cons x l2)))), eq (ad_list_stutters (app l (cons x l'))) true
+++++
intros l0 H0.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.

*****
H0 : sig (fun l2 : list ad => eq l (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x l'))) true
+++++
elim H0.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.

*****
H0 : sig (fun l2 : list ad => eq l (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
forall (x0 : list ad) (_ : eq l (app l0 (cons x x0))), eq (ad_list_stutters (app l (cons x l'))) true
+++++
intros l1 H1.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.

*****
H1 : eq l (app l0 (cons x l1))
l1 : list ad
H0 : sig (fun l2 : list ad => eq l (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x l'))) true
+++++
rewrite H1.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.
rewrite H1.

*****
H1 : eq l (app l0 (cons x l1))
l1 : list ad
H0 : sig (fun l2 : list ad => eq l (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app (app l0 (cons x l1)) (cons x l'))) true
+++++
rewrite app_ass.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.
rewrite H1.
rewrite app_ass.

*****
H1 : eq l (app l0 (cons x l1))
l1 : list ad
H0 : sig (fun l2 : list ad => eq l (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l0 (app (cons x l1) (cons x l')))) true
+++++
simpl in |- *.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.
rewrite H1.
rewrite app_ass.
simpl in |- *.

*****
H1 : eq l (app l0 (cons x l1))
l1 : list ad
H0 : sig (fun l2 : list ad => eq l (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l) true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l0 (cons x (app l1 (cons x l'))))) true
+++++
apply ad_list_has_circuit_stutters.
-----
Lemma ad_list_stutters_prev_l : forall (l l':list ad) (x:ad), ad_in_list x l = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.
rewrite H1.
rewrite app_ass.
simpl in |- *.
apply ad_list_has_circuit_stutters.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_prev_conv_l :\n   forall (l l':list ad) (x:ad),\n     ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_list_stutters (app l (cons x l'))) false), eq (ad_in_list x l) false
+++++
Proof.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_list_stutters (app l (cons x l'))) false), eq (ad_in_list x l) false
+++++
intros.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.
intros.

*****
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
eq (ad_in_list x l) false
+++++
elim (sumbool_of_bool (ad_in_list x l)).
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l)).

*****
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
forall _ : eq (ad_in_list x l) true, eq (ad_in_list x l) false
+++++
intro H0.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l)).
intro H0.

*****
H0 : eq (ad_in_list x l) true
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
eq (ad_in_list x l) false
+++++
rewrite (ad_list_stutters_prev_l l l' x H0) in H.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l)).
intro H0.
rewrite (ad_list_stutters_prev_l l l' x H0) in H.

*****
H0 : eq (ad_in_list x l) true
H : eq true false
x : ad
l,l' : list ad
*****
eq (ad_in_list x l) false
+++++
discriminate H.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l)).

*****
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
forall _ : eq (ad_in_list x l) false, eq (ad_in_list x l) false
+++++
trivial.
-----
Lemma ad_list_stutters_prev_conv_l : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l)).

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_prev_r :\n   forall (l l':list ad) (x:ad),\n     ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_in_list x l') true), eq (ad_list_stutters (app l (cons x l'))) true
+++++
Proof.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_in_list x l') true), eq (ad_list_stutters (app l (cons x l'))) true
+++++
intros.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.

*****
H : eq (ad_in_list x l') true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x l'))) true
+++++
elim (ad_in_list_forms_circuit _ _ H).
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).

*****
H : eq (ad_in_list x l') true
x : ad
l,l' : list ad
*****
forall (x0 : list ad) (_ : sig (fun l2 : list ad => eq l' (app x0 (cons x l2)))), eq (ad_list_stutters (app l (cons x l'))) true
+++++
intros l0 H0.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.

*****
H0 : sig (fun l2 : list ad => eq l' (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l') true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x l'))) true
+++++
elim H0.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.

*****
H0 : sig (fun l2 : list ad => eq l' (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l') true
x : ad
l,l' : list ad
*****
forall (x0 : list ad) (_ : eq l' (app l0 (cons x x0))), eq (ad_list_stutters (app l (cons x l'))) true
+++++
intros l1 H1.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.

*****
H1 : eq l' (app l0 (cons x l1))
l1 : list ad
H0 : sig (fun l2 : list ad => eq l' (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l') true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x l'))) true
+++++
rewrite H1.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.
rewrite H1.

*****
H1 : eq l' (app l0 (cons x l1))
l1 : list ad
H0 : sig (fun l2 : list ad => eq l' (app l0 (cons x l2)))
l0 : list ad
H : eq (ad_in_list x l') true
x : ad
l,l' : list ad
*****
eq (ad_list_stutters (app l (cons x (app l0 (cons x l1))))) true
+++++
apply ad_list_has_circuit_stutters.
-----
Lemma ad_list_stutters_prev_r : forall (l l':list ad) (x:ad), ad_in_list x l' = true -> ad_list_stutters (l ++ x :: l') = true.
Proof.
intros.
elim (ad_in_list_forms_circuit _ _ H).
intros l0 H0.
elim H0.
intros l1 H1.
rewrite H1.
apply ad_list_has_circuit_stutters.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_prev_conv_r :\n   forall (l l':list ad) (x:ad),\n     ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_list_stutters (app l (cons x l'))) false), eq (ad_in_list x l') false
+++++
Proof.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.

*****

*****
forall (l l' : list ad) (x : ad) (_ : eq (ad_list_stutters (app l (cons x l'))) false), eq (ad_in_list x l') false
+++++
intros.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.
intros.

*****
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
eq (ad_in_list x l') false
+++++
elim (sumbool_of_bool (ad_in_list x l')).
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l')).

*****
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
forall _ : eq (ad_in_list x l') true, eq (ad_in_list x l') false
+++++
intro H0.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l')).
intro H0.

*****
H0 : eq (ad_in_list x l') true
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
eq (ad_in_list x l') false
+++++
rewrite (ad_list_stutters_prev_r l l' x H0) in H.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l')).
intro H0.
rewrite (ad_list_stutters_prev_r l l' x H0) in H.

*****
H0 : eq (ad_in_list x l') true
H : eq true false
x : ad
l,l' : list ad
*****
eq (ad_in_list x l') false
+++++
discriminate H.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l')).

*****
H : eq (ad_list_stutters (app l (cons x l'))) false
x : ad
l,l' : list ad
*****
forall _ : eq (ad_in_list x l') false, eq (ad_in_list x l') false
+++++
trivial.
-----
Lemma ad_list_stutters_prev_conv_r : forall (l l':list ad) (x:ad), ad_list_stutters (l ++ x :: l') = false -> ad_in_list x l' = false.
Proof.
intros.
elim (sumbool_of_bool (ad_in_list x l')).

*****

*****

+++++
Qed.
-----
Lemma ad_list_Elems :\n   forall l l':list ad,\n     MapCard _ (Elems l) = MapCard _ (Elems l') ->\n     length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.

*****

*****
forall (l l' : list ad) (_ : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))) (_ : eq (length l) (length l')), eq (ad_list_stutters l) (ad_list_stutters l')
+++++
Proof.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.

*****

*****
forall (l l' : list ad) (_ : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))) (_ : eq (length l) (length l')), eq (ad_list_stutters l) (ad_list_stutters l')
+++++
intros.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.

*****
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l) (ad_list_stutters l')
+++++
elim (sumbool_of_bool (ad_list_stutters l)).
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
forall _ : eq (ad_list_stutters l) true, eq (ad_list_stutters l) (ad_list_stutters l')
+++++
intro H1.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l) (ad_list_stutters l')
+++++
rewrite H1.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq true (ad_list_stutters l')
+++++
apply sym_eq.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l') true
+++++
apply ad_list_stutters_card_conv.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_stutters_card_conv.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
lt (MapCard unit (Elems l')) (length l')
+++++
rewrite <- H.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_stutters_card_conv.
rewrite <- H.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
lt (MapCard unit (Elems l)) (length l')
+++++
rewrite <- H0.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_stutters_card_conv.
rewrite <- H.
rewrite <- H0.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
lt (MapCard unit (Elems l)) (length l)
+++++
apply ad_list_stutters_card.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_stutters_card_conv.
rewrite <- H.
rewrite <- H0.
apply ad_list_stutters_card.

*****
H1 : eq (ad_list_stutters l) true
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l) true
+++++
assumption.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
forall _ : eq (ad_list_stutters l) false, eq (ad_list_stutters l) (ad_list_stutters l')
+++++
intro H1.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l) (ad_list_stutters l')
+++++
rewrite H1.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq false (ad_list_stutters l')
+++++
apply sym_eq.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l') false
+++++
apply ad_list_not_stutters_card_conv.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_not_stutters_card_conv.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (length l') (MapCard unit (Elems l'))
+++++
rewrite <- H.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_not_stutters_card_conv.
rewrite <- H.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (length l') (MapCard unit (Elems l))
+++++
rewrite <- H0.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_not_stutters_card_conv.
rewrite <- H.
rewrite <- H0.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (length l) (MapCard unit (Elems l))
+++++
apply ad_list_not_stutters_card.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).
intro H1.
rewrite H1.
apply sym_eq.
apply ad_list_not_stutters_card_conv.
rewrite <- H.
rewrite <- H0.
apply ad_list_not_stutters_card.

*****
H1 : eq (ad_list_stutters l) false
H0 : eq (length l) (length l')
H : eq (MapCard unit (Elems l)) (MapCard unit (Elems l'))
l,l' : list ad
*****
eq (ad_list_stutters l) false
+++++
assumption.
-----
Lemma ad_list_Elems : forall l l':list ad, MapCard _ (Elems l) = MapCard _ (Elems l') -> length l = length l' -> ad_list_stutters l = ad_list_stutters l'.
Proof.
intros.
elim (sumbool_of_bool (ad_list_stutters l)).

*****

*****

+++++
Qed.
-----
Lemma ad_list_app_length :\n   forall l l':list ad, length (l ++ l') = length l + length l'.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.

*****

*****
forall l l' : list ad, eq (length (app l l')) (Init.Nat.add (length l) (length l'))
+++++
Proof.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.

*****

*****
forall l l' : list ad, eq (length (app l l')) (Init.Nat.add (length l) (length l'))
+++++
simple induction l.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.
simple induction l.

*****
l : list ad
*****
forall l' : list ad, eq (length (app nil l')) (Init.Nat.add (length nil) (length l'))
+++++
trivial.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall l' : list ad, eq (length (app l l')) (Init.Nat.add (length l) (length l'))) (l' : list ad), eq (length (app (cons a l) l')) (Init.Nat.add (length (cons a l)) (length l'))
+++++
intros.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.
simple induction l.
intros.

*****
l' : list ad
H : forall l' : list ad,\neq (length (app l0 l')) (Init.Nat.add (length l0) (length l'))
l0 : list ad
a : ad
l : list ad
*****
eq (length (app (cons a l0) l')) (Init.Nat.add (length (cons a l0)) (length l'))
+++++
simpl in |- *.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
l' : list ad
H : forall l' : list ad,\neq (length (app l0 l')) (Init.Nat.add (length l0) (length l'))
l0 : list ad
a : ad
l : list ad
*****
eq (S (length (app l0 l'))) (S (Init.Nat.add (length l0) (length l')))
+++++
rewrite (H l').
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (H l').

*****
l' : list ad
H : forall l' : list ad,\neq (length (app l0 l')) (Init.Nat.add (length l0) (length l'))
l0 : list ad
a : ad
l : list ad
*****
eq (S (Init.Nat.add (length l0) (length l'))) (S (Init.Nat.add (length l0) (length l')))
+++++
reflexivity.
-----
Lemma ad_list_app_length : forall l l':list ad, length (l ++ l') = length l + length l'.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_permute :\n   forall l l':list ad,\n     ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).

*****

*****
forall l l' : list ad, eq (ad_list_stutters (app l l')) (ad_list_stutters (app l' l))
+++++
Proof.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.

*****

*****
forall l l' : list ad, eq (ad_list_stutters (app l l')) (ad_list_stutters (app l' l))
+++++
intros.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.

*****
l,l' : list ad
*****
eq (ad_list_stutters (app l l')) (ad_list_stutters (app l' l))
+++++
apply ad_list_Elems.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.

*****
l,l' : list ad
*****
eq (MapCard unit (Elems (app l l'))) (MapCard unit (Elems (app l' l)))
+++++
rewrite Elems_app.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.
rewrite Elems_app.

*****
l,l' : list ad
*****
eq (MapCard unit (FSetUnion (Elems l) (Elems l'))) (MapCard unit (Elems (app l' l)))
+++++
rewrite Elems_app.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.
rewrite Elems_app.
rewrite Elems_app.

*****
l,l' : list ad
*****
eq (MapCard unit (FSetUnion (Elems l) (Elems l'))) (MapCard unit (FSetUnion (Elems l') (Elems l)))
+++++
rewrite (FSetUnion_comm_c _ _ (Elems_canon l) (Elems_canon l')).
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.
rewrite Elems_app.
rewrite Elems_app.
rewrite (FSetUnion_comm_c _ _ (Elems_canon l) (Elems_canon l')).

*****
l,l' : list ad
*****
eq (MapCard unit (FSetUnion (Elems l') (Elems l))) (MapCard unit (FSetUnion (Elems l') (Elems l)))
+++++
reflexivity.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.

*****
l,l' : list ad
*****
eq (length (app l l')) (length (app l' l))
+++++
rewrite ad_list_app_length.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.
rewrite ad_list_app_length.

*****
l,l' : list ad
*****
eq (Init.Nat.add (length l) (length l')) (length (app l' l))
+++++
rewrite ad_list_app_length.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.
rewrite ad_list_app_length.
rewrite ad_list_app_length.

*****
l,l' : list ad
*****
eq (Init.Nat.add (length l) (length l')) (Init.Nat.add (length l') (length l))
+++++
apply plus_comm.
-----
Lemma ad_list_stutters_permute : forall l l':list ad, ad_list_stutters (l ++ l') = ad_list_stutters (l' ++ l).
Proof.
intros.
apply ad_list_Elems.

*****

*****

+++++
Qed.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.

*****

*****
forall l : list ad, eq (length (rev l)) (length l)
+++++
Proof.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.

*****

*****
forall l : list ad, eq (length (rev l)) (length l)
+++++
simple induction l.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.

*****
l : list ad
*****
eq (length (rev nil)) (length nil)
+++++
trivial.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : eq (length (rev l)) (length l)), eq (length (rev (cons a l))) (length (cons a l))
+++++
intros.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (length (rev (cons a l0))) (length (cons a l0))
+++++
simpl in |- *.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (length (app (rev l0) (cons a nil))) (S (length l0))
+++++
rewrite ad_list_app_length.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_list_app_length.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (Init.Nat.add (length (rev l0)) (length (cons a nil))) (S (length l0))
+++++
simpl in |- *.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_list_app_length.
simpl in |- *.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (Init.Nat.add (length (rev l0)) (S O)) (S (length l0))
+++++
rewrite H.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_list_app_length.
simpl in |- *.
rewrite H.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (Init.Nat.add (length l0) (S O)) (S (length l0))
+++++
rewrite <- plus_Snm_nSm.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_list_app_length.
simpl in |- *.
rewrite H.
rewrite <- plus_Snm_nSm.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (Init.Nat.add (S (length l0)) O) (S (length l0))
+++++
rewrite <- plus_n_O.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite ad_list_app_length.
simpl in |- *.
rewrite H.
rewrite <- plus_Snm_nSm.
rewrite <- plus_n_O.

*****
H : eq (length (rev l0)) (length l0)
l0 : list ad
a : ad
l : list ad
*****
eq (S (length l0)) (S (length l0))
+++++
reflexivity.
-----
Lemma ad_list_rev_length : forall l:list ad, length (rev l) = length l.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Lemma ad_list_stutters_rev :\n   forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.

*****

*****
forall l : list ad, eq (ad_list_stutters (rev l)) (ad_list_stutters l)
+++++
Proof.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
Proof.

*****

*****
forall l : list ad, eq (ad_list_stutters (rev l)) (ad_list_stutters l)
+++++
intros.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
Proof.
intros.

*****
l : list ad
*****
eq (ad_list_stutters (rev l)) (ad_list_stutters l)
+++++
apply ad_list_Elems.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
Proof.
intros.
apply ad_list_Elems.

*****
l : list ad
*****
eq (MapCard unit (Elems (rev l))) (MapCard unit (Elems l))
+++++
rewrite Elems_rev.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
Proof.
intros.
apply ad_list_Elems.
rewrite Elems_rev.

*****
l : list ad
*****
eq (MapCard unit (Elems l)) (MapCard unit (Elems l))
+++++
reflexivity.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
Proof.
intros.
apply ad_list_Elems.

*****
l : list ad
*****
eq (length (rev l)) (length l)
+++++
apply ad_list_rev_length.
-----
Lemma ad_list_stutters_rev : forall l:list ad, ad_list_stutters (rev l) = ad_list_stutters l.
Proof.
intros.
apply ad_list_Elems.

*****

*****

+++++
Qed.
-----
Lemma ad_list_app_rev :\n   forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.

*****

*****
forall (l l' : list ad) (x : ad), eq (app (rev l) (cons x l')) (app (rev (cons x l)) l')
+++++
Proof.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.

*****

*****
forall (l l' : list ad) (x : ad), eq (app (rev l) (cons x l')) (app (rev (cons x l)) l')
+++++
simple induction l.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.

*****
l : list ad
*****
forall (l' : list ad) (x : ad), eq (app (rev nil) (cons x l')) (app (rev (cons x nil)) l')
+++++
trivial.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.

*****
l : list ad
*****
forall (a : ad) (l : list ad) (_ : forall (l' : list ad) (x : ad), eq (app (rev l) (cons x l')) (app (rev (cons x l)) l')) (l' : list ad) (x : ad), eq (app (rev (cons a l)) (cons x l')) (app (rev (cons x (cons a l))) l')
+++++
intros.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev (cons a l0)) (cons x l')) (app (rev (cons x (cons a l0))) l')
+++++
simpl in |- *.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (app (rev l0) (cons a nil)) (cons x l')) (app (app (app (rev l0) (cons a nil)) (cons x nil)) l')
+++++
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev l0) (app (cons a nil) (cons x l'))) (app (app (app (rev l0) (cons a nil)) (cons x nil)) l')
+++++
simpl in |- *.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev l0) (cons a (cons x l'))) (app (app (app (rev l0) (cons a nil)) (cons x nil)) l')
+++++
rewrite (H (x :: l') a).
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev (cons a l0)) (cons x l')) (app (app (app (rev l0) (cons a nil)) (cons x nil)) l')
+++++
simpl in |- *.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (app (rev l0) (cons a nil)) (cons x l')) (app (app (app (rev l0) (cons a nil)) (cons x nil)) l')
+++++
rewrite (app_ass (rev l0) (a :: nil) (x :: nil)).
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: nil)).

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (app (rev l0) (cons a nil)) (cons x l')) (app (app (rev l0) (app (cons a nil) (cons x nil))) l')
+++++
simpl in |- *.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: nil)).
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (app (rev l0) (cons a nil)) (cons x l')) (app (app (rev l0) (cons a (cons x nil))) l')
+++++
rewrite app_ass.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: nil)).
simpl in |- *.
rewrite app_ass.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev l0) (app (cons a nil) (cons x l'))) (app (app (rev l0) (cons a (cons x nil))) l')
+++++
simpl in |- *.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: nil)).
simpl in |- *.
rewrite app_ass.
simpl in |- *.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev l0) (cons a (cons x l'))) (app (app (rev l0) (cons a (cons x nil))) l')
+++++
rewrite app_ass.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.
intros.
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: l')).
simpl in |- *.
rewrite (H (x :: l') a).
simpl in |- *.
rewrite (app_ass (rev l0) (a :: nil) (x :: nil)).
simpl in |- *.
rewrite app_ass.
simpl in |- *.
rewrite app_ass.

*****
x : ad
l' : list ad
H : forall (l' : list ad) (x : ad),\neq (app (rev l0) (cons x l')) (app (rev (cons x l0)) l')
l0 : list ad
a : ad
l : list ad
*****
eq (app (rev l0) (cons a (cons x l'))) (app (rev l0) (app (cons a (cons x nil)) l'))
+++++
reflexivity.
-----
Lemma ad_list_app_rev : forall (l l':list ad) (x:ad), rev l ++ x :: l' = rev (x :: l) ++ l'.
Proof.
simple induction l.

*****

*****

+++++
Qed.
-----
Section ListOfDomDef.
-----
Variable A : Type.
-----
Definition ad_list_of_dom :=\n    MapFold A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil).
-----
Lemma ad_in_list_of_dom_in_dom :\n   forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.

*****
A : Type
*****
forall (m : Map A) (a : ad), eq (ad_in_list a (ad_list_of_dom m)) (in_dom A a m)
+++++
Proof.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.

*****
A : Type
*****
forall (m : Map A) (a : ad), eq (ad_in_list a (ad_list_of_dom m)) (in_dom A a m)
+++++
unfold ad_list_of_dom in |- *.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.

*****
A : Type
*****
forall (m : Map A) (a : ad), eq (ad_in_list a (MapFold A (list ad) nil (app (A:=ad)) (fun (a0 : ad) (_ : A) => cons a0 nil) m)) (in_dom A a m)
+++++
intros.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.

*****
a : ad
m : Map A
A : Type
*****
eq (ad_in_list a (MapFold A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) m)) (in_dom A a m)
+++++
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).

*****
a : ad
m : Map A
A : Type
*****
eq (MapFold A bool false orb (fun (a0 : ad) (_ : A) => ad_in_list a (cons a0 nil)) m) (in_dom A a m)
+++++
simpl in |- *.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.

*****
a : ad
m : Map A
A : Type
*****
eq (MapFold A bool false orb (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m) (in_dom A a m)
+++++
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).

*****
a : ad
m : Map A
A : Type
*****
eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).

*****
a : ad
m : Map A
A : Type
*****
forall _ : sig (fun y : prod ad A => eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m) (Some y)), eq match MapSweep A (fun (a1 : ad) (_ : A) => orb (N.eqb a a1) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
intro H.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.

*****
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
elim H.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.

*****
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
forall (x : prod ad A) (_ : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m) (Some x)), eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
intro r.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.

*****
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m) (Some r), eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
elim r.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.

*****
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
forall (a0 : ad) (b : A) (_ : eq (MapSweep A (fun (a1 : ad) (_ : A) => orb (N.eqb a a1) false) m) (Some (pair a0 b))), eq match MapSweep A (fun (a1 : ad) (_ : A) => orb (N.eqb a a1) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
intros a0 y H0.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.

*****
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
rewrite H0.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.

*****
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq true (in_dom A a m)
+++++
unfold in_dom in |- *.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.

*****
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq true match MapGet A m a with | Some _ => true | None => false end
+++++
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).

*****
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
forall _ : eq (N.eqb a a0) true, eq true match MapGet A m a with | Some _ => true | None => false end
+++++
intro H1.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).
intro H1.

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq true match MapGet A m a with | Some _ => true | None => false end
+++++
rewrite (Neqb_complete _ _ H1).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).
intro H1.
rewrite (Neqb_complete _ _ H1).

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq true match MapGet A m a0 with | Some _ => true | None => false end
+++++
rewrite (MapSweep_semantics_2 A _ _ _ _ H0).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).
intro H1.
rewrite (Neqb_complete _ _ H1).
rewrite (MapSweep_semantics_2 A _ _ _ _ H0).

*****
H1 : eq (N.eqb a a0) true
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).

*****
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
forall _ : eq false true, eq true match MapGet A m a with | Some _ => true | None => false end
+++++
intro H1.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
elim H.
intro r.
elim r.
intros a0 y H0.
rewrite H0.
unfold in_dom in |- *.
elim (orb_prop _ _ (MapSweep_semantics_1 _ _ _ _ _ H0)).
intro H1.

*****
H1 : eq false true
H0 : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some (pair a0 y))
y : A
a0 : ad
r : prod ad A
H : sig\n (fun y : prod ad A =>\n eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n (Some y))
a : ad
m : Map A
A : Type
*****
eq true match MapGet A m a with | Some _ => true | None => false end
+++++
discriminate H1.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).

*****
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m) None, eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
intro H.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.

*****
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
eq match MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m with | Some _ => true | None => false end (in_dom A a m)
+++++
rewrite H.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.

*****
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
eq false (in_dom A a m)
+++++
elim (sumbool_of_bool (in_dom A a m)).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).

*****
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_dom A a m) true, eq false (in_dom A a m)
+++++
intro H0.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.

*****
H0 : eq (in_dom A a m) true
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
eq false (in_dom A a m)
+++++
elim (in_dom_some A m a H0).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
elim (in_dom_some A m a H0).

*****
H0 : eq (in_dom A a m) true
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
forall (x : A) (_ : eq (MapGet A m a) (Some x)), eq false (in_dom A a m)
+++++
intros y H1.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
elim (in_dom_some A m a H0).
intros y H1.

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom A a m) true
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
eq false (in_dom A a m)
+++++
elim (orb_false_elim _ _ (MapSweep_semantics_3 _ _ _ H _ _ H1)).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
elim (in_dom_some A m a H0).
intros y H1.
elim (orb_false_elim _ _ (MapSweep_semantics_3 _ _ _ H _ _ H1)).

*****
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom A a m) true
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
forall (_ : eq (N.eqb a a) false) (_ : eq false false), eq false (in_dom A a m)
+++++
intro H2.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
elim (in_dom_some A m a H0).
intros y H1.
elim (orb_false_elim _ _ (MapSweep_semantics_3 _ _ _ H _ _ H1)).
intro H2.

*****
H2 : eq (N.eqb a a) false
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom A a m) true
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
forall _ : eq false false, eq false (in_dom A a m)
+++++
rewrite (Neqb_correct a) in H2.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).
intro H0.
elim (in_dom_some A m a H0).
intros y H1.
elim (orb_false_elim _ _ (MapSweep_semantics_3 _ _ _ H _ _ H1)).
intro H2.
rewrite (Neqb_correct a) in H2.

*****
H2 : eq true false
H1 : eq (MapGet A m a) (Some y)
y : A
H0 : eq (in_dom A a m) true
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
forall _ : eq false false, eq false (in_dom A a m)
+++++
discriminate H2.
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).
intro H.
rewrite H.
elim (sumbool_of_bool (in_dom A a m)).

*****
H : eq (MapSweep A (fun (a0 : ad) (_ : A) => orb (N.eqb a a0) false) m)\n None
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_dom A a m) false, eq false (in_dom A a m)
+++++
exact (sym_eq (y:=_)).
-----
Lemma ad_in_list_of_dom_in_dom : forall (m:Map A) (a:ad), ad_in_list a (ad_list_of_dom m) = in_dom A a m.
Proof.
unfold ad_list_of_dom in |- *.
intros.
rewrite (MapFold_distr_l A (list ad) nil (app (A:=ad)) bool false orb ad (fun (a:ad) (l:list ad) => ad_in_list a l) ( fun c:ad => refl_equal _) ad_in_list_app (fun (a0:ad) (_:A) => a0 :: nil) m a).
simpl in |- *.
rewrite (MapFold_orb A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m).
elim (option_sum _ (MapSweep A (fun (a0:ad) (_:A) => orb (Neqb a a0) false) m)).

*****

*****

+++++
Qed.
-----
Lemma Elems_of_list_of_dom :\n   forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).

*****
A : Type
*****
forall m : Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m)
+++++
Proof.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.

*****
A : Type
*****
forall m : Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m)
+++++
unfold eqmap in |- *.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.

*****
A : Type
*****
forall m : Map A, eqm unit (MapGet unit (Elems (ad_list_of_dom m))) (MapGet unit (MapDom A m))
+++++
unfold eqm in |- *.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.

*****
A : Type
*****
forall (m : Map A) (a : ad), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intros.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.

*****
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).

*****
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_FSet a (Elems (ad_list_of_dom m))) true, eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intro H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.

*****
H : eq (in_FSet a (Elems (ad_list_of_dom m))) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
elim (in_dom_some _ _ _ H).
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).

*****
H : eq (in_FSet a (Elems (ad_list_of_dom m))) true
a : ad
m : Map A
A : Type
*****
forall (x : unit) (_ : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some x)), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intro t.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.

*****
t : unit
H : eq (in_FSet a (Elems (ad_list_of_dom m))) true
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some t), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
elim t.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.

*****
t : unit
H : eq (in_FSet a (Elems (ad_list_of_dom m))) true
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intro H0.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.

*****
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (Elems (ad_list_of_dom m))) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.

*****
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (ad_in_list a (ad_list_of_dom m)) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
rewrite (ad_in_list_of_dom_in_dom m a) in H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.

*****
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_dom A a m) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
rewrite (MapDom_Dom A m a) in H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.

*****
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (MapDom A m)) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
elim (in_dom_some _ _ _ H).
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.
elim (in_dom_some _ _ _ H).

*****
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (MapDom A m)) true
a : ad
m : Map A
A : Type
*****
forall (x : unit) (_ : eq (MapGet unit (MapDom A m) a) (Some x)), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intro t'.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.
elim (in_dom_some _ _ _ H).
intro t'.

*****
t' : unit
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (MapDom A m)) true
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet unit (MapDom A m) a) (Some t'), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
elim t'.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.
elim (in_dom_some _ _ _ H).
intro t'.
elim t'.

*****
t' : unit
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (MapDom A m)) true
a : ad
m : Map A
A : Type
*****
forall _ : eq (MapGet unit (MapDom A m) a) (Some tt), eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intro H1.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.
elim (in_dom_some _ _ _ H).
intro t'.
elim t'.
intro H1.

*****
H1 : eq (MapGet unit (MapDom A m) a) (Some tt)
t' : unit
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (MapDom A m)) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
rewrite H1.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
elim (in_dom_some _ _ _ H).
intro t.
elim t.
intro H0.
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.
elim (in_dom_some _ _ _ H).
intro t'.
elim t'.
intro H1.
rewrite H1.

*****
H1 : eq (MapGet unit (MapDom A m) a) (Some tt)
t' : unit
H0 : eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
t : unit
H : eq (in_FSet a (MapDom A m)) true
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (Some tt)
+++++
assumption.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).

*****
a : ad
m : Map A
A : Type
*****
forall _ : eq (in_FSet a (Elems (ad_list_of_dom m))) false, eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
intro H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.

*****
H : eq (in_FSet a (Elems (ad_list_of_dom m))) false
a : ad
m : Map A
A : Type
*****
eq (MapGet unit (Elems (ad_list_of_dom m)) a) (MapGet unit (MapDom A m) a)
+++++
rewrite (in_dom_none _ _ _ H).
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
rewrite (in_dom_none _ _ _ H).

*****
H : eq (in_FSet a (Elems (ad_list_of_dom m))) false
a : ad
m : Map A
A : Type
*****
eq None (MapGet unit (MapDom A m) a)
+++++
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
rewrite (in_dom_none _ _ _ H).
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.

*****
H : eq (ad_in_list a (ad_list_of_dom m)) false
a : ad
m : Map A
A : Type
*****
eq None (MapGet unit (MapDom A m) a)
+++++
rewrite (ad_in_list_of_dom_in_dom m a) in H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
rewrite (in_dom_none _ _ _ H).
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.

*****
H : eq (in_dom A a m) false
a : ad
m : Map A
A : Type
*****
eq None (MapGet unit (MapDom A m) a)
+++++
rewrite (MapDom_Dom A m a) in H.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
rewrite (in_dom_none _ _ _ H).
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.

*****
H : eq (in_FSet a (MapDom A m)) false
a : ad
m : Map A
A : Type
*****
eq None (MapGet unit (MapDom A m) a)
+++++
rewrite (in_dom_none _ _ _ H).
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).
intro H.
rewrite (in_dom_none _ _ _ H).
rewrite (ad_in_elems_in_list (ad_list_of_dom m) a) in H.
rewrite (ad_in_list_of_dom_in_dom m a) in H.
rewrite (MapDom_Dom A m a) in H.
rewrite (in_dom_none _ _ _ H).

*****
H : eq (in_FSet a (MapDom A m)) false
a : ad
m : Map A
A : Type
*****
eq None None
+++++
reflexivity.
-----
Lemma Elems_of_list_of_dom : forall m:Map A, eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m).
Proof.
unfold eqmap in |- *.
unfold eqm in |- *.
intros.
elim (sumbool_of_bool (in_FSet a (Elems (ad_list_of_dom m)))).

*****

*****

+++++
Qed.
-----
Lemma Elems_of_list_of_dom_c :\n   forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon A m), eq (Elems (ad_list_of_dom m)) (MapDom A m)
+++++
Proof.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.

*****
A : Type
*****
forall (m : Map A) (_ : mapcanon A m), eq (Elems (ad_list_of_dom m)) (MapDom A m)
+++++
intros.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.
intros.

*****
H : mapcanon A m
m : Map A
A : Type
*****
eq (Elems (ad_list_of_dom m)) (MapDom A m)
+++++
apply (mapcanon_unique unit).
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.
intros.
apply (mapcanon_unique unit).

*****
H : mapcanon A m
m : Map A
A : Type
*****
mapcanon unit (Elems (ad_list_of_dom m))
+++++
apply Elems_canon.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.
intros.
apply (mapcanon_unique unit).

*****
H : mapcanon A m
m : Map A
A : Type
*****
mapcanon unit (MapDom A m)
+++++
apply MapDom_canon.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.
intros.
apply (mapcanon_unique unit).
apply MapDom_canon.

*****
H : mapcanon A m
m : Map A
A : Type
*****
mapcanon A m
+++++
assumption.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.
intros.
apply (mapcanon_unique unit).

*****
H : mapcanon A m
m : Map A
A : Type
*****
eqmap unit (Elems (ad_list_of_dom m)) (MapDom A m)
+++++
apply Elems_of_list_of_dom.
-----
Lemma Elems_of_list_of_dom_c : forall m:Map A, mapcanon A m -> Elems (ad_list_of_dom m) = MapDom A m.
Proof.
intros.
apply (mapcanon_unique unit).

*****

*****

+++++
Qed.
-----
Lemma ad_list_of_dom_card_1 :\n   forall (m:Map A) (pf:ad -> ad),\n     length\n       (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil)\n          pf m) = MapCard A m.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.

*****
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad), eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m)) (MapCard A m)
+++++
Proof.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.

*****
A : Type
*****
forall (m : Map A) (pf : forall _ : ad, ad), eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m)) (MapCard A m)
+++++
simple induction m.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf (M0 A))) (MapCard A (M0 A))
+++++
try trivial.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad), eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a1 : ad) (_ : A) => cons a1 nil) pf (M1 A a a0))) (MapCard A (M1 A a a0))
+++++
try trivial.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m)) (MapCard A m)) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m0)) (MapCard A m0)) (pf : forall _ : ad, ad), eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf (M2 A m m0))) (MapCard A (M2 A m m0))
+++++
try trivial.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.
try trivial.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m)) (MapCard A m)) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m0)) (MapCard A m0)) (pf : forall _ : ad, ad), eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf (M2 A m m0))) (MapCard A (M2 A m m0))
+++++
simpl in |- *.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.
try trivial.
simpl in |- *.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m)) (MapCard A m)) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m0)) (MapCard A m0)) (pf : forall _ : ad, ad), eq (length (app (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m0))) (Init.Nat.add (MapCard A m) (MapCard A m0))
+++++
intros.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)) \n (MapCard A m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)) \n (MapCard A m0)
m,m0 : Map A
A : Type
*****
eq (length (app (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m1))) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
rewrite ad_list_app_length.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.
rewrite ad_list_app_length.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)) \n (MapCard A m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)) \n (MapCard A m0)
m,m0 : Map A
A : Type
*****
eq (Init.Nat.add (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.double a0)) m0)) (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m1))) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
rewrite (H (fun a0:ad => pf (Ndouble a0))).
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.
rewrite ad_list_app_length.
rewrite (H (fun a0:ad => pf (Ndouble a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)) \n (MapCard A m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)) \n (MapCard A m0)
m,m0 : Map A
A : Type
*****
eq (Init.Nat.add (MapCard A m0) (length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m1))) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.
rewrite ad_list_app_length.
rewrite (H (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)) \n (MapCard A m1)
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (length\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)) \n (MapCard A m0)
m,m0 : Map A
A : Type
*****
eq (Init.Nat.add (MapCard A m0) (MapCard A m1)) (Init.Nat.add (MapCard A m0) (MapCard A m1))
+++++
reflexivity.
-----
Lemma ad_list_of_dom_card_1 : forall (m:Map A) (pf:ad -> ad), length (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m) = MapCard A m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma ad_list_of_dom_card :\n   forall m:Map A, length (ad_list_of_dom m) = MapCard A m.
-----
Lemma ad_list_of_dom_card : forall m:Map A, length (ad_list_of_dom m) = MapCard A m.

*****
A : Type
*****
forall m : Map A, eq (length (ad_list_of_dom m)) (MapCard A m)
+++++
Proof.
-----
Lemma ad_list_of_dom_card : forall m:Map A, length (ad_list_of_dom m) = MapCard A m.
Proof.

*****
A : Type
*****
forall m : Map A, eq (length (ad_list_of_dom m)) (MapCard A m)
+++++
exact (fun m:Map A => ad_list_of_dom_card_1 m (fun a:ad => a)).
-----
Lemma ad_list_of_dom_card : forall m:Map A, length (ad_list_of_dom m) = MapCard A m.
Proof.
exact (fun m:Map A => ad_list_of_dom_card_1 m (fun a:ad => a)).

*****

*****

+++++
Qed.
-----
Lemma ad_list_of_dom_not_stutters :\n   forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.

*****
A : Type
*****
forall m : Map A, eq (ad_list_stutters (ad_list_of_dom m)) false
+++++
Proof.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.

*****
A : Type
*****
forall m : Map A, eq (ad_list_stutters (ad_list_of_dom m)) false
+++++
intro.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.

*****
m : Map A
A : Type
*****
eq (ad_list_stutters (ad_list_of_dom m)) false
+++++
apply ad_list_not_stutters_card_conv.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.
apply ad_list_not_stutters_card_conv.

*****
m : Map A
A : Type
*****
eq (length (ad_list_of_dom m)) (MapCard unit (Elems (ad_list_of_dom m)))
+++++
rewrite ad_list_of_dom_card.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.
apply ad_list_not_stutters_card_conv.
rewrite ad_list_of_dom_card.

*****
m : Map A
A : Type
*****
eq (MapCard A m) (MapCard unit (Elems (ad_list_of_dom m)))
+++++
apply sym_eq.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.
apply ad_list_not_stutters_card_conv.
rewrite ad_list_of_dom_card.
apply sym_eq.

*****
m : Map A
A : Type
*****
eq (MapCard unit (Elems (ad_list_of_dom m))) (MapCard A m)
+++++
rewrite (MapCard_Dom A m).
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.
apply ad_list_not_stutters_card_conv.
rewrite ad_list_of_dom_card.
apply sym_eq.
rewrite (MapCard_Dom A m).

*****
m : Map A
A : Type
*****
eq (MapCard unit (Elems (ad_list_of_dom m))) (MapCard unit (MapDom A m))
+++++
apply MapCard_ext.
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.
apply ad_list_not_stutters_card_conv.
rewrite ad_list_of_dom_card.
apply sym_eq.
rewrite (MapCard_Dom A m).
apply MapCard_ext.

*****
m : Map A
A : Type
*****
eqm unit (MapGet unit (Elems (ad_list_of_dom m))) (MapGet unit (MapDom A m))
+++++
exact (Elems_of_list_of_dom m).
-----
Lemma ad_list_of_dom_not_stutters : forall m:Map A, ad_list_stutters (ad_list_of_dom m) = false.
Proof.
intro.
apply ad_list_not_stutters_card_conv.
rewrite ad_list_of_dom_card.
apply sym_eq.
rewrite (MapCard_Dom A m).
apply MapCard_ext.
exact (Elems_of_list_of_dom m).

*****

*****

+++++
Qed.
-----
End ListOfDomDef.
-----
Lemma ad_list_of_dom_Dom_1 :\n   forall (A:Type) (m:Map A) (pf:ad -> ad),\n     MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf\n       m =\n     MapFold1 unit (list ad) nil (app (A:=ad))\n       (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).

*****

*****
forall (A : Type) (m : Map A) (pf : forall _ : ad, ad), eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m))
+++++
Proof.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.

*****

*****
forall (A : Type) (m : Map A) (pf : forall _ : ad, ad), eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m))
+++++
simple induction m.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf (M0 A)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A (M0 A)))
+++++
try trivial.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad), eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a1 : ad) (_ : A) => cons a1 nil) pf (M1 A a a0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a1 : ad) (_ : unit) => cons a1 nil) pf (MapDom A (M1 A a a0)))
+++++
try trivial.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m))) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m0) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m0))) (pf : forall _ : ad, ad), eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf (M2 A m m0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A (M2 A m m0)))
+++++
try trivial.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.
try trivial.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m))) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m0) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m0))) (pf : forall _ : ad, ad), eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf (M2 A m m0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A (M2 A m m0)))
+++++
simpl in |- *.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.
try trivial.
simpl in |- *.

*****
m : Map A
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m))) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) pf m0) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m0))) (pf : forall _ : ad, ad), eq (app (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m0)) (app (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.double a0)) (MapDom A m)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) (MapDom A m0)))
+++++
intros.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)\n (MapFold1 unit (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m1))
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)\n (MapFold1 unit (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m0))
m,m0 : Map A
A : Type
*****
eq (app (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m1)) (app (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.double a0)) (MapDom A m0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) (MapDom A m1)))
+++++
rewrite (H (fun a0:ad => pf (Ndouble a0))).
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.
rewrite (H (fun a0:ad => pf (Ndouble a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)\n (MapFold1 unit (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m1))
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)\n (MapFold1 unit (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m0))
m,m0 : Map A
A : Type
*****
eq (app (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.double a0)) (MapDom A m0)) (MapFold1 A (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : A) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) m1)) (app (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.double a0)) (MapDom A m0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) (MapDom A m1)))
+++++
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.
try trivial.
simpl in |- *.
intros.
rewrite (H (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m1)\n (MapFold1 unit (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m1))
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq\n (MapFold1 A (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : A) => cons a nil) pf m0)\n (MapFold1 unit (list ad) nil (app (A:=ad))\n (fun (a : ad) (_ : unit) => cons a nil) pf (MapDom A m0))
m,m0 : Map A
A : Type
*****
eq (app (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.double a0)) (MapDom A m0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) (MapDom A m1))) (app (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.double a0)) (MapDom A m0)) (MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a : ad) (_ : unit) => cons a nil) (fun a0 : ad => pf (N.succ_double a0)) (MapDom A m1)))
+++++
reflexivity.
-----
Lemma ad_list_of_dom_Dom_1 : forall (A:Type) (m:Map A) (pf:ad -> ad), MapFold1 A (list ad) nil (app (A:=ad)) (fun (a:ad) (_:A) => a :: nil) pf m = MapFold1 unit (list ad) nil (app (A:=ad)) (fun (a:ad) (_:unit) => a :: nil) pf (MapDom A m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma ad_list_of_dom_Dom :\n   forall (A:Type) (m:Map A),\n     ad_list_of_dom A m = ad_list_of_dom unit (MapDom A m).
-----
Lemma ad_list_of_dom_Dom : forall (A:Type) (m:Map A), ad_list_of_dom A m = ad_list_of_dom unit (MapDom A m).

*****

*****
forall (A : Type) (m : Map A), eq (ad_list_of_dom A m) (ad_list_of_dom unit (MapDom A m))
+++++
Proof.
-----
Lemma ad_list_of_dom_Dom : forall (A:Type) (m:Map A), ad_list_of_dom A m = ad_list_of_dom unit (MapDom A m).
Proof.

*****

*****
forall (A : Type) (m : Map A), eq (ad_list_of_dom A m) (ad_list_of_dom unit (MapDom A m))
+++++
intros.
-----
Lemma ad_list_of_dom_Dom : forall (A:Type) (m:Map A), ad_list_of_dom A m = ad_list_of_dom unit (MapDom A m).
Proof.
intros.

*****
m : Map A
A : Type
*****
eq (ad_list_of_dom A m) (ad_list_of_dom unit (MapDom A m))
+++++
exact (ad_list_of_dom_Dom_1 A m (fun a0:ad => a0)).
-----
Lemma ad_list_of_dom_Dom : forall (A:Type) (m:Map A), ad_list_of_dom A m = ad_list_of_dom unit (MapDom A m).
Proof.
intros.
exact (ad_list_of_dom_Dom_1 A m (fun a0:ad => a0)).

*****

*****

+++++
Qed.
-----
End MapLists.
-----
