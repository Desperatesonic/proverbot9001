From Coq Require Import Recdef.
-----
Require Import NArith.
-----
Require Import Sorting.
-----
Require Import GeoCoq.Tactics.Coinc.Permutations.
-----
Require Import GeoCoq.Utils.general_tactics.
-----
Require Import GeoCoq.Utils.sets.
-----
Module SSWP := WPropertiesOn SetOfSetsOfPositiveOrderedType SS.
-----
Module SSWEqP := WEqPropertiesOn SetOfSetsOfPositiveOrderedType SS.
-----
Module Import PosSort := Sort PosOrder.
-----
Section Coinc_refl.
-----
Context {AR : Arity}.
-----
Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.
-----
Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.

*****
cp : cartesianPower positive (S (S m))
s : SS\.elt
m : nat
AR : Arity
*****
bool
+++++
Proof.
-----
Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.
Proof.

*****
cp : cartesianPower positive (S (S m))
s : SS\.elt
m : nat
AR : Arity
*****
bool
+++++
induction m.
-----
Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.
Proof.
induction m.

*****
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
bool
+++++
exact ((S.mem (fst cp) s) && (S.mem (snd cp) s)).
-----
Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.
Proof.
induction m.

*****
IHm : forall _ : cartesianPower positive (S (S m)), bool
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
bool
+++++
exact ((S.mem (fst cp) s) && (IHm (tailCP cp))).
-----
Definition pick_variety_auxCP {m : nat} (s : SS.elt) (cp : cartesianPower positive (S (S m))) : bool.
Proof.
induction m.

*****

*****

+++++
Defined.
-----
Definition pick_variety_aux (s : SS.elt) (t : tST) := pick_variety_auxCP s t.
-----
Lemma pick_variety_auxCP_forallT {m : nat} :\n  forall s (cp : cartesianPower positive (S (S m))),\n  pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).

*****
m : nat
AR : Arity
*****
forall (s : SS.elt) (cp : cartesianPower positive (S (S m))), iff (eq (pick_variety_auxCP s cp) true) (forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true)
+++++
Proof.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.

*****
m : nat
AR : Arity
*****
forall (s : SS.elt) (cp : cartesianPower positive (S (S m))), iff (eq (pick_variety_auxCP s cp) true) (forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true)
+++++
induction m; intros s cp; [unfold InCP|]; simpl; split.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
forall (_ : eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) true) (p : positive) (_ : or (eq (fst cp) p) (or (eq (snd cp) p) False)), eq (S.mem p s) true
+++++
intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].

*****
Hmem2 : eq (S.mem (snd cp) s) true
Hmem1 : eq (S.mem (fst cp) s) true
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
forall (p : positive) (_ : or (eq (fst cp) p) (or (eq (snd cp) p) False)), eq (S.mem p s) true
+++++
intros p H; do 2 (try (elim H; clear H; intro; subst)); auto.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
forall _ : forall (p : positive) (_ : or (eq (fst cp) p) (or (eq (snd cp) p) False)), eq (S.mem p s) true, eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) true
+++++
intro H; apply andb_true_iff; split; [apply (H (fst cp))|apply (H (snd cp))]; auto.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) true)\n (forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true)
m : nat
AR : Arity
*****
forall (_ : eq (andb (S.mem (fst cp) s) (pick_variety_auxCP s (snd cp))) true) (p : positive) (_ : InCP p cp), eq (S.mem p s) true
+++++
intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].

*****
Hmem2 : eq (pick_variety_auxCP s (snd cp)) true
Hmem1 : eq (S.mem (fst cp) s) true
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) true)\n (forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true)
m : nat
AR : Arity
*****
forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true
+++++
intros p H; apply InCPOK in H; elim H; clear H; intro HIn; subst; simpl; auto.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro Hmem; apply andb_true_iff in Hmem; destruct Hmem as [Hmem1 Hmem2].
intros p H; apply InCPOK in H; elim H; clear H; intro HIn; subst; simpl; auto.

*****
HIn : InCP p (tailCP cp)
p : positive
Hmem2 : eq (pick_variety_auxCP s (snd cp)) true
Hmem1 : eq (S.mem (fst cp) s) true
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) true)\n (forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true)
m : nat
AR : Arity
*****
eq (S.mem p s) true
+++++
destruct (IHm s (tailCP cp)) as [H _]; apply H; auto.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) true)\n (forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true)
m : nat
AR : Arity
*****
forall _ : forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true, eq (andb (S.mem (fst cp) s) (pick_variety_auxCP s (snd cp))) true
+++++
destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.

*****
IHm : forall\n _ : forall (p : positive) (_ : InCP p (tailCP cp)),\n eq (S.mem p s) true, eq (pick_variety_auxCP s (tailCP cp)) true
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
forall _ : forall (p : positive) (_ : InCP p cp), eq (S.mem p s) true, eq (andb (S.mem (fst cp) s) (pick_variety_auxCP s (snd cp))) true
+++++
intro H; apply andb_true_iff; split; [apply (H (fst cp))|apply IHm; intros p HIn; apply H]; apply InCPOK; auto.
-----
Lemma pick_variety_auxCP_forallT {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = true <-> (forall p, InCP p cp -> S.mem p s = true).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****

*****

+++++
Qed.
-----
Lemma pick_variety_auxCP_existsF {m : nat} :\n  forall s (cp : cartesianPower positive (S (S m))),\n  pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\ S.mem p s = false).
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).

*****
m : nat
AR : Arity
*****
forall (s : SS.elt) (cp : cartesianPower positive (S (S m))), iff (eq (pick_variety_auxCP s cp) false) (ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)))
+++++
Proof.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.

*****
m : nat
AR : Arity
*****
forall (s : SS.elt) (cp : cartesianPower positive (S (S m))), iff (eq (pick_variety_auxCP s cp) false) (ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)))
+++++
induction m; intros s cp; [unfold InCP|]; simpl; split.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
forall _ : eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) false, ex (fun p : positive => and (or (eq (fst cp) p) (or (eq (snd cp) p) False)) (eq (S.mem p s) false))
+++++
intro H; apply andb_false_iff in H; elim H; clear H; intro H; [exists (fst cp)|exists (snd cp)]; auto.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
forall _ : ex (fun p : positive => and (or (eq (fst cp) p) (or (eq (snd cp) p) False)) (eq (S.mem p s) false)), eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) false
+++++
intro H; destruct H as [p [H Hmem]]; apply andb_false_iff.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro H; destruct H as [p [H Hmem]]; apply andb_false_iff.

*****
Hmem : eq (S.mem p s) false
H : or (eq (fst cp) p) (or (eq (snd cp) p) False)
p : positive
cp : cartesianPower positive (S (S O))
s : SS\.elt
AR : Arity
*****
or (eq (S.mem (fst cp) s) false) (eq (S.mem (snd cp) s) false)
+++++
do 2 (try (elim H; clear H; intro H; subst)); intuition.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) false)\n (ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)))
m : nat
AR : Arity
*****
forall _ : eq (andb (S.mem (fst cp) s) (pick_variety_auxCP s (snd cp))) false, ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false))
+++++
intro H; apply andb_false_iff in H.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro H; apply andb_false_iff in H.

*****
H : or (eq (S.mem (fst cp) s) false)\n (eq (pick_variety_auxCP s (snd cp)) false)
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) false)\n (ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)))
m : nat
AR : Arity
*****
ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false))
+++++
destruct (IHm s (tailCP cp)) as [H' _]; clear IHm; rename H' into IHm.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro H; apply andb_false_iff in H.
destruct (IHm s (tailCP cp)) as [H' _]; clear IHm; rename H' into IHm.

*****
IHm : forall _ : eq (pick_variety_auxCP s (tailCP cp)) false,\nex\n (fun p : positive => and (InCP p (tailCP cp)) (eq (S.mem p s) false))
H : or (eq (S.mem (fst cp) s) false)\n (eq (pick_variety_auxCP s (snd cp)) false)
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false))
+++++
elim H; clear H; intro Hmem.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro H; apply andb_false_iff in H.
destruct (IHm s (tailCP cp)) as [H' _]; clear IHm; rename H' into IHm.
elim H; clear H; intro Hmem.

*****
Hmem : eq (S.mem (fst cp) s) false
IHm : forall _ : eq (pick_variety_auxCP s (tailCP cp)) false,\nex\n (fun p : positive => and (InCP p (tailCP cp)) (eq (S.mem p s) false))
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false))
+++++
exists (fst cp); unfold InCP; simpl; auto.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
intro H; apply andb_false_iff in H.
destruct (IHm s (tailCP cp)) as [H' _]; clear IHm; rename H' into IHm.
elim H; clear H; intro Hmem.

*****
Hmem : eq (pick_variety_auxCP s (snd cp)) false
IHm : forall _ : eq (pick_variety_auxCP s (tailCP cp)) false,\nex\n (fun p : positive => and (InCP p (tailCP cp)) (eq (S.mem p s) false))
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false))
+++++
destruct (IHm Hmem) as [p [HIn Hmem']]; exists p; split; try apply InCPOK; auto.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
IHm : forall (s : SS.elt) (cp : cartesianPower positive (S (S m))),\niff (eq (pick_variety_auxCP s cp) false)\n (ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)))
m : nat
AR : Arity
*****
forall _ : ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)), eq (andb (S.mem (fst cp) s) (pick_variety_auxCP s (snd cp))) false
+++++
destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.

*****
IHm : forall\n _ : ex\n (fun p : positive =>\n and (InCP p (tailCP cp)) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s (tailCP cp)) false
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
forall _ : ex (fun p : positive => and (InCP p cp) (eq (S.mem p s) false)), eq (andb (S.mem (fst cp) s) (pick_variety_auxCP s (snd cp))) false
+++++
intro H; destruct H as [p [HIn Hmem]]; apply InCPOK in HIn; apply andb_false_iff.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.
intro H; destruct H as [p [HIn Hmem]]; apply InCPOK in HIn; apply andb_false_iff.

*****
Hmem : eq (S.mem p s) false
HIn : or (eq p (headCP cp)) (InCP p (tailCP cp))
p : positive
IHm : forall\n _ : ex\n (fun p : positive =>\n and (InCP p (tailCP cp)) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s (tailCP cp)) false
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
or (eq (S.mem (fst cp) s) false) (eq (pick_variety_auxCP s (snd cp)) false)
+++++
elim HIn; clear HIn; intro HIn; subst; auto.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.
destruct (IHm s (tailCP cp)) as [_ H]; clear IHm; rename H into IHm.
intro H; destruct H as [p [HIn Hmem]]; apply InCPOK in HIn; apply andb_false_iff.
elim HIn; clear HIn; intro HIn; subst; auto.

*****
HIn : InCP p (tailCP cp)
Hmem : eq (S.mem p s) false
p : positive
IHm : forall\n _ : ex\n (fun p : positive =>\n and (InCP p (tailCP cp)) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s (tailCP cp)) false
cp : cartesianPower positive (S (S (S m)))
s : SS\.elt
m : nat
AR : Arity
*****
or (eq (S.mem (fst cp) s) false) (eq (pick_variety_auxCP s (snd cp)) false)
+++++
right; apply IHm; exists p; auto.
-----
Lemma pick_variety_auxCP_existsF {m : nat} : forall s (cp : cartesianPower positive (S (S m))), pick_variety_auxCP s cp = false <-> (exists p, InCP p cp /\\ S.mem p s = false).
Proof.
induction m; intros s cp; [unfold InCP|]; simpl; split.

*****

*****

+++++
Qed.
-----
Lemma proper_00 :\n  forall s,\n  Proper\n  ((fun (t1 t2 : tST) =>\n     eqST t1 t2) ==> eq)\n  (fun t : tST => pick_variety_aux s t).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).

*****
AR : Arity
*****
forall s : SS.elt, Proper (respectful (fun t1 t2 : tST => eqST t1 t2) eq) (fun t : tST => pick_variety_aux s t)
+++++
Proof.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.

*****
AR : Arity
*****
forall s : SS.elt, Proper (respectful (fun t1 t2 : tST => eqST t1 t2) eq) (fun t : tST => pick_variety_aux s t)
+++++
unfold pick_variety_aux.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.

*****
AR : Arity
*****
forall s : SS.elt, Proper (respectful (fun t1 t2 : tST => eqST t1 t2) eq) (fun t : tST => pick_variety_auxCP s t)
+++++
unfold eqST.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.

*****
AR : Arity
*****
forall s : SS.elt, Proper (respectful (fun t1 t2 : tST => eqList (sets.PosSort.sort (CPToList t1)) (sets.PosSort.sort (CPToList t2))) eq) (fun t : tST => pick_variety_auxCP s t)
+++++
intros s t1 t2 HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.

*****
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq (pick_variety_auxCP s t1) (pick_variety_auxCP s t2)
+++++
case_eq (pick_variety_auxCP s t1).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).

*****
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
forall _ : eq (pick_variety_auxCP s t1) true, eq true (pick_variety_auxCP s t2)
+++++
intro Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.

*****
Ht1 : eq (pick_variety_auxCP s t1) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].

*****
H2 : forall _ : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true,\neq (pick_variety_auxCP s t1) true
H1 : forall (_ : eq (pick_variety_auxCP s t1) true) (p : positive)\n (_ : InCP p t1), eq (S.mem p s) true
Ht1 : eq (pick_variety_auxCP s t1) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
clear H2.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.

*****
H1 : forall (_ : eq (pick_variety_auxCP s t1) true) (p : positive)\n (_ : InCP p t1), eq (S.mem p s) true
Ht1 : eq (pick_variety_auxCP s t1) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
assert (H := H1 Ht1).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).

*****
H : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
H1 : forall (_ : eq (pick_variety_auxCP s t1) true) (p : positive)\n (_ : InCP p t1), eq (S.mem p s) true
Ht1 : eq (pick_variety_auxCP s t1) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
clear H1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.

*****
H : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
Ht1 : eq (pick_variety_auxCP s t1) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
clear Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.

*****
H : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
rename H into Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.

*****
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].

*****
H2 : forall _ : forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true,\neq (pick_variety_auxCP s t2) true
H1 : forall (_ : eq (pick_variety_auxCP s t2) true) (p : positive)\n (_ : InCP p t2), eq (S.mem p s) true
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
clear H1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.

*****
H2 : forall _ : forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true,\neq (pick_variety_auxCP s t2) true
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true (pick_variety_auxCP s t2)
+++++
rewrite H2.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.

*****
H2 : forall _ : forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true,\neq (pick_variety_auxCP s t2) true
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq true true
+++++
try reflexivity.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.

*****
H2 : forall _ : forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true,\neq (pick_variety_auxCP s t2) true
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true
+++++
try reflexivity.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.

*****
H2 : forall _ : forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true,\neq (pick_variety_auxCP s t2) true
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true
+++++
clear H2.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.

*****
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
forall (p : positive) (_ : InCP p t2), eq (S.mem p s) true
+++++
intros p HIn.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.

*****
HIn : InCP p t2
p : positive
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq (S.mem p s) true
+++++
apply Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.

*****
HIn : InCP p t2
p : positive
Ht1 : forall (p : positive) (_ : InCP p t1), eq (S.mem p s) true
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p t1
+++++
clear Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.

*****
HIn : InCP p t2
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p t1
+++++
apply InCPOCP.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.

*****
HIn : InCP p t2
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t1)
+++++
apply InCPOCP in HIn.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.

*****
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t1)
+++++
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).

*****
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (CPToList (OCP t2))
+++++
assert (Ht1 := eqListSortOCP t1).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).

*****
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (CPToList (OCP t2))
+++++
assert (Ht2 := eqListSortOCP t2).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (CPToList (OCP t2))
+++++
apply eqListTrans with (PosSort.sort (CPToList t1)).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (sort (CPToList t1))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t1)) (CPToList (OCP t2))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t1)) (CPToList (OCP t2))
+++++
apply eqListTrans with (PosSort.sort (CPToList t2)).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t1)) (sort (CPToList t2))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t2)) (CPToList (OCP t2))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).
try assumption.

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t2)) (CPToList (OCP t2))
+++++
apply eqListSym.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).
try assumption.
apply eqListSym.

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t2)) (sort (CPToList t2))
+++++
assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).

*****
H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))
HIn : InCP p (OCP t2)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t1)
+++++
clear HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.

*****
H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))
HIn : InCP p (OCP t2)
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t1)
+++++
rename H into HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.

*****
HEq : eqList (CPToList (OCP t1)) (CPToList (OCP t2))
HIn : InCP p (OCP t2)
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t1)
+++++
apply eqListOK in HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.
apply eqListOK in HEq.

*****
HEq : eq (CPToList (OCP t1)) (CPToList (OCP t2))
HIn : InCP p (OCP t2)
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t1)
+++++
unfold InCP in *.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.
apply eqListOK in HEq.
unfold InCP in *.

*****
HEq : eq (CPToList (OCP t1)) (CPToList (OCP t2))
HIn : In p (CPToList (OCP t2))
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
In p (CPToList (OCP t1))
+++++
rewrite HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_forallT s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_forallT s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
intros p HIn.
apply Ht1.
clear Ht1.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.
apply eqListOK in HEq.
unfold InCP in *.
rewrite HEq.

*****
HEq : eq (CPToList (OCP t1)) (CPToList (OCP t2))
HIn : In p (CPToList (OCP t2))
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
In p (CPToList (OCP t2))
+++++
auto.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).

*****
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
forall _ : eq (pick_variety_auxCP s t1) false, eq false (pick_variety_auxCP s t2)
+++++
intro Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.

*****
Ht1 : eq (pick_variety_auxCP s t1) false
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].

*****
H2 : forall\n _ : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s t1) false
H1 : forall _ : eq (pick_variety_auxCP s t1) false,\nex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
Ht1 : eq (pick_variety_auxCP s t1) false
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
clear H2.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.

*****
H1 : forall _ : eq (pick_variety_auxCP s t1) false,\nex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
Ht1 : eq (pick_variety_auxCP s t1) false
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
assert (H := H1 Ht1).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).

*****
H : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
H1 : forall _ : eq (pick_variety_auxCP s t1) false,\nex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
Ht1 : eq (pick_variety_auxCP s t1) false
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
clear H1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.

*****
H : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
Ht1 : eq (pick_variety_auxCP s t1) false
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
clear Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.

*****
H : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
rename H into Ht1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.

*****
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].

*****
H2 : forall\n _ : ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s t2) false
H1 : forall _ : eq (pick_variety_auxCP s t2) false,\nex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false))
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
clear H1.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.

*****
H2 : forall\n _ : ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s t2) false
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false (pick_variety_auxCP s t2)
+++++
rewrite H2.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.

*****
H2 : forall\n _ : ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s t2) false
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq false false
+++++
try reflexivity.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.

*****
H2 : forall\n _ : ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s t2) false
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false))
+++++
try reflexivity.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.

*****
H2 : forall\n _ : ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false)),\neq (pick_variety_auxCP s t2) false
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false))
+++++
clear H2.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.

*****
Ht1 : ex (fun p : positive => and (InCP p t1) (eq (S.mem p s) false))
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false))
+++++
destruct Ht1 as [p [HIn Hmem]].
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].

*****
Hmem : eq (S.mem p s) false
HIn : InCP p t1
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
ex (fun p : positive => and (InCP p t2) (eq (S.mem p s) false))
+++++
exists p.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.

*****
Hmem : eq (S.mem p s) false
HIn : InCP p t1
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
and (InCP p t2) (eq (S.mem p s) false)
+++++
split.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.

*****
Hmem : eq (S.mem p s) false
HIn : InCP p t1
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p t2
+++++
auto.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.

*****
Hmem : eq (S.mem p s) false
HIn : InCP p t1
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p t2
+++++
apply InCPOCP.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.

*****
Hmem : eq (S.mem p s) false
HIn : InCP p t1
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t2)
+++++
apply InCPOCP in HIn.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.

*****
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t2)
+++++
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).

*****
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (CPToList (OCP t2))
+++++
assert (Ht1 := eqListSortOCP t1).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).

*****
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (CPToList (OCP t2))
+++++
assert (Ht2 := eqListSortOCP t2).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (CPToList (OCP t2))
+++++
apply eqListTrans with (PosSort.sort (CPToList t1)).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t1)) (sort (CPToList t1))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t1)) (CPToList (OCP t2))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t1)) (CPToList (OCP t2))
+++++
apply eqListTrans with (PosSort.sort (CPToList t2)).
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t1)) (sort (CPToList t2))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t2)) (CPToList (OCP t2))
+++++
try assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).
try assumption.

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (sort (CPToList t2)) (CPToList (OCP t2))
+++++
apply eqListSym.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
assert (Ht1 := eqListSortOCP t1).
assert (Ht2 := eqListSortOCP t2).
apply eqListTrans with (PosSort.sort (CPToList t1)).
try assumption.
apply eqListTrans with (PosSort.sort (CPToList t2)).
try assumption.
apply eqListSym.

*****
Ht2 : eqList (CPToList (OCP t2)) (sets.PosSort.sort (CPToList t2))
Ht1 : eqList (CPToList (OCP t1)) (sets.PosSort.sort (CPToList t1))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eqList (CPToList (OCP t2)) (sort (CPToList t2))
+++++
assumption.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).

*****
H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t2)
+++++
clear HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.

*****
H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t2)
+++++
rename H into HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.

*****
HEq : eqList (CPToList (OCP t1)) (CPToList (OCP t2))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t2)
+++++
apply eqListOK in HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.
apply eqListOK in HEq.

*****
HEq : eq (CPToList (OCP t1)) (CPToList (OCP t2))
Hmem : eq (S.mem p s) false
HIn : InCP p (OCP t1)
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
InCP p (OCP t2)
+++++
unfold InCP in *.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.
apply eqListOK in HEq.
unfold InCP in *.

*****
HEq : eq (CPToList (OCP t1)) (CPToList (OCP t2))
Hmem : eq (S.mem p s) false
HIn : In p (CPToList (OCP t1))
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
In p (CPToList (OCP t2))
+++++
rewrite <- HEq.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.
auto.
apply InCPOCP.
apply InCPOCP in HIn.
assert (H : eqList (CPToList (OCP t1)) (CPToList (OCP t2))).
clear HEq.
rename H into HEq.
apply eqListOK in HEq.
unfold InCP in *.
rewrite <- HEq.

*****
HEq : eq (CPToList (OCP t1)) (CPToList (OCP t2))
Hmem : eq (S.mem p s) false
HIn : In p (CPToList (OCP t1))
p : positive
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
In p (CPToList (OCP t1))
+++++
auto.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).
intro Ht1.
destruct (pick_variety_auxCP_existsF s t1) as [H1 H2].
clear H2.
assert (H := H1 Ht1).
clear H1.
clear Ht1.
rename H into Ht1.
destruct (pick_variety_auxCP_existsF s t2) as [H1 H2].
clear H1.
rewrite H2.
try reflexivity.
clear H2.
destruct Ht1 as [p [HIn Hmem]].
exists p.
split.

*****
Hmem : eq (S.mem p s) false
HIn : InCP p t1
p : positive
HEq : eqList (sets.PosSort.sort (CPToList t1))\n (sets.PosSort.sort (CPToList t2))
t1,t2 : tST
s : SS\.elt
AR : Arity
*****
eq (S.mem p s) false
+++++
auto.
-----
Lemma proper_00 : forall s, Proper ((fun (t1 t2 : tST) => eqST t1 t2) ==> eq) (fun t : tST => pick_variety_aux s t).
Proof.
unfold pick_variety_aux.
unfold eqST.
intros s t1 t2 HEq.
case_eq (pick_variety_auxCP s t1).

*****

*****

+++++
Qed.
-----
Definition pick_variety (s : SS.elt) (st : STt) :=\n  STexists_ (fun t => pick_variety_aux s t) st.
-----
Lemma proper_0 :\n  Proper (S.Equal ==> eq ==> eq) pick_variety.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.

*****
AR : Arity
*****
Proper (respectful S.Equal (respectful eq eq)) pick_variety
+++++
Proof.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.

*****
AR : Arity
*****
Proper (respectful S.Equal (respectful eq eq)) pick_variety
+++++
intros x1 y1 HXY1.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.

*****
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
respectful eq eq (pick_variety x1) (pick_variety y1)
+++++
intros x2 y2 HXY2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.

*****
HXY2 : eq x2 y2
x2,y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (pick_variety x1 x2) (pick_variety y1 y2)
+++++
rewrite HXY2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.

*****
HXY2 : eq x2 y2
x2,y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (pick_variety x1 y2) (pick_variety y1 y2)
+++++
clear HXY2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.

*****
x2,y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (pick_variety x1 y2) (pick_variety y1 y2)
+++++
clear x2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.

*****
y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (pick_variety x1 y2) (pick_variety y1 y2)
+++++
unfold pick_variety.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.

*****
y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (STexists_ (fun t : STelt => pick_variety_aux x1 t) y2) (STexists_ (fun t : STelt => pick_variety_aux y1 t) y2)
+++++
unfold pick_variety_aux.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.

*****
y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (STexists_ (fun t : STelt => pick_variety_auxCP x1 t) y2) (STexists_ (fun t : STelt => pick_variety_auxCP y1 t) y2)
+++++
unfold STexists_.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.

*****
y2 : STt
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP x1 t) y2) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2)
+++++
induction y2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.

*****
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq false false
+++++
try reflexivity.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.

*****
IHy2 : eq\n ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} :\n bool :=\n match s with\n | nil => false\n | cons hd tl => orb (f hd) (STexists_ f tl)\n end) (fun t : STelt => pick_variety_auxCP x1 t) y2)\n ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} :\n bool :=\n match s with\n | nil => false\n | cons hd tl => orb (f hd) (STexists_ f tl)\n end) (fun t : STelt => pick_variety_auxCP y1 t) y2)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP x1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
try reflexivity.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.

*****
IHy2 : eq\n ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} :\n bool :=\n match s with\n | nil => false\n | cons hd tl => orb (f hd) (STexists_ f tl)\n end) (fun t : STelt => pick_variety_auxCP x1 t) y2)\n ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} :\n bool :=\n match s with\n | nil => false\n | cons hd tl => orb (f hd) (STexists_ f tl)\n end) (fun t : STelt => pick_variety_auxCP y1 t) y2)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP x1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
rewrite IHy2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.

*****
IHy2 : eq\n ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} :\n bool :=\n match s with\n | nil => false\n | cons hd tl => orb (f hd) (STexists_ f tl)\n end) (fun t : STelt => pick_variety_auxCP x1 t) y2)\n ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} :\n bool :=\n match s with\n | nil => false\n | cons hd tl => orb (f hd) (STexists_ f tl)\n end) (fun t : STelt => pick_variety_auxCP y1 t) y2)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
clear IHy2.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.

*****
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).

*****
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall e : S.elt, eq (S.mem e x1) (S.mem e y1)
+++++
intro.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
intro.

*****
e : S\.elt
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (S.mem e x1) (S.mem e y1)
+++++
apply SWP.Dec.F.mem_m.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
intro.
apply SWP.Dec.F.mem_m.

*****
e : S\.elt
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq e e
+++++
intuition.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
intro.
apply SWP.Dec.F.mem_m.

*****
e : S\.elt
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
S.Equal x1 y1
+++++
intuition.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).

*****
HEqMem : forall e : S.elt, eq (S.mem e x1) (S.mem e y1)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
idtac.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
idtac.

*****
HEqMem : forall e : S.elt, eq (S.mem e x1) (S.mem e y1)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
assert (HF : forall n a, (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) x1 && S.mem (snd t0) x1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) x1 && F n0 (tailCP t0) end) n a = (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) y1 && S.mem (snd t0) y1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) y1 && F n0 (tailCP t0) end) n a) by (induction n; try (intro; do 2 (rewrite HEqMem); reflexivity); intro ; rewrite HEqMem; rewrite IHn; reflexivity).
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
idtac.
assert (HF : forall n a, (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) x1 && S.mem (snd t0) x1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) x1 && F n0 (tailCP t0) end) n a = (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) y1 && S.mem (snd t0) y1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) y1 && F n0 (tailCP t0) end) n a) by (induction n; try (intro; do 2 (rewrite HEqMem); reflexivity); intro ; rewrite HEqMem; rewrite IHn; reflexivity).

*****
HF : forall (n : nat) (a : cartesianPower positive (S (S n))),\neq\n ((fix F (n0 : nat) :\n forall _ : cartesianPower positive (S (S n0)), bool :=\n match\n n0 as n1\n return (forall _ : cartesianPower positive (S (S n1)), bool)\n with\n | O =>\n fun t0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst t0) x1) (S.mem (snd t0) x1)\n | S n1 =>\n fun t0 : cartesianPower positive (S (S (S n1))) =>\n andb (S.mem (headCP t0) x1) (F n1 (tailCP t0))\n end) n a)\n ((fix F (n0 : nat) :\n forall _ : cartesianPower positive (S (S n0)), bool :=\n match\n n0 as n1\n return (forall _ : cartesianPower positive (S (S n1)), bool)\n with\n | O =>\n fun t0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst t0) y1) (S.mem (snd t0) y1)\n | S n1 =>\n fun t0 : cartesianPower positive (S (S (S n1))) =>\n andb (S.mem (headCP t0) y1) (F n1 (tailCP t0))\n end) n a)
HEqMem : forall e : S.elt, eq (S.mem e x1) (S.mem e y1)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (pick_variety_auxCP x1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2)) (orb (pick_variety_auxCP y1 a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => pick_variety_auxCP y1 t) y2))
+++++
unfold pick_variety_auxCP.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
idtac.
assert (HF : forall n a, (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) x1 && S.mem (snd t0) x1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) x1 && F n0 (tailCP t0) end) n a = (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) y1 && S.mem (snd t0) y1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) y1 && F n0 (tailCP t0) end) n a) by (induction n; try (intro; do 2 (rewrite HEqMem); reflexivity); intro ; rewrite HEqMem; rewrite IHn; reflexivity).
unfold pick_variety_auxCP.

*****
HF : forall (n : nat) (a : cartesianPower positive (S (S n))),\neq\n ((fix F (n0 : nat) :\n forall _ : cartesianPower positive (S (S n0)), bool :=\n match\n n0 as n1\n return (forall _ : cartesianPower positive (S (S n1)), bool)\n with\n | O =>\n fun t0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst t0) x1) (S.mem (snd t0) x1)\n | S n1 =>\n fun t0 : cartesianPower positive (S (S (S n1))) =>\n andb (S.mem (headCP t0) x1) (F n1 (tailCP t0))\n end) n a)\n ((fix F (n0 : nat) :\n forall _ : cartesianPower positive (S (S n0)), bool :=\n match\n n0 as n1\n return (forall _ : cartesianPower positive (S (S n1)), bool)\n with\n | O =>\n fun t0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst t0) y1) (S.mem (snd t0) y1)\n | S n1 =>\n fun t0 : cartesianPower positive (S (S (S n1))) =>\n andb (S.mem (headCP t0) y1) (F n1 (tailCP t0))\n end) n a)
HEqMem : forall e : S.elt, eq (S.mem e x1) (S.mem e y1)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) x1) (S.mem (snd cp) x1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) x1) (IHm (tailCP cp))) n a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) y1) (S.mem (snd cp) y1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) y1) (IHm (tailCP cp))) n t) y2)) (orb (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) y1) (S.mem (snd cp) y1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) y1) (IHm (tailCP cp))) n a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) y1) (S.mem (snd cp) y1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) y1) (IHm (tailCP cp))) n t) y2))
+++++
rewrite HF.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.
try reflexivity.
rewrite IHy2.
clear IHy2.
assert (HEqMem : forall e, S.mem e x1 = S.mem e y1).
idtac.
assert (HF : forall n a, (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) x1 && S.mem (snd t0) x1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) x1 && F n0 (tailCP t0) end) n a = (fix F (n : nat) : cartesianPower positive (S (S n)) -> bool := match n as n0 return (cartesianPower positive (S (S n0)) -> bool) with | 0 => fun t0 : cartesianPower positive 2 => S.mem (fst t0) y1 && S.mem (snd t0) y1 | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => S.mem (headCP t0) y1 && F n0 (tailCP t0) end) n a) by (induction n; try (intro; do 2 (rewrite HEqMem); reflexivity); intro ; rewrite HEqMem; rewrite IHn; reflexivity).
unfold pick_variety_auxCP.
rewrite HF.

*****
HF : forall (n : nat) (a : cartesianPower positive (S (S n))),\neq\n ((fix F (n0 : nat) :\n forall _ : cartesianPower positive (S (S n0)), bool :=\n match\n n0 as n1\n return (forall _ : cartesianPower positive (S (S n1)), bool)\n with\n | O =>\n fun t0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst t0) x1) (S.mem (snd t0) x1)\n | S n1 =>\n fun t0 : cartesianPower positive (S (S (S n1))) =>\n andb (S.mem (headCP t0) x1) (F n1 (tailCP t0))\n end) n a)\n ((fix F (n0 : nat) :\n forall _ : cartesianPower positive (S (S n0)), bool :=\n match\n n0 as n1\n return (forall _ : cartesianPower positive (S (S n1)), bool)\n with\n | O =>\n fun t0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst t0) y1) (S.mem (snd t0) y1)\n | S n1 =>\n fun t0 : cartesianPower positive (S (S (S n1))) =>\n andb (S.mem (headCP t0) y1) (F n1 (tailCP t0))\n end) n a)
HEqMem : forall e : S.elt, eq (S.mem e x1) (S.mem e y1)
y2 : list tST
a : tST
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (orb ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), bool := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), bool) with | O => fun t0 : cartesianPower positive (S (S O)) => andb (S.mem (fst t0) y1) (S.mem (snd t0) y1) | S n0 => fun t0 : cartesianPower positive (S (S (S n0))) => andb (S.mem (headCP t0) y1) (F n0 (tailCP t0)) end) n a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) y1) (S.mem (snd cp) y1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) y1) (IHm (tailCP cp))) n t) y2)) (orb (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) y1) (S.mem (snd cp) y1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) y1) (IHm (tailCP cp))) n a) ((fix STexists_ (f : forall _ : STelt, bool) (s : STt) {struct s} : bool := match s with | nil => false | cons hd tl => orb (f hd) (STexists_ f tl) end) (fun t : STelt => nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) y1) (S.mem (snd cp) y1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) y1) (IHm (tailCP cp))) n t) y2))
+++++
reflexivity.
-----
Lemma proper_0 : Proper (S.Equal ==> eq ==> eq) pick_variety.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
rewrite HXY2.
clear HXY2.
clear x2.
unfold pick_variety.
unfold pick_variety_aux.
unfold STexists_.
induction y2.

*****

*****

+++++
Qed.
-----
Lemma proper_1 : forall s1 st,\n  Proper (S.Equal ==> eq)\n  (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).

*****
AR : Arity
*****
forall (s1 : S.t) (st : STt), Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)
+++++
Proof.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.

*****
AR : Arity
*****
forall (s1 : S.t) (st : STt), Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)
+++++
intros s1 st.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.

*****
st : STt
s1 : S\.t
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)
+++++
intros x y HXY.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.

*****
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
eq (pick_variety (S.inter s1 x) st) (pick_variety (S.inter s1 y) st)
+++++
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).

*****
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
S.Equal (S.inter s1 x) (S.inter s1 y)
+++++
apply SWP.inter_equal_2.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).
apply SWP.inter_equal_2.

*****
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
S.Equal x y
+++++
assumption.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).

*****
HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
eq (pick_variety (S.inter s1 x) st) (pick_variety (S.inter s1 y) st)
+++++
idtac.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).
idtac.

*****
HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
eq (pick_variety (S.inter s1 x) st) (pick_variety (S.inter s1 y) st)
+++++
apply proper_0.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).
idtac.
apply proper_0.

*****
HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
S.Equal (S.inter s1 x) (S.inter s1 y)
+++++
auto.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).
idtac.
apply proper_0.

*****
HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)
HXY : S.Equal x y
x,y : S\.t
st : STt
s1 : S\.t
AR : Arity
*****
eq st st
+++++
auto.
-----
Lemma proper_1 : forall s1 st, Proper (S.Equal ==> eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
Proof.
intros s1 st.
intros x y HXY.
assert (HEqI : S.Equal (S.inter s1 x) (S.inter s1 y)).

*****

*****

+++++
Qed.
-----
Definition exists_witness (f : SS.elt -> bool) (s : SS.t) : option SS.elt :=\n  SS.choose (SS.filter f s).
-----
Lemma exists_witness_ok : forall e f s,\n  Proper (S.Equal ==> eq) f ->\n  exists_witness f s = Some e -> SS.In e s.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.

*****
AR : Arity
*****
forall (e : SS.elt) (f : forall _ : S.t, bool) (s : SS.t) (_ : Proper (respectful S.Equal eq) f) (_ : eq (exists_witness f s) (Some e)), SS.In e s
+++++
Proof.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.

*****
AR : Arity
*****
forall (e : SS.elt) (f : forall _ : S.t, bool) (s : SS.t) (_ : Proper (respectful S.Equal eq) f) (_ : eq (exists_witness f s) (Some e)), SS.In e s
+++++
intros e f s HP H.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.

*****
H : eq (exists_witness f s) (Some e)
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
SS.In e s
+++++
unfold exists_witness in H.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.

*****
H : eq (SS.choose (SS.filter f s)) (Some e)
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
SS.In e s
+++++
apply SSWEqP.MP.Dec.F.mem_2.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.

*****
H : eq (SS.choose (SS.filter f s)) (Some e)
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
eq (SS.mem e s) true
+++++
apply SSWEqP.choose_mem_1 in H.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.

*****
H : eq (SS.mem e (SS.filter f s)) true
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
eq (SS.mem e s) true
+++++
rewrite SSWEqP.filter_mem in H.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.
rewrite SSWEqP.filter_mem in H.

*****
H : eq (andb (SS.mem e s) (f e)) true
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
eq (SS.mem e s) true
+++++
try assumption.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.
rewrite SSWEqP.filter_mem in H.
try assumption.

*****
H : eq (andb (SS.mem e s) (f e)) true
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
eq (SS.mem e s) true
+++++
apply andb_true_iff in H.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.
rewrite SSWEqP.filter_mem in H.
try assumption.
apply andb_true_iff in H.

*****
H : and (eq (SS.mem e s) true) (eq (f e) true)
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
eq (SS.mem e s) true
+++++
induction H.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.
rewrite SSWEqP.filter_mem in H.
try assumption.
apply andb_true_iff in H.
induction H.

*****
H0 : eq (f e) true
H : eq (SS.mem e s) true
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
eq (SS.mem e s) true
+++++
assumption.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.
rewrite SSWEqP.filter_mem in H.

*****
H : eq (SS.mem e (SS.filter f s)) true
HP : Proper (respectful S.Equal eq) f
s : SS\.t
f : forall _ : S.t, bool
e : SS\.elt
AR : Arity
*****
Proper (respectful S.Equal eq) f
+++++
try assumption.
-----
Lemma exists_witness_ok : forall e f s, Proper (S.Equal ==> eq) f -> exists_witness f s = Some e -> SS.In e s.
Proof.
intros e f s HP H.
unfold exists_witness in H.
apply SSWEqP.MP.Dec.F.mem_2.
apply SSWEqP.choose_mem_1 in H.
rewrite SSWEqP.filter_mem in H.

*****

*****

+++++
Qed.
-----
Definition pick_varieties_aux (s1 : SS.elt) (ss : SS.t) (st : STt)\n                              : (option (SS.elt * SS.elt)) :=\n  match ((exists_witness (fun s2 => let i := S.inter s1 s2 in\n                                    pick_variety i st)) ss) with\n    | None => None\n    | Some s2 => Some(s1,s2)\n  end.
-----
Definition pick_varieties (ss : SS.t) (st : STt)\n                          : (option (SS.elt * SS.elt)) :=\n  match (exists_witness (fun s =>\n                           match (pick_varieties_aux s (SS.remove s ss) st) with\n                             | None => false\n                             | _ => true\n                           end) ss) with\n    | None => None\n    | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n  end.
-----
Definition eqop (p1 p2 : option SS.elt) :=\n  match p1,p2 with\n    | None, None => True\n    | Some s1, Some s2 => True\n    | _, _ => False\n  end.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t),\n  Proper (S.Equal ==> eq) f1 ->\n  Proper (S.Equal ==> eq) f2 ->\n  (forall x, f1 x = f2 x) ->\n  SS.Equal s1 s2 ->\n  eqop (exists_witness f1 s1) (exists_witness f2 s2).
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).

*****
AR : Arity
*****
forall (f1 f2 : forall _ : SS.elt, bool) (s1 s2 : SS.t) (_ : Proper (respectful S.Equal eq) f1) (_ : Proper (respectful S.Equal eq) f2) (_ : forall x : SS.elt, eq (f1 x) (f2 x)) (_ : SS.Equal s1 s2), eqop (exists_witness f1 s1) (exists_witness f2 s2)
+++++
Proof.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.

*****
AR : Arity
*****
forall (f1 f2 : forall _ : SS.elt, bool) (s1 s2 : SS.t) (_ : Proper (respectful S.Equal eq) f1) (_ : Proper (respectful S.Equal eq) f2) (_ : forall x : SS.elt, eq (f1 x) (f2 x)) (_ : SS.Equal s1 s2), eqop (exists_witness f1 s1) (exists_witness f2 s2)
+++++
intros f1 f2 s1 s2.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.

*****
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall (_ : Proper (respectful S.Equal eq) f1) (_ : Proper (respectful S.Equal eq) f2) (_ : forall x : SS.elt, eq (f1 x) (f2 x)) (_ : SS.Equal s1 s2), eqop (exists_witness f1 s1) (exists_witness f2 s2)
+++++
intros H1 H2 H3 H4.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
eqop (exists_witness f1 s1) (exists_witness f2 s2)
+++++
unfold eqop.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
match exists_witness f1 s1 with | Some _ => match exists_witness f2 s2 with | Some _ => True | None => False end | None => match exists_witness f2 s2 with | Some _ => False | None => True end end
+++++
unfold exists_witness in *.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
match SS.choose (SS.filter f1 s1) with | Some _ => match SS.choose (SS.filter f2 s2) with | Some _ => True | None => False end | None => match SS.choose (SS.filter f2 s2) with | Some _ => False | None => True end end
+++++
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
+++++
apply SSWEqP.MP.Dec.F.filter_ext.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
apply SSWEqP.MP.Dec.F.filter_ext.

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
Proper (respectful S.Equal eq) f1
+++++
assumption.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
apply SSWEqP.MP.Dec.F.filter_ext.

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall x : S.t, eq (f1 x) (f2 x)
+++++
assumption.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
apply SSWEqP.MP.Dec.F.filter_ext.

*****
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
SS.Equal s1 s2
+++++
assumption.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
match SS.choose (SS.filter f1 s1) with | Some _ => match SS.choose (SS.filter f2 s2) with | Some _ => True | None => False end | None => match SS.choose (SS.filter f2 s2) with | Some _ => False | None => True end end
+++++
idtac.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
match SS.choose (SS.filter f1 s1) with | Some _ => match SS.choose (SS.filter f2 s2) with | Some _ => True | None => False end | None => match SS.choose (SS.filter f2 s2) with | Some _ => False | None => True end end
+++++
case_eq (SS.choose (SS.filter f1 s1)).
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall (e : SS.elt) (_ : eq (SS.choose (SS.filter f1 s1)) (Some e)), match SS.choose (SS.filter f2 s2) with | Some _ => True | None => False end
+++++
case_eq (SS.choose (SS.filter f2 s2)).
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall (e : SS.elt) (_ : eq (SS.choose (SS.filter f2 s2)) (Some e)) (e0 : SS.elt) (_ : eq (SS.choose (SS.filter f1 s1)) (Some e0)), True
+++++
intuition.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall (_ : eq (SS.choose (SS.filter f2 s2)) None) (e : SS.elt) (_ : eq (SS.choose (SS.filter f1 s1)) (Some e)), False
+++++
intros HCN e HCS.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.

*****
HCS : eq (SS.choose (SS.filter f1 s1)) (Some e)
e : SS\.elt
HCN : eq (SS.choose (SS.filter f2 s2)) None
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
apply SS.choose_spec1 in HCS.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.
apply SS.choose_spec1 in HCS.

*****
HCS : SS.In e (SS.filter f1 s1)
e : SS\.elt
HCN : eq (SS.choose (SS.filter f2 s2)) None
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
apply SS.choose_spec2 in HCN.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.

*****
HCS : SS.In e (SS.filter f1 s1)
e : SS\.elt
HCN : SS.Empty (SS.filter f2 s2)
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
rewrite H in HCS.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCS.

*****
HCS : SS.In e (SS.filter f2 s2)
e : SS\.elt
HCN : SS.Empty (SS.filter f2 s2)
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
apply SSWEqP.MP.empty_is_empty_1 in HCN.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCS.
apply SSWEqP.MP.empty_is_empty_1 in HCN.

*****
HCS : SS.In e (SS.filter f2 s2)
e : SS\.elt
HCN : SS.Equal (SS.filter f2 s2) SS.empty
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
rewrite HCN in HCS.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCS.
apply SSWEqP.MP.empty_is_empty_1 in HCN.
rewrite HCN in HCS.

*****
HCS : SS.In e SS.empty
e : SS\.elt
HCN : SS.Equal (SS.filter f2 s2) SS.empty
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
rewrite <- SSWEqP.MP.Dec.F.empty_iff.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros HCN e HCS.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCS.
apply SSWEqP.MP.empty_is_empty_1 in HCN.
rewrite HCN in HCS.
rewrite <- SSWEqP.MP.Dec.F.empty_iff.

*****
HCS : SS.In e SS.empty
e : SS\.elt
HCN : SS.Equal (SS.filter f2 s2) SS.empty
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
SS.In ?Goal1 SS.empty
+++++
eassumption.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall _ : eq (SS.choose (SS.filter f1 s1)) None, match SS.choose (SS.filter f2 s2) with | Some _ => False | None => True end
+++++
case_eq (SS.choose (SS.filter f2 s2)).
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall (e : SS.elt) (_ : eq (SS.choose (SS.filter f2 s2)) (Some e)) (_ : eq (SS.choose (SS.filter f1 s1)) None), False
+++++
intros e HCS HCN.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.

*****
HCN : eq (SS.choose (SS.filter f1 s1)) None
HCS : eq (SS.choose (SS.filter f2 s2)) (Some e)
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
apply SS.choose_spec1 in HCS.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.
apply SS.choose_spec1 in HCS.

*****
HCN : eq (SS.choose (SS.filter f1 s1)) None
HCS : SS.In e (SS.filter f2 s2)
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
apply SS.choose_spec2 in HCN.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.

*****
HCN : SS.Empty (SS.filter f1 s1)
HCS : SS.In e (SS.filter f2 s2)
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
rewrite H in HCN.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCN.

*****
HCN : SS.Empty (SS.filter f2 s2)
HCS : SS.In e (SS.filter f2 s2)
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
apply SSWEqP.MP.empty_is_empty_1 in HCN.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCN.
apply SSWEqP.MP.empty_is_empty_1 in HCN.

*****
HCN : SS.Equal (SS.filter f2 s2) SS.empty
HCS : SS.In e (SS.filter f2 s2)
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
rewrite HCN in HCS.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCN.
apply SSWEqP.MP.empty_is_empty_1 in HCN.
rewrite HCN in HCS.

*****
HCN : SS.Equal (SS.filter f2 s2) SS.empty
HCS : SS.In e SS.empty
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
False
+++++
rewrite <- SSWEqP.MP.Dec.F.empty_iff.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).
intros e HCS HCN.
apply SS.choose_spec1 in HCS.
apply SS.choose_spec2 in HCN.
rewrite H in HCN.
apply SSWEqP.MP.empty_is_empty_1 in HCN.
rewrite HCN in HCS.
rewrite <- SSWEqP.MP.Dec.F.empty_iff.

*****
HCN : SS.Equal (SS.filter f2 s2) SS.empty
HCS : SS.In e SS.empty
e : SS\.elt
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
SS.In ?Goal1 SS.empty
+++++
eassumption.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).
idtac.
case_eq (SS.choose (SS.filter f1 s1)).
case_eq (SS.choose (SS.filter f2 s2)).

*****
H : SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)
H4 : SS.Equal s1 s2
H3 : forall x : SS.elt, eq (f1 x) (f2 x)
H2 : Proper (respectful S.Equal eq) f2
H1 : Proper (respectful S.Equal eq) f1
s1,s2 : SS\.t
f1,f2 : forall _ : SS.elt, bool
AR : Arity
*****
forall (_ : eq (SS.choose (SS.filter f2 s2)) None) (_ : eq (SS.choose (SS.filter f1 s1)) None), True
+++++
intuition.
-----
Lemma proper_2 : forall (f1 f2 : SS.elt -> bool) (s1 s2 : SS.t), Proper (S.Equal ==> eq) f1 -> Proper (S.Equal ==> eq) f2 -> (forall x, f1 x = f2 x) -> SS.Equal s1 s2 -> eqop (exists_witness f1 s1) (exists_witness f2 s2).
Proof.
intros f1 f2 s1 s2.
intros H1 H2 H3 H4.
unfold eqop.
unfold exists_witness in *.
assert (SS.Equal (SS.filter f1 s1) (SS.filter f2 s2)).

*****

*****

+++++
Qed.
-----
Definition eqopp (p1 p2 : option (SS.elt * SS.elt)) :=\n  match p1,p2 with\n    | None, None => True\n    | Some s1, Some s2 => True\n    | _, _ => False\n  end.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.

*****
AR : Arity
*****
Proper (respectful S.Equal (respectful SS.Equal (respectful eq eqopp))) pick_varieties_aux
+++++
Proof.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.

*****
AR : Arity
*****
Proper (respectful S.Equal (respectful SS.Equal (respectful eq eqopp))) pick_varieties_aux
+++++
intros x1 y1 HXY1.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.

*****
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
respectful SS.Equal (respectful eq eqopp) (pick_varieties_aux x1) (pick_varieties_aux y1)
+++++
intros x2 y2 HXY2.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.

*****
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
respectful eq eqopp (pick_varieties_aux x1 x2) (pick_varieties_aux y1 y2)
+++++
intros x3 y3 HXY3.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqopp (pick_varieties_aux x1 x2 x3) (pick_varieties_aux y1 y2 y3)
+++++
unfold pick_varieties_aux.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqopp match exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) x3) x2 with | Some s2 => Some (pair x1 s2) | None => None end match exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2 with | Some s2 => Some (pair y1 s2) | None => None end
+++++
rewrite HXY3.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqopp match exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2 with | Some s2 => Some (pair x1 s2) | None => None end match exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2 with | Some s2 => Some (pair y1 s2) | None => None end
+++++
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)
+++++
apply proper_2.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)
+++++
apply proper_1.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)
+++++
apply proper_1.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall x : SS.elt, eq (pick_variety (S.inter x1 x) y3) (pick_variety (S.inter y1 x) y3)
+++++
intro.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.
intro.

*****
x : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq (pick_variety (S.inter x1 x) y3) (pick_variety (S.inter y1 x) y3)
+++++
apply proper_0.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.
intro.
apply proper_0.

*****
x : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
S.Equal (S.inter x1 x) (S.inter y1 x)
+++++
try reflexivity.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.
intro.
apply proper_0.
try reflexivity.

*****
x : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
S.Equal (S.inter x1 x) (S.inter y1 x)
+++++
apply SWP.inter_equal_1.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.
intro.
apply proper_0.
try reflexivity.
apply SWP.inter_equal_1.

*****
x : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
S.Equal x1 y1
+++++
assumption.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.
intro.
apply proper_0.

*****
x : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eq y3 y3
+++++
try reflexivity.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
apply proper_2.

*****
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
SS.Equal x2 y2
+++++
assumption.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqopp match exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2 with | Some s2 => Some (pair x1 s2) | None => None end match exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2 with | Some s2 => Some (pair y1 s2) | None => None end
+++++
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) (Some e)), eqopp match exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2 with | Some s2 => Some (pair x1 s2) | None => None end (Some (pair y1 e))
+++++
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (Some e)) (e0 : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) (Some e0)), eqopp (Some (pair x1 e)) (Some (pair y1 e0))
+++++
simpl.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
simpl.

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (Some e)) (e0 : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) (Some e0)), True
+++++
intuition.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) None) (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) (Some e)), eqopp None (Some (pair y1 e))
+++++
intros HCN e HCS.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros HCN e HCS.

*****
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) (Some e)
e : SS\.elt
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) None
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqopp None (Some (pair y1 e))
+++++
simpl in *.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros HCN e HCS.
simpl in *.

*****
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) (Some e)
e : SS\.elt
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) None
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
rewrite HCS in H.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros HCN e HCS.
simpl in *.
rewrite HCS in H.

*****
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) (Some e)
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) None
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) (Some e)
e : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
rewrite HCN in H.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros HCN e HCS.
simpl in *.
rewrite HCS in H.
rewrite HCN in H.

*****
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) (Some e)
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) None
H : eqop None (Some e)
e : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
simpl in *.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros HCN e HCS.
simpl in *.
rewrite HCS in H.
rewrite HCN in H.
simpl in *.

*****
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) (Some e)
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) None
H : False
e : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
intuition.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall _ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) None, eqopp match exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2 with | Some s2 => Some (pair x1 s2) | None => None end None
+++++
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (Some e)) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) None), eqopp (Some (pair x1 e)) None
+++++
intros e HCS HCN.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros e HCS HCN.

*****
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) None
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) (Some e)
e : SS\.elt
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
eqopp (Some (pair x1 e)) None
+++++
simpl in *.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros e HCS HCN.
simpl in *.

*****
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) None
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) (Some e)
e : SS\.elt
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
rewrite HCS in H.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros e HCS HCN.
simpl in *.
rewrite HCS in H.

*****
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) None
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) (Some e)
H : eqop (Some e)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
e : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
rewrite HCN in H.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros e HCS HCN.
simpl in *.
rewrite HCS in H.
rewrite HCN in H.

*****
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) None
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) (Some e)
H : eqop (Some e) None
e : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
simpl in *.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).
intros e HCS HCN.
simpl in *.
rewrite HCS in H.
rewrite HCN in H.
simpl in *.

*****
HCN : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2) None
HCS : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2) (Some e)
H : False
e : SS\.elt
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
False
+++++
intuition.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2).
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2).

*****
H : eqop\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3)\n x2)\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3)\n y2)
HXY3 : eq x3 y3
x3,y3 : STt
HXY2 : SS.Equal x2 y2
x2,y2 : SS\.t
HXY1 : S.Equal x1 y1
x1,y1 : S\.t
AR : Arity
*****
forall (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) None) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2) None), eqopp None None
+++++
intuition.
-----
Lemma proper_3 : Proper (S.Equal ==> SS.Equal ==> eq ==> eqopp) pick_varieties_aux.
Proof.
intros x1 y1 HXY1.
intros x2 y2 HXY2.
intros x3 y3 HXY3.
unfold pick_varieties_aux.
rewrite HXY3.
assert (eqop (exists_witness (fun s2 : SS.elt => pick_variety (S.inter x1 s2) y3) x2) (exists_witness (fun s2 : SS.elt => pick_variety (S.inter y1 s2) y3) y2)).

*****

*****

+++++
Qed.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st,\n  pick_varieties ss st = Some(s1,s2) ->\n  SS.In s1 ss.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.

*****
AR : Arity
*****
forall (s1 s2 : SS.elt) (ss : SS.t) (st : STt) (_ : eq (pick_varieties ss st) (Some (pair s1 s2))), SS.In s1 ss
+++++
Proof.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.

*****
AR : Arity
*****
forall (s1 s2 : SS.elt) (ss : SS.t) (st : STt) (_ : eq (pick_varieties ss st) (Some (pair s1 s2))), SS.In s1 ss
+++++
intros s1 s2 ss st H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.

*****
H : eq (pick_varieties ss st) (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
unfold pick_varieties in H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.

*****
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) (Some e)), SS.In s1 ss
+++++
intros e1 HEW1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
e1 : SS\.elt
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
rewrite HEW1 in H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (pick_varieties_aux e1 (SS.remove e1 ss) st) (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
unfold pick_varieties_aux in H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) (Some e)), SS.In s1 ss
+++++
intros e2 HEW2.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
e2 : SS\.elt
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
rewrite HEW2 in H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
assert (HEq1 : e1 = s1).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e1 s1
+++++
injection H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
injection H.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (_ : eq e2 s2) (_ : eq e1 s1), eq e1 s1
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
injection H.
intros.

*****
H1 : eq e1 s1
H0 : eq e2 s2
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e1 s1
+++++
assumption.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
idtac.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
rewrite HEq1 in *.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
assert (HEq2 : e2 = s2).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e2 s2
+++++
injection H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
injection H.

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq e2 s2, eq e2 s2
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
injection H.
intros.

*****
H0 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e2 s2
+++++
assumption.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
idtac.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
rewrite HEq2 in *.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end)
+++++
intros x y HXY.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq match pick_varieties_aux x (SS.remove x ss) st with | Some _ => true | None => false end match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.Equal (SS.remove x ss) (SS.remove y ss)
+++++
apply SSWP.Dec.F.remove_m.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
apply SSWP.Dec.F.remove_m.

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
S.Equal x y
+++++
try assumption.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
apply SSWP.Dec.F.remove_m.

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.Equal ss ss
+++++
try assumption.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
apply SSWP.Dec.F.remove_m.
try assumption.

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.Equal ss ss
+++++
reflexivity.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).

*****
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq match pick_varieties_aux x (SS.remove x ss) st with | Some _ => true | None => false end match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
idtac.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.

*****
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq match pick_varieties_aux x (SS.remove x ss) st with | Some _ => true | None => false end match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).

*****
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)
+++++
apply proper_3.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
apply proper_3.

*****
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
S.Equal x y
+++++
auto.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
apply proper_3.

*****
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.Equal (SS.remove x ss) (SS.remove y ss)
+++++
auto.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
apply proper_3.

*****
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq st st
+++++
auto.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).

*****
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq match pick_varieties_aux x (SS.remove x ss) st with | Some _ => true | None => false end match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
idtac.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.

*****
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq match pick_varieties_aux x (SS.remove x ss) st with | Some _ => true | None => false end match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
case_eq (pick_varieties_aux x (SS.remove x ss) st).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).

*****
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (p : prod SS.elt SS.elt) (_ : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)), eq true match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.

*****
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
p : prod SS.elt SS.elt
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
case_eq (pick_varieties_aux y (SS.remove y ss) st).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).

*****
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
p : prod SS.elt SS.elt
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (p : prod SS.elt SS.elt) (_ : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)), eq true true
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p0)
p0 : prod SS.elt SS.elt
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
p : prod SS.elt SS.elt
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true true
+++++
reflexivity.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).

*****
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
p : prod SS.elt SS.elt
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (pick_varieties_aux y (SS.remove y ss) st) None, eq true false
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) None
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
p : prod SS.elt SS.elt
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true false
+++++
rewrite H2 in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) None
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
H1 : eqopp (Some p) (pick_varieties_aux y (SS.remove y ss) st)
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true false
+++++
rewrite H3 in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.
rewrite H3 in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) None
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
H1 : eqopp (Some p) None
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true false
+++++
unfold eqop in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.
rewrite H3 in H1.
unfold eqop in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) None
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
H1 : eqopp (Some p) None
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true false
+++++
simpl in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.
rewrite H3 in H1.
unfold eqop in H1.
simpl in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) None
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) (Some p)
H1 : False
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq true false
+++++
intuition.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).

*****
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (pick_varieties_aux x (SS.remove x ss) st) None, eq false match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.

*****
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false match pick_varieties_aux y (SS.remove y ss) st with | Some _ => true | None => false end
+++++
case_eq (pick_varieties_aux y (SS.remove y ss) st).
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).

*****
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (p : prod SS.elt SS.elt) (_ : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)), eq false true
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)
p : prod SS.elt SS.elt
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false true
+++++
rewrite H2 in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)
p : prod SS.elt SS.elt
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp None (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false true
+++++
rewrite H3 in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.
rewrite H3 in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp None (Some p)
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false true
+++++
unfold eqop in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.
rewrite H3 in H1.
unfold eqop in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp None (Some p)
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false true
+++++
simpl in H1.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.
rewrite H2 in H1.
rewrite H3 in H1.
unfold eqop in H1.
simpl in H1.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) (Some p)
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : False
p : prod SS.elt SS.elt
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false true
+++++
intuition.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).

*****
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (pick_varieties_aux y (SS.remove y ss) st) None, eq false false
+++++
intros.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).
intros x y HXY.
assert (SS.Equal (SS.remove x ss) (SS.remove y ss)).
idtac.
assert (eqopp (pick_varieties_aux x (SS.remove x ss) st) (pick_varieties_aux y (SS.remove y ss) st)).
idtac.
case_eq (pick_varieties_aux x (SS.remove x ss) st).
intros.
case_eq (pick_varieties_aux y (SS.remove y ss) st).
intros.

*****
H3 : eq (pick_varieties_aux y (SS.remove y ss) st) None
H2 : eq (pick_varieties_aux x (SS.remove x ss) st) None
H1 : eqopp (pick_varieties_aux x (SS.remove x ss) st)\n (pick_varieties_aux y (SS.remove y ss) st)
H0 : SS.Equal (SS.remove x ss) (SS.remove y ss)
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq false false
+++++
reflexivity.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end).

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) (Some s1)
+++++
assumption.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) None, SS.In s1 ss
+++++
intro HEW2.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intro HEW2.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) None
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
rewrite HEW2 in H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intro HEW2.
rewrite HEW2 in H.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) None
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq None (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
discriminate.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) None, SS.In s1 ss
+++++
intro HEW.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intro HEW.

*****
HEW : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) None
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
rewrite HEW in H.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intro HEW.
rewrite HEW in H.

*****
HEW : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) None
H : eq None (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s1 ss
+++++
discriminate.
-----
Lemma pick_varieties_ok_1 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s1 ss.
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****

*****

+++++
Qed.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st,\n  pick_varieties ss st = Some(s1,s2) ->\n  SS.In s2 (SS.remove s1 ss).
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).

*****
AR : Arity
*****
forall (s1 s2 : SS.elt) (ss : SS.t) (st : STt) (_ : eq (pick_varieties ss st) (Some (pair s1 s2))), SS.In s2 (SS.remove s1 ss)
+++++
Proof.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.

*****
AR : Arity
*****
forall (s1 s2 : SS.elt) (ss : SS.t) (st : STt) (_ : eq (pick_varieties ss st) (Some (pair s1 s2))), SS.In s2 (SS.remove s1 ss)
+++++
intros s1 s2 ss st H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.

*****
H : eq (pick_varieties ss st) (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
unfold pick_varieties in H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.

*****
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) (Some e)), SS.In s2 (SS.remove s1 ss)
+++++
intros e1 HEW1.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
e1 : SS\.elt
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
rewrite HEW1 in H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (pick_varieties_aux e1 (SS.remove e1 ss) st) (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
unfold pick_varieties_aux in H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) (Some e)), SS.In s2 (SS.remove s1 ss)
+++++
intros e2 HEW2.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
e2 : SS\.elt
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
rewrite HEW2 in H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
assert (HEq1 : e1 = s1).
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e1 s1
+++++
injection H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
injection H.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall (_ : eq e2 s2) (_ : eq e1 s1), eq e1 s1
+++++
intros.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
injection H.
intros.

*****
H1 : eq e1 s1
H0 : eq e2 s2
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e1 s1
+++++
assumption.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
idtac.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq (Some (pair e1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
rewrite HEq1 in *.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
assert (HEq2 : e2 = s2).
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e2 s2
+++++
injection H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
injection H.

*****
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq e2 s2, eq e2 s2
+++++
intros.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
injection H.
intros.

*****
H0 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq e2 s2
+++++
assumption.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
idtac.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some e2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 e2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
rewrite HEq2 in *.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)
+++++
intros x y HXY.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
intros x y HXY.

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq (pick_variety (S.inter s1 x) st) (pick_variety (S.inter s1 y) st)
+++++
apply proper_1.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).
intros x y HXY.
apply proper_1.

*****
HXY : S.Equal x y
x,y : S\.t
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
S.Equal x y
+++++
assumption.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intros e2 HEW2.
rewrite HEW2 in H.
assert (HEq1 : e1 = s1).
idtac.
rewrite HEq1 in *.
assert (HEq2 : e2 = s2).
idtac.
rewrite HEq2 in *.
apply exists_witness_ok with (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st).

*****
HEq2 : eq e2 s2
HEq1 : eq e1 s1
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some s1)
H : eq (Some (pair s1 s2)) (Some (pair s1 s2))
e1,e2 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st) (SS.remove s1 ss)) (Some s2)
+++++
assumption.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).

*****
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) None, SS.In s2 (SS.remove s1 ss)
+++++
intro HEW2.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intro HEW2.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) None
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
rewrite HEW2 in H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intros e1 HEW1.
rewrite HEW1 in H.
unfold pick_varieties_aux in H.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
intro HEW2.
rewrite HEW2 in H.

*****
HEW2 : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) None
HEW1 : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
H : eq None (Some (pair s1 s2))
e1 : SS\.elt
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
discriminate.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
forall _ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) None, SS.In s2 (SS.remove s1 ss)
+++++
intro HEW.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intro HEW.

*****
HEW : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) None
H : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
rewrite HEW in H.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
intro HEW.
rewrite HEW in H.

*****
HEW : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) None
H : eq None (Some (pair s1 s2))
st : STt
ss : SS\.t
s1,s2 : SS\.elt
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
discriminate.
-----
Lemma pick_varieties_ok_2 : forall s1 s2 ss st, pick_varieties ss st = Some(s1,s2) -> SS.In s2 (SS.remove s1 ss).
Proof.
intros s1 s2 ss st H.
unfold pick_varieties in H.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****

*****

+++++
Qed.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss}\n                                 : SS.t :=\n  let varieties := pick_varieties ss st in\n    match varieties with\n      |None => ss\n      |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in\n                       let auxset := S.union s1 s2 in\n                       let newss := SS.add auxset auxsetofsets in\n                         identify_varieties newss st\n    end.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.

*****
AR : Arity
*****
forall (ss : SS.t) (st : STt) (p : prod SS.elt SS.elt) (s1 s2 : SS.elt) (_ : eq p (pair s1 s2)) (_ : eq (pick_varieties ss st) (Some (pair s1 s2))), lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
Proof.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.

*****
AR : Arity
*****
forall (ss : SS.t) (st : STt) (p : prod SS.elt SS.elt) (s1 s2 : SS.elt) (_ : eq p (pair s1 s2)) (_ : eq (pick_varieties ss st) (Some (pair s1 s2))), lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
intros.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.

*****
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).

*****
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
+++++
apply SSWP.remove_cardinal_1.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
apply SSWP.remove_cardinal_1.

*****
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
SS.In s1 ss
+++++
apply pick_varieties_ok_1 with s2 st.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
apply SSWP.remove_cardinal_1.
apply pick_varieties_ok_1 with s2 st.

*****
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (pick_varieties ss st) (Some (pair s1 s2))
+++++
assumption.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).

*****
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).

*****
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))) (S (SS.cardinal (SS.remove s1 ss)))
+++++
apply eq_S.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
apply eq_S.

*****
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal (SS.remove s1 ss))
+++++
apply SSWP.remove_cardinal_1.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
apply eq_S.
apply SSWP.remove_cardinal_1.

*****
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
SS.In s2 (SS.remove s1 ss)
+++++
apply pick_varieties_ok_2 with st.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
apply eq_S.
apply SSWP.remove_cardinal_1.
apply pick_varieties_ok_2 with st.

*****
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (pick_varieties ss st) (Some (pair s1 s2))
+++++
assumption.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).

*****
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).

*****
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))) (SS.cardinal ss)
+++++
transitivity (S(SS.cardinal (SS.remove s1 ss))).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
transitivity (S(SS.cardinal (SS.remove s1 ss))).

*****
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))) (S (SS.cardinal (SS.remove s1 ss)))
+++++
assumption.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
transitivity (S(SS.cardinal (SS.remove s1 ss))).

*****
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
+++++
assumption.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).

*****
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).

*****
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
forall _ : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)), lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
intro HDec.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.

*****
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).

*****
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))
+++++
apply SSWP.add_cardinal_1.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).
apply SSWP.add_cardinal_1.

*****
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
+++++
assumption.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
rewrite HR2.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).
rewrite HR2.

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.remove s2 (SS.remove s1 ss))) (SS.cardinal ss)
+++++
rewrite <- HR1.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).
rewrite HR2.
rewrite <- HR1.

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.remove s2 (SS.remove s1 ss))) (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))
+++++
apply le_S.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = SS.cardinal (SS.remove s2 (SS.remove s1 ss))).
rewrite HR2.
rewrite <- HR1.
apply le_S.

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))
HDec : SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
le (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))
+++++
apply le_n.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).

*****
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
forall _ : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))), lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
intro HDec.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.

*****
HDec : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).

*****
HDec : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
eq (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))
+++++
apply SSWP.add_cardinal_2.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).
apply SSWP.add_cardinal_2.

*****
HDec : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
+++++
assumption.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))
HDec : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
rewrite HR2.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).
rewrite HR2.

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))
HDec : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) (SS.cardinal ss)
+++++
rewrite <- HR1.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).
assert (S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = S(SS.cardinal (SS.remove s1 ss))).
assert (HR1 : S(S(SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) = SS.cardinal ss).
elim (SSWP.In_dec (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))).
intro HDec.
assert (HR2 : SS.cardinal (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))) = S( SS.cardinal (SS.remove s2 (SS.remove s1 ss)))).
rewrite HR2.
rewrite <- HR1.

*****
HR2 : eq\n (SS.cardinal\n (SS.add (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss))))\n (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss))))
HDec : not (SS.In (S.union s1 s2) (SS.remove s2 (SS.remove s1 ss)))
HR1 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (SS.cardinal ss)
H0 : eq (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))\n (S (SS.cardinal (SS.remove s1 ss)))
H : eq (S (SS.cardinal (SS.remove s1 ss))) (SS.cardinal ss)
teq : eq (pick_varieties ss st) (Some (pair s1 s2))
teq0 : eq p (pair s1 s2)
s1,s2 : SS\.elt
p : prod SS.elt SS.elt
st : STt
ss : SS\.t
AR : Arity
*****
lt (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))) (S (S (SS.cardinal (SS.remove s2 (SS.remove s1 ss)))))
+++++
apply le_n.
-----
Function identify_varieties (ss : SS.t) (st : STt) {measure SS.cardinal ss} : SS.t := let varieties := pick_varieties ss st in match varieties with |None => ss |Some (s1,s2) => let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in identify_varieties newss st end.
Proof.
intros.
assert (S(SS.cardinal (SS.remove s1 ss)) = SS.cardinal ss).

*****

*****

+++++
Defined.
-----
Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.
-----
Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.

*****
s : SS\.elt
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
bool
+++++
Proof.
-----
Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.
Proof.

*****
s : SS\.elt
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
bool
+++++
induction m.
-----
Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.
Proof.
induction m.

*****
s : SS\.elt
cp : cartesianPower positive (S (S O))
AR : Arity
*****
bool
+++++
exact (S.mem (fst cp) s && S.mem (snd cp) s).
-----
Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.
Proof.
induction m.

*****
IHm : forall _ : cartesianPower positive (S (S m)), bool
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
bool
+++++
exact (S.mem (fst cp) s && (IHm (snd cp))).
-----
Definition memCPAux m (cp : cartesianPower positive (S (S m))) (s : SS.elt) : bool.
Proof.
induction m.

*****

*****

+++++
Defined.
-----
Lemma memCPAuxHdTl : forall m cp s,\n  memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt), eq (memCPAux (S m) cp s) (andb (S.mem (fst cp) s) (memCPAux m (tailCP cp) s))
+++++
Proof.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt), eq (memCPAux (S m) cp s) (andb (S.mem (fst cp) s) (memCPAux m (tailCP cp) s))
+++++
induction m.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S O)))) (s : SS.elt), eq (memCPAux (S O) cp s) (andb (S.mem (fst cp) s) (memCPAux O (tailCP cp) s))
+++++
unfold memCPAux.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.
unfold memCPAux.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S O)))) (s : SS.elt), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp0 : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp0) s) (IHm (snd cp0))) (S O) cp) (andb (S.mem (fst cp) s) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp0 : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp0) s) (IHm (snd cp0))) O (tailCP cp)))
+++++
unfold nat_rect.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.
unfold memCPAux.
unfold nat_rect.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S O)))) (s : SS.elt), eq (andb (S.mem (fst cp) s) (andb (S.mem (fst (snd cp)) s) (S.mem (snd (snd cp)) s))) (andb (S.mem (fst cp) s) (andb (S.mem (fst (tailCP cp)) s) (S.mem (snd (tailCP cp)) s)))
+++++
reflexivity.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt),\neq (memCPAux (S m) cp s)\n (andb (S.mem (fst cp) s) (memCPAux m (tailCP cp) s))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S (S m))))) (s : SS.elt), eq (memCPAux (S (S m)) cp s) (andb (S.mem (fst cp) s) (memCPAux (S m) (tailCP cp) s))
+++++
unfold memCPAux.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.
unfold memCPAux.

*****
IHm : forall (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt),\neq (memCPAux (S m) cp s)\n (andb (S.mem (fst cp) s) (memCPAux m (tailCP cp) s))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S (S m))))) (s : SS.elt), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp0 : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp0) s) (IHm (snd cp0))) (S (S m)) cp) (andb (S.mem (fst cp) s) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp0 : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp0) s) (IHm (snd cp0))) (S m) (tailCP cp)))
+++++
unfold nat_rect.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.
unfold memCPAux.
unfold nat_rect.

*****
IHm : forall (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt),\neq (memCPAux (S m) cp s)\n (andb (S.mem (fst cp) s) (memCPAux m (tailCP cp) s))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S (S m))))) (s : SS.elt), eq (andb (S.mem (fst cp) s) (andb (S.mem (fst (snd cp)) s) ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), bool := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), bool) with | O => fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => andb (S.mem (fst cp0) s) (F n0 (snd cp0)) end) m (snd (snd cp))))) (andb (S.mem (fst cp) s) (andb (S.mem (fst (tailCP cp)) s) ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), bool := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), bool) with | O => fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => andb (S.mem (fst cp0) s) (F n0 (snd cp0)) end) m (snd (tailCP cp)))))
+++++
reflexivity.
-----
Lemma memCPAuxHdTl : forall m cp s, memCPAux (S m) cp s = S.mem (fst cp) s && memCPAux m (tailCP cp) s.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).

*****
AR : Arity
*****
forall m : nat, Proper (respectful eq (respectful S.Equal eq)) (memCPAux m)
+++++
Proof.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.

*****
AR : Arity
*****
forall m : nat, Proper (respectful eq (respectful S.Equal eq)) (memCPAux m)
+++++
intros m cp1 cp2 Hcp s1 s2 Hs.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
Hcp : eq cp1 cp2
cp1,cp2 : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (memCPAux m cp1 s1) (memCPAux m cp2 s2)
+++++
rewrite Hcp.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
Hcp : eq cp1 cp2
cp1,cp2 : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (memCPAux m cp2 s1) (memCPAux m cp2 s2)
+++++
clear Hcp.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp1,cp2 : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (memCPAux m cp2 s1) (memCPAux m cp2 s2)
+++++
clear cp1.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp2 : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (memCPAux m cp2 s1) (memCPAux m cp2 s2)
+++++
rename cp2 into cp.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (memCPAux m cp s1) (memCPAux m cp s2)
+++++
unfold memCPAux.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) m cp) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m cp)
+++++
assert (H : forall p, S.mem p s1 = S.mem p s2).
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).

*****
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
+++++
intro p.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
intro p.

*****
p : S\.elt
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (S.mem p s1) (S.mem p s2)
+++++
apply SWP.Dec.F.mem_m.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
intro p.
apply SWP.Dec.F.mem_m.

*****
p : S\.elt
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq p p
+++++
trivial.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
intro p.
apply SWP.Dec.F.mem_m.

*****
p : S\.elt
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
S.Equal s1 s2
+++++
trivial.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).

*****
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) m cp) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m cp)
+++++
idtac.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.

*****
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) m cp) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m cp)
+++++
induction m.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.

*****
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) O cp) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) O cp)
+++++
simpl.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.
simpl.

*****
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (andb (S.mem (fst cp) s2) (S.mem (snd cp) s2))
+++++
do 2 (rewrite H).
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.
simpl.
do 2 (rewrite H).

*****
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (andb (S.mem (fst cp) s2) (S.mem (snd cp) s2))
+++++
reflexivity.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.

*****
IHm : forall cp : cartesianPower positive (S (S m)),\neq\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s1) (S.mem (snd cp0) s1))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s1) (IHm (snd cp0))) m cp)\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s2) (S.mem (snd cp0) s2))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s2) (IHm (snd cp0))) m cp)
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) (S m) cp) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) (S m) cp)
+++++
simpl.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.
simpl.

*****
IHm : forall cp : cartesianPower positive (S (S m)),\neq\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s1) (S.mem (snd cp0) s1))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s1) (IHm (snd cp0))) m cp)\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s2) (S.mem (snd cp0) s2))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s2) (IHm (snd cp0))) m cp)
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (andb (S.mem (fst cp) s1) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) m (snd cp))) (andb (S.mem (fst cp) s2) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m (snd cp)))
+++++
rewrite H.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.
simpl.
rewrite H.

*****
IHm : forall cp : cartesianPower positive (S (S m)),\neq\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s1) (S.mem (snd cp0) s1))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s1) (IHm (snd cp0))) m cp)\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s2) (S.mem (snd cp0) s2))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s2) (IHm (snd cp0))) m cp)
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (andb (S.mem (fst cp) s2) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s1) (IHm (snd cp))) m (snd cp))) (andb (S.mem (fst cp) s2) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m (snd cp)))
+++++
rewrite IHm.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).
idtac.
induction m.
simpl.
rewrite H.
rewrite IHm.

*****
IHm : forall cp : cartesianPower positive (S (S m)),\neq\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s1) (S.mem (snd cp0) s1))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s1) (IHm (snd cp0))) m cp)\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp0 : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp0) s2) (S.mem (snd cp0) s2))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp0 : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp0) s2) (IHm (snd cp0))) m cp)
H : forall p : S.elt, eq (S.mem p s1) (S.mem p s2)
Hs : S.Equal s1 s2
s1,s2 : S\.t
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (andb (S.mem (fst cp) s2) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m (snd cp))) (andb (S.mem (fst cp) s2) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp : cartesianPower positive (S (S O)) => andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp) s2) (IHm (snd cp))) m (snd cp)))
+++++
reflexivity.
-----
Lemma memCPAuxProperOK : forall m, Proper (eq ==> S.Equal==> eq) (memCPAux m).
Proof.
intros m cp1 cp2 Hcp s1 s2 Hs.
rewrite Hcp.
clear Hcp.
clear cp1.
rename cp2 into cp.
unfold memCPAux.
assert (H : forall p, S.mem p s1 = S.mem p s2).

*****

*****

+++++
Qed.
-----
Lemma memCPAuxOK : forall m cp s e,\n  memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S m))) (s : SS.elt) (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp), eq (S.mem e s) true
+++++
Proof.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S m))) (s : SS.elt) (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp), eq (S.mem e s) true
+++++
induction m.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (s : SS.elt) (e : positive) (_ : eq (memCPAux O cp s) true) (_ : InCP e cp), eq (S.mem e s) true
+++++
unfold memCPAux.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
unfold memCPAux.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (s : SS.elt) (e : positive) (_ : eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp0 : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp0) s) (IHm (snd cp0))) O cp) true) (_ : InCP e cp), eq (S.mem e s) true
+++++
intros cp s e Hmem HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
unfold memCPAux.
intros cp s e Hmem HIn.

*****
HIn : InCP e cp
Hmem : eq\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp) s) (S.mem (snd cp) s))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp) s) (IHm (snd cp))) O cp) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (S.mem e s) true
+++++
unfold InCP in HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
unfold memCPAux.
intros cp s e Hmem HIn.
unfold InCP in HIn.

*****
HIn : In e (CPToList cp)
Hmem : eq\n (nat_rect\n (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool)\n (fun cp : cartesianPower positive (S (S O)) =>\n andb (S.mem (fst cp) s) (S.mem (snd cp) s))\n (fun (m : nat)\n (IHm : forall _ : cartesianPower positive (S (S m)), bool)\n (cp : cartesianPower positive (S (S (S m)))) =>\n andb (S.mem (fst cp) s) (IHm (snd cp))) O cp) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (S.mem e s) true
+++++
simpl in *.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
unfold memCPAux.
intros cp s e Hmem HIn.
unfold InCP in HIn.
simpl in *.

*****
HIn : or (eq (fst cp) e) (or (eq (snd cp) e) False)
Hmem : eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (S.mem e s) true
+++++
rewrite andb_true_iff in Hmem.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
unfold memCPAux.
intros cp s e Hmem HIn.
unfold InCP in HIn.
simpl in *.
rewrite andb_true_iff in Hmem.

*****
HIn : or (eq (fst cp) e) (or (eq (snd cp) e) False)
Hmem : and (eq (S.mem (fst cp) s) true) (eq (S.mem (snd cp) s) true)
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S O))
AR : Arity
*****
eq (S.mem e s) true
+++++
do 2 (elim HIn; clear HIn; intro HIn; try (subst; spliter; auto)).
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt) (e : positive) (_ : eq (memCPAux (S m) cp s) true) (_ : InCP e cp), eq (S.mem e s) true
+++++
intros cp s e Hmem HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.

*****
HIn : InCP e cp
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem e s) true
+++++
apply InCPOK in HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.

*****
HIn : or (eq e (headCP cp)) (InCP e (tailCP cp))
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem e s) true
+++++
elim HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.

*****
HIn : or (eq e (headCP cp)) (InCP e (tailCP cp))
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
forall _ : eq e (headCP cp), eq (S.mem e s) true
+++++
clear HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.

*****
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
forall _ : eq e (headCP cp), eq (S.mem e s) true
+++++
intro HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : eq e (headCP cp)
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem e s) true
+++++
subst.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
subst.

*****
Hmem : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem (headCP cp) s) true
+++++
simpl in Hmem.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
simpl in Hmem.

*****
Hmem : eq (andb (S.mem (fst cp) s) (memCPAux m (snd cp) s)) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem (headCP cp) s) true
+++++
rewrite andb_true_iff in Hmem.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
simpl in Hmem.
rewrite andb_true_iff in Hmem.

*****
Hmem : and (eq (S.mem (fst cp) s) true) (eq (memCPAux m (snd cp) s) true)
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem (headCP cp) s) true
+++++
spliter.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
subst.
simpl in Hmem.
rewrite andb_true_iff in Hmem.
spliter.

*****
H0 : eq (memCPAux m (snd cp) s) true
H : eq (S.mem (fst cp) s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem (headCP cp) s) true
+++++
auto.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.

*****
HIn : or (eq e (headCP cp)) (InCP e (tailCP cp))
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
forall _ : InCP e (tailCP cp), eq (S.mem e s) true
+++++
clear HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.

*****
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
forall _ : InCP e (tailCP cp), eq (S.mem e s) true
+++++
intro HIn.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : InCP e (tailCP cp)
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (S.mem e s) true
+++++
apply IHm with (tailCP cp).
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
apply IHm with (tailCP cp).

*****
HIn : InCP e (tailCP cp)
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
try assumption.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
apply IHm with (tailCP cp).
try assumption.

*****
HIn : InCP e (tailCP cp)
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
simpl in Hmem.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
apply IHm with (tailCP cp).
try assumption.
simpl in Hmem.

*****
HIn : InCP e (tailCP cp)
Hmem : eq (andb (S.mem (fst cp) s) (memCPAux m (snd cp) s)) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
rewrite andb_true_iff in Hmem.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
apply IHm with (tailCP cp).
try assumption.
simpl in Hmem.
rewrite andb_true_iff in Hmem.

*****
HIn : InCP e (tailCP cp)
Hmem : and (eq (S.mem (fst cp) s) true) (eq (memCPAux m (snd cp) s) true)
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
spliter.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
apply IHm with (tailCP cp).
try assumption.
simpl in Hmem.
rewrite andb_true_iff in Hmem.
spliter.

*****
HIn : InCP e (tailCP cp)
H0 : eq (memCPAux m (snd cp) s) true
H : eq (S.mem (fst cp) s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
assumption.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.
intros cp s e Hmem HIn.
apply InCPOK in HIn.
elim HIn.
clear HIn.
intro HIn.
apply IHm with (tailCP cp).

*****
HIn : InCP e (tailCP cp)
Hmem : eq (memCPAux (S m) cp s) true
e : positive
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m))) (s : SS.elt)\n (e : positive) (_ : eq (memCPAux m cp s) true) (_ : InCP e cp),\neq (S.mem e s) true
m : nat
AR : Arity
*****
InCP e (tailCP cp)
+++++
try assumption.
-----
Lemma memCPAuxOK : forall m cp s e, memCPAux m cp s = true -> InCP e cp -> S.mem e s = true.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma memMemCPAuxOK : forall m cp s,\n  (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower S.elt (S (S m))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (memCPAux m cp s) true
+++++
Proof.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower S.elt (S (S m))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (memCPAux m cp s) true
+++++
induction m.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.

*****
AR : Arity
*****
forall (cp : cartesianPower S.elt (S (S O))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (memCPAux O cp s) true
+++++
unfold memCPAux.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.

*****
AR : Arity
*****
forall (cp : cartesianPower S.elt (S (S O))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), bool) (fun cp0 : cartesianPower positive (S (S O)) => andb (S.mem (fst cp0) s) (S.mem (snd cp0) s)) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), bool) (cp0 : cartesianPower positive (S (S (S m)))) => andb (S.mem (fst cp0) s) (IHm (snd cp0))) O cp) true
+++++
simpl.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.

*****
AR : Arity
*****
forall (cp : cartesianPower S.elt (S (S O))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) true
+++++
intros cp s H.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
eq (andb (S.mem (fst cp) s) (S.mem (snd cp) s)) true
+++++
rewrite andb_true_iff.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (S.mem (snd cp) s) true)
+++++
assert (HIn1 : InCP (fst cp) cp).
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
InCP (fst cp) cp
+++++
unfold InCP.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
unfold InCP.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
In (fst cp) (CPToList cp)
+++++
simpl.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
unfold InCP.
simpl.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
or (eq (fst cp) (fst cp)) (or (eq (snd cp) (fst cp)) False)
+++++
auto.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).

*****
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (S.mem (snd cp) s) true)
+++++
idtac.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.

*****
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (S.mem (snd cp) s) true)
+++++
assert (HIn2 : InCP (snd cp) cp).
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).

*****
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
InCP (snd cp) cp
+++++
unfold InCP.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
unfold InCP.

*****
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
In (snd cp) (CPToList cp)
+++++
simpl.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
unfold InCP.
simpl.

*****
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
or (eq (fst cp) (snd cp)) (or (eq (snd cp) (snd cp)) False)
+++++
auto.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).

*****
HIn2 : InCP (snd cp) cp
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (S.mem (snd cp) s) true)
+++++
idtac.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
idtac.

*****
HIn2 : InCP (snd cp) cp
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (S.mem (snd cp) s) true)
+++++
split.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
idtac.
split.

*****
HIn2 : InCP (snd cp) cp
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
eq (S.mem (fst cp) s) true
+++++
apply H.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
idtac.
split.
apply H.

*****
HIn2 : InCP (snd cp) cp
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
InCP (fst cp) cp
+++++
assumption.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
idtac.
split.

*****
HIn2 : InCP (snd cp) cp
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
eq (S.mem (snd cp) s) true
+++++
apply H.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
unfold memCPAux.
simpl.
intros cp s H.
rewrite andb_true_iff.
assert (HIn1 : InCP (fst cp) cp).
idtac.
assert (HIn2 : InCP (snd cp) cp).
idtac.
split.
apply H.

*****
HIn2 : InCP (snd cp) cp
HIn1 : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S O))
AR : Arity
*****
InCP (snd cp) cp
+++++
assumption.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
forall (cp : cartesianPower S.elt (S (S (S m)))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (memCPAux (S m) cp s) true
+++++
intros cp s H.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (memCPAux (S m) cp s) true
+++++
rewrite memCPAuxHdTl.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (andb (S.mem (fst cp) s) (memCPAux m (tailCP cp) s)) true
+++++
rewrite andb_true_iff.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (memCPAux m (tailCP cp) s) true)
+++++
assert (HIn : InCP (fst cp) cp).
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
InCP (fst cp) cp
+++++
unfold InCP.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
unfold InCP.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
In (fst cp) (CPToList cp)
+++++
simpl.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
unfold InCP.
simpl.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
or (eq (fst cp) (fst cp)) (or (eq (fst (snd cp)) (fst cp)) (In (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower S.elt (S n), list S.elt) (fun cp : cartesianPower S.elt (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower S.elt (S n), list S.elt) (cp : cartesianPower S.elt (S (S n))) => cons (fst cp) (IHn (tailCP cp))) m (tailCP (snd cp)))))
+++++
auto.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).

*****
HIn : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (memCPAux m (tailCP cp) s) true)
+++++
idtac.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.

*****
HIn : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
and (eq (S.mem (fst cp) s) true) (eq (memCPAux m (tailCP cp) s) true)
+++++
split.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.

*****
HIn : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (S.mem (fst cp) s) true
+++++
try (apply H; assumption).
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.

*****
HIn : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
try (apply H; assumption).
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).

*****
HIn : InCP (fst cp) cp
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
clear HIn.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).
clear HIn.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
apply IHm.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).
clear HIn.
apply IHm.

*****
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
forall (e : S.elt) (_ : InCP e (tailCP cp)), eq (S.mem e s) true
+++++
intros e HIn.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).
clear HIn.
apply IHm.
intros e HIn.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
eq (S.mem e s) true
+++++
apply H.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).
clear HIn.
apply IHm.
intros e HIn.
apply H.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
InCP e cp
+++++
apply InCPOK.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).
clear HIn.
apply IHm.
intros e HIn.
apply H.
apply InCPOK.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
right.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.
intros cp s H.
rewrite memCPAuxHdTl.
rewrite andb_true_iff.
assert (HIn : InCP (fst cp) cp).
idtac.
split.
try (apply H; assumption).
clear HIn.
apply IHm.
intros e HIn.
apply H.
apply InCPOK.
right.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
H : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true
s : S\.t
cp : cartesianPower S.elt (S (S (S m)))
IHm : forall (cp : cartesianPower S.elt (S (S m))) (s : S.t)\n (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true),\neq (memCPAux m cp s) true
m : nat
AR : Arity
*****
InCP e (tailCP cp)
+++++
assumption.
-----
Lemma memMemCPAuxOK : forall m cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCPAux m cp s = true.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma memCPAuxTlOK : forall m cp s,\n  memCPAux (S m) cp s = true ->\n  memCPAux m (tailCP cp) s = true.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt) (_ : eq (memCPAux (S m) cp s) true), eq (memCPAux m (tailCP cp) s) true
+++++
Proof.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.

*****
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S (S m)))) (s : SS.elt) (_ : eq (memCPAux (S m) cp s) true), eq (memCPAux m (tailCP cp) s) true
+++++
intros m cp s Hmemcp.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.

*****
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (memCPAux m (tailCP cp) s) true
+++++
apply memMemCPAuxOK.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.

*****
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
forall (e : S.elt) (_ : InCP e (tailCP cp)), eq (S.mem e s) true
+++++
intros e HIn.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (S.mem e s) true
+++++
apply memCPAuxOK with (S m) cp.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.
apply memCPAuxOK with (S m) cp.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
eq (memCPAux (S m) cp s) true
+++++
try assumption.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.
apply memCPAuxOK with (S m) cp.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
InCP e cp
+++++
try assumption.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.
apply memCPAuxOK with (S m) cp.
try assumption.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
InCP e cp
+++++
apply InCPOK.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.
apply memCPAuxOK with (S m) cp.
try assumption.
apply InCPOK.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
right.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.
apply memCPAuxOK with (S m) cp.
try assumption.
apply InCPOK.
right.

*****
HIn : InCP e (tailCP cp)
e : S\.elt
Hmemcp : eq (memCPAux (S m) cp s) true
s : SS\.elt
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
InCP e (tailCP cp)
+++++
assumption.
-----
Lemma memCPAuxTlOK : forall m cp s, memCPAux (S m) cp s = true -> memCPAux m (tailCP cp) s = true.
Proof.
intros m cp s Hmemcp.
apply memMemCPAuxOK.
intros e HIn.
apply memCPAuxOK with (S m) cp.

*****

*****

+++++
Qed.
-----
Definition memCP (cp : cartesianPower positive (S (S (S n)))) (s : SS.elt) := memCPAux (S n) cp s.
-----
Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.
-----
Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.

*****
AR : Arity
*****
Proper (respectful eq (respectful S.Equal eq)) memCP
+++++
Proof.
-----
Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.
Proof.

*****
AR : Arity
*****
Proper (respectful eq (respectful S.Equal eq)) memCP
+++++
apply memCPAuxProperOK.
-----
Lemma memCPProper : Proper (eq ==> S.Equal==> eq) memCP.
Proof.
apply memCPAuxProperOK.

*****

*****

+++++
Qed.
-----
Lemma memMemCPOK : forall cp s,\n  (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.
-----
Lemma memMemCPOK : forall cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.

*****
AR : Arity
*****
forall (cp : cartesianPower S.elt (S (S (S n)))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (memCP cp s) true
+++++
Proof.
-----
Lemma memMemCPOK : forall cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.
Proof.

*****
AR : Arity
*****
forall (cp : cartesianPower S.elt (S (S (S n)))) (s : S.t) (_ : forall (e : S.elt) (_ : InCP e cp), eq (S.mem e s) true), eq (memCP cp s) true
+++++
apply memMemCPAuxOK.
-----
Lemma memMemCPOK : forall cp s, (forall e, InCP e cp -> S.mem e s = true) -> memCP cp s = true.
Proof.
apply memMemCPAuxOK.

*****

*****

+++++
Qed.
-----
Lemma memCPConsHd : forall p s x,\n  S.mem p s = true ->\n  memCPAux n x s = true ->\n  memCP (consHeadCP p x) s = true.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.

*****
AR : Arity
*****
forall (p : S.elt) (s : S.t) (x : cartesianPower positive (S (S n))) (_ : eq (S.mem p s) true) (_ : eq (memCPAux n x s) true), eq (memCP (consHeadCP p x) s) true
+++++
Proof.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.

*****
AR : Arity
*****
forall (p : S.elt) (s : S.t) (x : cartesianPower positive (S (S n))) (_ : eq (S.mem p s) true) (_ : eq (memCPAux n x s) true), eq (memCP (consHeadCP p x) s) true
+++++
intros p s x Hmem Hmemcp.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.

*****
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (memCP (consHeadCP p x) s) true
+++++
apply memMemCPOK.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.

*****
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
forall (e : S.elt) (_ : InCP e (consHeadCP p x)), eq (S.mem e s) true
+++++
intros e HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.

*****
HIn : InCP e (consHeadCP p x)
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (S.mem e s) true
+++++
apply InCPOK in HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.

*****
HIn : or (eq e (headCP (consHeadCP p x))) (InCP e (tailCP (consHeadCP p x)))
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (S.mem e s) true
+++++
simpl in HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.

*****
HIn : or (eq e p) (InCP e x)
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (S.mem e s) true
+++++
elim HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.

*****
HIn : or (eq e p) (InCP e x)
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
forall _ : eq e p, eq (S.mem e s) true
+++++
clear HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.

*****
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
forall _ : eq e p, eq (S.mem e s) true
+++++
intro HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : eq e p
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (S.mem e s) true
+++++
subst.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.
intro HIn.
subst.

*****
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (S.mem p s) true
+++++
assumption.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.

*****
HIn : or (eq e p) (InCP e x)
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
forall _ : InCP e x, eq (S.mem e s) true
+++++
clear HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.

*****
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
forall _ : InCP e x, eq (S.mem e s) true
+++++
intro HIn.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.
intro HIn.

*****
HIn : InCP e x
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (S.mem e s) true
+++++
apply memCPAuxOK with n x.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.
intro HIn.
apply memCPAuxOK with n x.

*****
HIn : InCP e x
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
eq (memCPAux n x s) true
+++++
assumption.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.
clear HIn.
intro HIn.
apply memCPAuxOK with n x.

*****
HIn : InCP e x
e : S\.elt
Hmemcp : eq (memCPAux n x s) true
Hmem : eq (S.mem p s) true
x : cartesianPower positive (S (S n))
s : S\.t
p : S\.elt
AR : Arity
*****
InCP e x
+++++
assumption.
-----
Lemma memCPConsHd : forall p s x, S.mem p s = true -> memCPAux n x s = true -> memCP (consHeadCP p x) s = true.
Proof.
intros p s x Hmem Hmemcp.
apply memMemCPOK.
intros e HIn.
apply InCPOK in HIn.
simpl in HIn.
elim HIn.

*****

*****

+++++
Qed.
-----
Definition test_coinc (ss : SS.t) (st : STt) (cp : cartesianPower positive (S (S (S n)))) : bool :=\n  let newss := identify_varieties ss st  in\n    SS.exists_ (fun s => memCP cp s) newss.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))),\n  pick_variety_auxCP (S.inter s1 s2) cp = true ->\n  memCPAux m cp s1 = true.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.

*****
AR : Arity
*****
forall (s1 s2 : S.t) (m : nat) (cp : cartesianPower positive (S (S m))) (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true), eq (memCPAux m cp s1) true
+++++
Proof.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.

*****
AR : Arity
*****
forall (s1 s2 : S.t) (m : nat) (cp : cartesianPower positive (S (S m))) (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true), eq (memCPAux m cp s1) true
+++++
intros s1 s2 m cp.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.

*****
cp : cartesianPower positive (S (S m))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true, eq (memCPAux m cp s1) true
+++++
induction m.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.

*****
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true, eq (memCPAux O cp s1) true
+++++
simpl.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.

*****
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (andb (S.mem (fst cp) (S.inter s1 s2)) (S.mem (snd cp) (S.inter s1 s2))) true, eq (andb (S.mem (fst cp) s1) (S.mem (snd cp) s1)) true
+++++
do 2 (rewrite andb_true_iff).
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).

*****
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
forall _ : and (eq (S.mem (fst cp) (S.inter s1 s2)) true) (eq (S.mem (snd cp) (S.inter s1 s2)) true), and (eq (S.mem (fst cp) s1) true) (eq (S.mem (snd cp) s1) true)
+++++
intro Hhtspa.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.

*****
Hhtspa : and (eq (S.mem (fst cp) (S.inter s1 s2)) true)\n (eq (S.mem (snd cp) (S.inter s1 s2)) true)
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (S.mem (snd cp) s1) true)
+++++
do 2 (rewrite SWP.FM.inter_b in Hhtspa).
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
do 2 (rewrite SWP.FM.inter_b in Hhtspa).

*****
Hhtspa : and (eq (andb (S.mem (fst cp) s1) (S.mem (fst cp) s2)) true)\n (eq (andb (S.mem (snd cp) s1) (S.mem (snd cp) s2)) true)
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (S.mem (snd cp) s1) true)
+++++
do 2 (rewrite andb_true_iff in Hhtspa).
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
do 2 (rewrite SWP.FM.inter_b in Hhtspa).
do 2 (rewrite andb_true_iff in Hhtspa).

*****
Hhtspa : and (and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true))\n (and (eq (S.mem (snd cp) s1) true) (eq (S.mem (snd cp) s2) true))
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (S.mem (snd cp) s1) true)
+++++
tauto.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true, eq (memCPAux (S m) cp s1) true
+++++
simpl.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (andb (S.mem (fst cp) (S.inter s1 s2)) (pick_variety_auxCP (S.inter s1 s2) (snd cp))) true, eq (andb (S.mem (fst cp) s1) (memCPAux m (snd cp) s1)) true
+++++
do 2 (rewrite andb_true_iff).
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : and (eq (S.mem (fst cp) (S.inter s1 s2)) true) (eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true), and (eq (S.mem (fst cp) s1) true) (eq (memCPAux m (snd cp) s1) true)
+++++
intro Hhtspa.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.

*****
Hhtspa : and (eq (S.mem (fst cp) (S.inter s1 s2)) true)\n (eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (memCPAux m (snd cp) s1) true)
+++++
destruct Hhtspa as [Hmem Hhtspa].
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : eq (S.mem (fst cp) (S.inter s1 s2)) true
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (memCPAux m (snd cp) s1) true)
+++++
rewrite SWP.FM.inter_b in Hmem.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : eq (andb (S.mem (fst cp) s1) (S.mem (fst cp) s2)) true
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (memCPAux m (snd cp) s1) true)
+++++
rewrite andb_true_iff in Hmem.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s1) true) (eq (memCPAux m (snd cp) s1) true)
+++++
split.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (S.mem (fst cp) s1) true
+++++
try (spliter; assumption).
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (memCPAux m (snd cp) s1) true
+++++
try (spliter; assumption).
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.
try (spliter; assumption).

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (memCPAux m (snd cp) s1) true
+++++
apply IHm.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.
try (spliter; assumption).
apply IHm.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s1) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
+++++
assumption.
-----
Lemma pick_variety_aux_memCPAux1 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s1 = true.
Proof.
intros s1 s2 m cp.
induction m.

*****

*****

+++++
Qed.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))),\n  pick_variety_auxCP (S.inter s1 s2) cp = true ->\n  memCPAux m cp s2 = true.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.

*****
AR : Arity
*****
forall (s1 s2 : S.t) (m : nat) (cp : cartesianPower positive (S (S m))) (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true), eq (memCPAux m cp s2) true
+++++
Proof.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.

*****
AR : Arity
*****
forall (s1 s2 : S.t) (m : nat) (cp : cartesianPower positive (S (S m))) (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true), eq (memCPAux m cp s2) true
+++++
intros s1 s2 m cp.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.

*****
cp : cartesianPower positive (S (S m))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true, eq (memCPAux m cp s2) true
+++++
induction m.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.

*****
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true, eq (memCPAux O cp s2) true
+++++
simpl.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.

*****
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (andb (S.mem (fst cp) (S.inter s1 s2)) (S.mem (snd cp) (S.inter s1 s2))) true, eq (andb (S.mem (fst cp) s2) (S.mem (snd cp) s2)) true
+++++
do 2 (rewrite andb_true_iff).
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).

*****
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
forall _ : and (eq (S.mem (fst cp) (S.inter s1 s2)) true) (eq (S.mem (snd cp) (S.inter s1 s2)) true), and (eq (S.mem (fst cp) s2) true) (eq (S.mem (snd cp) s2) true)
+++++
intro Hhtspa.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.

*****
Hhtspa : and (eq (S.mem (fst cp) (S.inter s1 s2)) true)\n (eq (S.mem (snd cp) (S.inter s1 s2)) true)
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (S.mem (snd cp) s2) true)
+++++
do 2 (rewrite SWP.FM.inter_b in Hhtspa).
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
do 2 (rewrite SWP.FM.inter_b in Hhtspa).

*****
Hhtspa : and (eq (andb (S.mem (fst cp) s1) (S.mem (fst cp) s2)) true)\n (eq (andb (S.mem (snd cp) s1) (S.mem (snd cp) s2)) true)
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (S.mem (snd cp) s2) true)
+++++
do 2 (rewrite andb_true_iff in Hhtspa).
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
do 2 (rewrite SWP.FM.inter_b in Hhtspa).
do 2 (rewrite andb_true_iff in Hhtspa).

*****
Hhtspa : and (and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true))\n (and (eq (S.mem (snd cp) s1) true) (eq (S.mem (snd cp) s2) true))
cp : cartesianPower positive (S (S O))
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (S.mem (snd cp) s2) true)
+++++
tauto.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true, eq (memCPAux (S m) cp s2) true
+++++
simpl.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : eq (andb (S.mem (fst cp) (S.inter s1 s2)) (pick_variety_auxCP (S.inter s1 s2) (snd cp))) true, eq (andb (S.mem (fst cp) s2) (memCPAux m (snd cp) s2)) true
+++++
do 2 (rewrite andb_true_iff).
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
forall _ : and (eq (S.mem (fst cp) (S.inter s1 s2)) true) (eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true), and (eq (S.mem (fst cp) s2) true) (eq (memCPAux m (snd cp) s2) true)
+++++
intro Hhtspa.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.

*****
Hhtspa : and (eq (S.mem (fst cp) (S.inter s1 s2)) true)\n (eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (memCPAux m (snd cp) s2) true)
+++++
destruct Hhtspa as [Hmem Hhtspa].
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : eq (S.mem (fst cp) (S.inter s1 s2)) true
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (memCPAux m (snd cp) s2) true)
+++++
rewrite SWP.FM.inter_b in Hmem.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : eq (andb (S.mem (fst cp) s1) (S.mem (fst cp) s2)) true
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (memCPAux m (snd cp) s2) true)
+++++
rewrite andb_true_iff in Hmem.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
and (eq (S.mem (fst cp) s2) true) (eq (memCPAux m (snd cp) s2) true)
+++++
split.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (S.mem (fst cp) s2) true
+++++
try (spliter; assumption).
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (memCPAux m (snd cp) s2) true
+++++
try (spliter; assumption).
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.
try (spliter; assumption).

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (memCPAux m (snd cp) s2) true
+++++
apply IHm.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.
simpl.
do 2 (rewrite andb_true_iff).
intro Hhtspa.
destruct Hhtspa as [Hmem Hhtspa].
rewrite SWP.FM.inter_b in Hmem.
rewrite andb_true_iff in Hmem.
split.
try (spliter; assumption).
apply IHm.

*****
Hhtspa : eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
Hmem : and (eq (S.mem (fst cp) s1) true) (eq (S.mem (fst cp) s2) true)
IHm : forall (cp : cartesianPower positive (S (S m)))\n (_ : eq (pick_variety_auxCP (S.inter s1 s2) cp) true),\neq (memCPAux m cp s2) true
cp : cartesianPower positive (S (S (S m)))
m : nat
s1,s2 : S\.t
AR : Arity
*****
eq (pick_variety_auxCP (S.inter s1 s2) (snd cp)) true
+++++
assumption.
-----
Lemma pick_variety_aux_memCPAux2 : forall s1 s2 m (cp : cartesianPower positive (S (S m))), pick_variety_auxCP (S.inter s1 s2) cp = true -> memCPAux m cp s2 = true.
Proof.
intros s1 s2 m cp.
induction m.

*****

*****

+++++
Qed.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S m)
m : nat
AR : Arity
*****
cartesianPower COINCpoint (S m)
+++++
Proof.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S m)
m : nat
AR : Arity
*****
cartesianPower COINCpoint (S m)
+++++
induction m.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S O)
AR : Arity
*****
cartesianPower COINCpoint (S O)
+++++
exact (interp cp).
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.

*****
IHm : forall _ : cartesianPower positive (S m),\ncartesianPower COINCpoint (S m)
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
cartesianPower COINCpoint (S (S m))
+++++
clear IHm.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S m))
m : nat
AR : Arity
*****
cartesianPower COINCpoint (S (S m))
+++++
induction m.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.
induction m.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S O))
AR : Arity
*****
cartesianPower COINCpoint (S (S O))
+++++
split.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.
induction m.
split.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S O))
AR : Arity
*****
COINCpoint
+++++
exact (interp (headCP cp)).
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.
induction m.
split.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S O))
AR : Arity
*****
cartesianPowerAux COINCpoint O
+++++
exact (interp (tailCP cp)).
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.
induction m.

*****
IHm : forall _ : cartesianPower positive (S (S m)),\ncartesianPower COINCpoint (S (S m))
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
cartesianPower COINCpoint (S (S (S m)))
+++++
split.
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.
induction m.
split.

*****
IHm : forall _ : cartesianPower positive (S (S m)),\ncartesianPower COINCpoint (S (S m))
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
COINCpoint
+++++
exact (interp (headCP cp)).
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.
clear IHm.
induction m.
split.

*****
IHm : forall _ : cartesianPower positive (S (S m)),\ncartesianPower COINCpoint (S (S m))
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
m : nat
AR : Arity
*****
cartesianPowerAux COINCpoint (S m)
+++++
exact (IHm (tailCP cp)).
-----
Definition interp_CP {m : nat} (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint) : cartesianPower COINCpoint (S m).
Proof.
induction m.

*****

*****

+++++
Defined.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp,\n  interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).

*****
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S m)) (interp : forall _ : positive, COINCpoint), eq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
+++++
Proof.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.

*****
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S m)) (interp : forall _ : positive, COINCpoint), eq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
+++++
induction m.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (interp : forall _ : positive, COINCpoint), eq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
+++++
unfold interp_CP.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (interp : forall _ : positive, COINCpoint), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) O (headCPbis cp)) (headCP (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) O cp))
+++++
unfold nat_rect.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.
unfold nat_rect.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (interp : forall _ : positive, COINCpoint), eq (interp (headCPbis cp)) (headCP (interp cp))
+++++
simpl.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.
unfold nat_rect.
simpl.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (interp : forall _ : positive, COINCpoint), eq (interp cp) (interp cp)
+++++
reflexivity.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
+++++
induction m.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
+++++
unfold interp_CP.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.
unfold interp_CP.

*****
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) O (headCPbis cp)) (headCP (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) (S O) cp))
+++++
unfold nat_rect.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.
unfold interp_CP.
unfold nat_rect.

*****
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (interp (headCPbis cp)) (headCP (pair (interp (headCP cp)) (interp (tailCP cp))))
+++++
simpl.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.
unfold interp_CP.
unfold nat_rect.
simpl.

*****
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (interp (fst cp)) (interp (fst cp))
+++++
reflexivity.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.

*****
IHm0 : forall\n (_ : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\n eq (interp_CP (headCPbis cp) interp)\n (headCP (interp_CP cp interp)))\n (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
+++++
unfold interp_CP.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.
unfold interp_CP.

*****
IHm0 : forall\n (_ : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\n eq (interp_CP (headCPbis cp) interp)\n (headCP (interp_CP cp interp)))\n (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) O (headCPbis cp)) (headCP (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) (S (S m)) cp))
+++++
unfold nat_rect.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.
unfold interp_CP.
unfold nat_rect.

*****
IHm0 : forall\n (_ : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\n eq (interp_CP (headCPbis cp) interp)\n (headCP (interp_CP cp interp)))\n (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq (interp (headCPbis cp)) (headCP (pair (interp (headCP cp)) ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), cartesianPower COINCpoint (S (S n)) := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), cartesianPower COINCpoint (S (S n0))) with | O => fun cp0 : cartesianPower positive (S (S O)) => pair (interp (headCP cp0)) (interp (tailCP cp0)) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => pair (interp (headCP cp0)) (F n0 (tailCP cp0)) end) m (tailCP cp))))
+++++
simpl.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.
induction m.
unfold interp_CP.
unfold nat_rect.
simpl.

*****
IHm0 : forall\n (_ : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\n eq (interp_CP (headCPbis cp) interp)\n (headCP (interp_CP cp interp)))\n (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (headCPbis cp) interp) (headCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq (interp (fst cp)) (interp (fst cp))
+++++
reflexivity.
-----
Lemma interp_CPHdOK {m : nat} : forall (cp : cartesianPower positive (S m)) interp, interp_CP (headCPbis cp) interp = headCP (interp_CP cp interp).
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp,\n  interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).

*****
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
+++++
Proof.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.

*****
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
+++++
induction m.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
+++++
unfold interp_CP.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) O (tailCP cp)) (tailCP (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) (S O) cp))
+++++
unfold nat_rect.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.
unfold nat_rect.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (interp (tailCP cp)) (tailCP (pair (interp (headCP cp)) (interp (tailCP cp))))
+++++
simpl.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.
unfold nat_rect.
simpl.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S (S O))) (interp : forall _ : positive, COINCpoint), eq (interp (snd cp)) (interp (snd cp))
+++++
reflexivity.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
+++++
unfold interp_CP.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) (S m) (tailCP cp)) (tailCP (nat_rect (fun m : nat => forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (fun cp0 : cartesianPower positive (S O) => interp cp0) (fun (m : nat) (_ : forall _ : cartesianPower positive (S m), cartesianPower COINCpoint (S m)) (cp0 : cartesianPower positive (S (S m))) => nat_rect (fun m0 : nat => forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (fun cp1 : cartesianPower positive (S (S O)) => pair (interp (headCP cp1)) (interp (tailCP cp1))) (fun (m0 : nat) (IHm0 : forall _ : cartesianPower positive (S (S m0)), cartesianPower COINCpoint (S (S m0))) (cp1 : cartesianPower positive (S (S (S m0)))) => pair (interp (headCP cp1)) (IHm0 (tailCP cp1))) m cp0) (S (S m)) cp))
+++++
unfold nat_rect.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.
unfold nat_rect.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), cartesianPower COINCpoint (S (S n)) := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), cartesianPower COINCpoint (S (S n0))) with | O => fun cp0 : cartesianPower positive (S (S O)) => pair (interp (headCP cp0)) (interp (tailCP cp0)) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => pair (interp (headCP cp0)) (F n0 (tailCP cp0)) end) m (tailCP cp)) (tailCP (pair (interp (headCP cp)) ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), cartesianPower COINCpoint (S (S n)) := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), cartesianPower COINCpoint (S (S n0))) with | O => fun cp0 : cartesianPower positive (S (S O)) => pair (interp (headCP cp0)) (interp (tailCP cp0)) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => pair (interp (headCP cp0)) (F n0 (tailCP cp0)) end) m (tailCP cp))))
+++++
simpl.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.
unfold interp_CP.
unfold nat_rect.
simpl.

*****
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (interp_CP (tailCP cp) interp) (tailCP (interp_CP cp interp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (interp : forall _ : positive, COINCpoint), eq ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), cartesianPower COINCpoint (S (S n)) := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), cartesianPower COINCpoint (S (S n0))) with | O => fun cp0 : cartesianPower positive (S (S O)) => pair (interp (fst cp0)) (interp (snd cp0)) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => pair (interp (fst cp0)) (F n0 (snd cp0)) end) m (snd cp)) ((fix F (n : nat) : forall _ : cartesianPower positive (S (S n)), cartesianPower COINCpoint (S (S n)) := match n as n0 return (forall _ : cartesianPower positive (S (S n0)), cartesianPower COINCpoint (S (S n0))) with | O => fun cp0 : cartesianPower positive (S (S O)) => pair (interp (fst cp0)) (interp (snd cp0)) | S n0 => fun cp0 : cartesianPower positive (S (S (S n0))) => pair (interp (fst cp0)) (F n0 (snd cp0)) end) m (snd cp))
+++++
reflexivity.
-----
Lemma interp_CPTlOK {m : nat} : forall (cp : cartesianPower positive (S (S m))) interp, interp_CP (tailCP cp) interp = tailCP (interp_CP cp interp).
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint),\n  CPToList (interp_CP cp interp) = map interp (CPToList cp).
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).

*****
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S m)) (interp : forall _ : positive, COINCpoint), eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
Proof.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.

*****
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S m)) (interp : forall _ : positive, COINCpoint), eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
induction m.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.

*****
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (interp : forall _ : positive, COINCpoint), eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
intros cp interp.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S O)
AR : Arity
*****
eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
simpl.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
simpl.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S O)
AR : Arity
*****
eq (cons (interp cp) nil) (cons (interp cp) nil)
+++++
reflexivity.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (interp : forall _ : positive, COINCpoint), eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
intros cp interp.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S m))
IHm : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
induction m.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S O))
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
AR : Arity
*****
eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
try (clear IHm0).
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S O))
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
AR : Arity
*****
eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
simpl.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).
simpl.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S O))
IHm : forall (cp : cartesianPower positive (S O))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
AR : Arity
*****
eq (cons (interp (fst cp)) (cons (interp (snd cp)) nil)) (cons (interp (fst cp)) (cons (interp (snd cp)) nil))
+++++
reflexivity.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.

*****
IHm0 : forall\n (_ : forall (cp : cartesianPower positive (S m))\n (interp : forall _ : positive, COINCpoint),\n eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp)))\n (cp : cartesianPower positive (S (S m))),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
try (clear IHm0).
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
+++++
rewrite CPToListOK.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).
rewrite CPToListOK.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (cons (headCP (interp_CP cp interp)) (CPToList (tailCP (interp_CP cp interp)))) (map interp (CPToList cp))
+++++
rewrite <- interp_CPHdOK.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).
rewrite CPToListOK.
rewrite <- interp_CPHdOK.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (cons (interp_CP (headCPbis cp) interp) (CPToList (tailCP (interp_CP cp interp)))) (map interp (CPToList cp))
+++++
rewrite <- interp_CPTlOK.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).
rewrite CPToListOK.
rewrite <- interp_CPHdOK.
rewrite <- interp_CPTlOK.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (cons (interp_CP (headCPbis cp) interp) (CPToList (interp_CP (tailCP cp) interp))) (map interp (CPToList cp))
+++++
rewrite IHm.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).
rewrite CPToListOK.
rewrite <- interp_CPHdOK.
rewrite <- interp_CPTlOK.
rewrite IHm.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (cons (interp_CP (headCPbis cp) interp) (map interp (CPToList (tailCP cp)))) (map interp (CPToList cp))
+++++
simpl.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.
intros cp interp.
induction m.
try (clear IHm0).
rewrite CPToListOK.
rewrite <- interp_CPHdOK.
rewrite <- interp_CPTlOK.
rewrite IHm.
simpl.

*****
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (interp : forall _ : positive, COINCpoint),\neq (CPToList (interp_CP cp interp)) (map interp (CPToList cp))
m : nat
AR : Arity
*****
eq (cons (interp (fst cp)) (cons (interp (fst (snd cp))) (map interp (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) m (tailCP (snd cp)))))) (cons (interp (fst cp)) (cons (interp (fst (snd cp))) (map interp (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) m (tailCP (snd cp))))))
+++++
reflexivity.
-----
Lemma interp_CPOK {m : nat} : forall (cp : cartesianPower positive (S m)) (interp: positive -> COINCpoint), CPToList (interp_CP cp interp) = map interp (CPToList cp).
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Context {COP : Coinc_predicates AR}.
-----
Definition ss_ok (ss : SS.t) (interp: positive -> COINCpoint) :=\n  forall s, SS.mem s ss = true ->\n  forall cp, memCP cp s = true ->\n    app coinc (interp_CP cp interp).
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp,\n  consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (x : tST) (interp : forall _ : positive, COINCpoint), eq (consHeadCP (interp_CP cp interp) (interp_CP x interp)) (interp_CP (consHeadCP cp x) interp)
+++++
Proof.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S O)) (x : tST) (interp : forall _ : positive, COINCpoint), eq (consHeadCP (interp_CP cp interp) (interp_CP x interp)) (interp_CP (consHeadCP cp x) interp)
+++++
intros cp x interp.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.
intros cp x interp.

*****
interp : forall _ : positive, COINCpoint
x : tST
cp : cartesianPower positive (S O)
COP : Coinc_predicates AR
AR : Arity
*****
eq (consHeadCP (interp_CP cp interp) (interp_CP x interp)) (interp_CP (consHeadCP cp x) interp)
+++++
apply CP_ind.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.
intros cp x interp.
apply CP_ind.

*****
interp : forall _ : positive, COINCpoint
x : tST
cp : cartesianPower positive (S O)
COP : Coinc_predicates AR
AR : Arity
*****
eq (headCP (consHeadCP (interp_CP cp interp) (interp_CP x interp))) (headCP (interp_CP (consHeadCP cp x) interp))
+++++
simpl.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.
intros cp x interp.
apply CP_ind.
simpl.

*****
interp : forall _ : positive, COINCpoint
x : tST
cp : cartesianPower positive (S O)
COP : Coinc_predicates AR
AR : Arity
*****
eq (interp cp) (interp cp)
+++++
reflexivity.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.
intros cp x interp.
apply CP_ind.

*****
interp : forall _ : positive, COINCpoint
x : tST
cp : cartesianPower positive (S O)
COP : Coinc_predicates AR
AR : Arity
*****
eq (tailCP (consHeadCP (interp_CP cp interp) (interp_CP x interp))) (tailCP (interp_CP (consHeadCP cp x) interp))
+++++
simpl.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.
intros cp x interp.
apply CP_ind.
simpl.

*****
interp : forall _ : positive, COINCpoint
x : tST
cp : cartesianPower positive (S O)
COP : Coinc_predicates AR
AR : Arity
*****
eq (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), cartesianPower COINCpoint (S (S m))) (fun cp : cartesianPower positive (S (S O)) => pair (interp (fst cp)) (interp (snd cp))) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), cartesianPower COINCpoint (S (S m))) (cp : cartesianPower positive (S (S (S m)))) => pair (interp (fst cp)) (IHm (snd cp))) n x) (nat_rect (fun m : nat => forall _ : cartesianPower positive (S (S m)), cartesianPower COINCpoint (S (S m))) (fun cp : cartesianPower positive (S (S O)) => pair (interp (fst cp)) (interp (snd cp))) (fun (m : nat) (IHm : forall _ : cartesianPower positive (S (S m)), cartesianPower COINCpoint (S (S m))) (cp : cartesianPower positive (S (S (S m)))) => pair (interp (fst cp)) (IHm (snd cp))) n x)
+++++
reflexivity.
-----
Lemma consHdInterpOK : forall (cp : cartesianPower positive 1) (x : tST) interp, consHeadCP (interp_CP cp interp) (interp_CP x interp) = interp_CP (consHeadCP cp x) interp.
Proof.
intros cp x interp.
apply CP_ind.

*****

*****

+++++
Qed.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1),\n  ss_ok ss interp ->\n  SS.In s1 ss ->\n  pick_variety_aux (S.inter s1 s2) x = true ->\n  S.mem p s1 = true ->\n  app_1_n coinc (interp_CP p interp) (interp_CP x interp).
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (interp : forall _ : positive, COINCpoint) (s1 : SS.elt) (s2 : S.t) (x : tST) (p : cartesianPower positive (S O)) (_ : ss_ok ss interp) (_ : SS.In s1 ss) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true) (_ : eq (S.mem p s1) true), app_1_n coinc (interp_CP p interp) (interp_CP x interp)
+++++
Proof.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (interp : forall _ : positive, COINCpoint) (s1 : SS.elt) (s2 : S.t) (x : tST) (p : cartesianPower positive (S O)) (_ : ss_ok ss interp) (_ : SS.In s1 ss) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true) (_ : eq (S.mem p s1) true), app_1_n coinc (interp_CP p interp) (interp_CP x interp)
+++++
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (interp_CP p interp) (interp_CP x interp)
+++++
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
try (simpl; reflexivity).
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
assert (Hmemcp : memCPAux n x s1 = true).
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux n x s1) true
+++++
apply pick_variety_aux_memCPAux1 with s2.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
apply pick_variety_aux_memCPAux1 with s2.

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_auxCP (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
idtac.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
unfold ss_ok in HSSOK.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
rewrite consHdInterpOK.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP (consHeadCP p x) interp)
+++++
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s1 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP (consHeadCP p x) interp)
+++++
apply HSSOK with s1.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s1.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s1 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s1 ss) true
+++++
try assumption.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s1.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s1 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP (consHeadCP p x) s1) true
+++++
try assumption.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s1.
try assumption.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s1 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP (consHeadCP p x) s1) true
+++++
apply memCPConsHd.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s1.
try assumption.
apply memCPConsHd.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s1 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem p s1) true
+++++
assumption.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s1 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s1.
try assumption.
apply memCPConsHd.

*****
Hmemcp : eq (memCPAux n x s1) true
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s1 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux n x s1) true
+++++
assumption.
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (headCP (consHeadCP (interp_CP p interp) (interp_CP x interp))) (interp_CP p interp)
+++++
try (simpl; reflexivity).
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****
Hmem : eq (S.mem p s1) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s1 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : S\.t
s1 : SS\.elt
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (tailCP (consHeadCP (interp_CP p interp) (interp_CP x interp))) (interp_CP x interp)
+++++
try (simpl; reflexivity).
-----
Lemma ss_ok_inter_ok1 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s1 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s1 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****

*****

+++++
Qed.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1),\n  ss_ok ss interp ->\n  SS.In s2 ss ->\n  pick_variety_aux (S.inter s1 s2) x = true ->\n  S.mem p s2 = true ->\n  app_1_n coinc (interp_CP p interp) (interp_CP x interp).
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (interp : forall _ : positive, COINCpoint) (s1 : S.t) (s2 : SS.elt) (x : tST) (p : cartesianPower positive (S O)) (_ : ss_ok ss interp) (_ : SS.In s2 ss) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true) (_ : eq (S.mem p s2) true), app_1_n coinc (interp_CP p interp) (interp_CP x interp)
+++++
Proof.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (interp : forall _ : positive, COINCpoint) (s1 : S.t) (s2 : SS.elt) (x : tST) (p : cartesianPower positive (S O)) (_ : ss_ok ss interp) (_ : SS.In s2 ss) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true) (_ : eq (S.mem p s2) true), app_1_n coinc (interp_CP p interp) (interp_CP x interp)
+++++
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (interp_CP p interp) (interp_CP x interp)
+++++
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
try (simpl; reflexivity).
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
assert (Hmemcp : memCPAux n x s2 = true).
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux n x s2) true
+++++
apply pick_variety_aux_memCPAux2 with s1.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
apply pick_variety_aux_memCPAux2 with s1.

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_auxCP (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
idtac.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
unfold ss_ok in HSSOK.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (consHeadCP (interp_CP p interp) (interp_CP x interp))
+++++
rewrite consHdInterpOK.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP (consHeadCP p x) interp)
+++++
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s2 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP (consHeadCP p x) interp)
+++++
apply HSSOK with s2.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s2.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s2 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s2 ss) true
+++++
try assumption.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s2.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s2 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP (consHeadCP p x) s2) true
+++++
try assumption.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s2.
try assumption.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s2 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP (consHeadCP p x) s2) true
+++++
apply memCPConsHd.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s2.
try assumption.
apply memCPConsHd.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s2 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem p s2) true
+++++
assumption.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).
try (simpl; reflexivity).
assert (Hmemcp : memCPAux n x s2 = true).
idtac.
unfold ss_ok in HSSOK.
rewrite consHdInterpOK.
apply SSWEqP.MP.Dec.F.mem_1 in HIn.
apply HSSOK with s2.
try assumption.
apply memCPConsHd.

*****
Hmemcp : eq (memCPAux n x s2) true
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : eq (SS.mem s2 ss) true
HSSOK : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux n x s2) true
+++++
assumption.
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (headCP (consHeadCP (interp_CP p interp) (interp_CP x interp))) (interp_CP p interp)
+++++
try (simpl; reflexivity).
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****
Hmem : eq (S.mem p s2) true
HInter : eq (pick_variety_aux (S.inter s1 s2) x) true
HIn : SS.In s2 ss
HSSOK : ss_ok ss interp
p : cartesianPower positive (S O)
x : tST
s2 : SS\.elt
s1 : S\.t
interp : forall _ : positive, COINCpoint
ss : SS\.t
COP : Coinc_predicates AR
AR : Arity
*****
eq (tailCP (consHeadCP (interp_CP p interp) (interp_CP x interp))) (interp_CP x interp)
+++++
try (simpl; reflexivity).
-----
Lemma ss_ok_inter_ok2 : forall ss interp s1 s2 x (p : cartesianPower positive 1), ss_ok ss interp -> SS.In s2 ss -> pick_variety_aux (S.inter s1 s2) x = true -> S.mem p s2 = true -> app_1_n coinc (interp_CP p interp) (interp_CP x interp).
Proof.
intros ss interp s1 s2 x p HSSOK HIn HInter Hmem.
apply app_app_1_n with (consHeadCP (interp_CP p interp) (interp_CP x interp)).

*****

*****

+++++
Qed.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp,\n  ss_ok ss interp ->\n  SS.In s1 ss ->\n  SS.In s2 ss ->\n  memCPAux (S m) cp (S.union s1 s2) = true ->\n  pick_variety_aux (S.inter s1 s2) x = true ->\n  pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S (S m)))) (s1 s2 : SS.elt) (ss : SS.t) (x : tST) (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp) (_ : SS.In s1 ss) (_ : SS.In s2 ss) (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true), pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp)
+++++
Proof.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (m : nat) (cp : cartesianPower positive (S (S (S m)))) (s1 s2 : SS.elt) (ss : SS.t) (x : tST) (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp) (_ : SS.In s1 ss) (_ : SS.In s2 ss) (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true), pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp)
+++++
induction m.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.

*****
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S O)))) (s1 s2 : SS.elt) (ss : SS.t) (x : tST) (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp) (_ : SS.In s1 ss) (_ : SS.In s2 ss) (_ : eq (memCPAux (S O) cp (S.union s1 s2)) true) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true), pred_conj_aux coinc (S (S O)) (interp_CP cp interp) (interp_CP x interp)
+++++
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj_aux coinc (S (S O)) (interp_CP cp interp) (interp_CP x interp)
+++++
unfold pred_conj_aux.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
nat_rect (fun m : nat => forall _ : cartesianPower COINCpoint (S m), Prop) (fun cp : cartesianPower COINCpoint (S O) => app_1_n coinc cp (interp_CP x interp)) (fun (m : nat) (IHm : forall _ : cartesianPower COINCpoint (S m), Prop) (cp : cartesianPower COINCpoint (S (S m))) => and (app_1_n coinc (headCP cp) (interp_CP x interp)) (IHm (tailCP cp))) (S (S O)) (interp_CP cp interp)
+++++
unfold nat_rect.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
and (app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)) (and (app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)) (app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)))
+++++
split.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
assert (HIn : InCP (headCP cp) cp).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp) cp
+++++
unfold InCP.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
unfold InCP.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
In (headCP cp) (CPToList cp)
+++++
simpl.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
unfold InCP.
simpl.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) (fst cp)) (or (eq (fst (snd cp)) (fst cp)) (or (eq (snd (snd cp)) (fst cp)) False))
+++++
auto.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp) (S.union s1 s2)) true
+++++
apply memCPAuxOK with 1 cp.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
apply memCPAuxOK with 1 cp.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S O) cp (S.union s1 s2)) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
apply memCPAuxOK with 1 cp.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp) cp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).

*****
HElim : eq (S.mem (headCP cp) (S.union s1 s2)) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.

*****
HElim : eq (S.mem (headCP cp) (S.union s1 s2)) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
rewrite SWP.FM.union_b in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.

*****
HElim : eq (orb (S.mem (headCP cp) s1) (S.mem (headCP cp) s2)) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
apply orb_true_iff in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.

*****
HElim : or (eq (S.mem (headCP cp) s1) true) (eq (S.mem (headCP cp) s2) true)
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
elim HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (headCP cp) s1) true) (eq (S.mem (headCP cp) s2) true)
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s1) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s1) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
apply ss_ok_inter_ok1 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s1 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp) s1) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (headCP cp) s1) true) (eq (S.mem (headCP cp) s2) true)
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s2) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s2) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
apply ss_ok_inter_ok2 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s2 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp) s2) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
and (app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)) (app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp))
+++++
split.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
assert (HIn : InCP (headCP (tailCP cp)) cp).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP (tailCP cp)) cp
+++++
unfold InCP.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
unfold InCP.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
In (headCP (tailCP cp)) (CPToList cp)
+++++
simpl.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
unfold InCP.
simpl.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) (fst (snd cp))) (or (eq (fst (snd cp)) (fst (snd cp))) (or (eq (snd (snd cp)) (fst (snd cp))) False))
+++++
auto.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP (tailCP cp)) (S.union s1 s2)) true
+++++
apply memCPAuxOK with 1 cp.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
apply memCPAuxOK with 1 cp.

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S O) cp (S.union s1 s2)) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
apply memCPAuxOK with 1 cp.

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP (tailCP cp)) cp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).

*****
HElim : eq (S.mem (headCP (tailCP cp)) (S.union s1 s2)) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.

*****
HElim : eq (S.mem (headCP (tailCP cp)) (S.union s1 s2)) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
rewrite SWP.FM.union_b in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.

*****
HElim : eq\n (orb (S.mem (headCP (tailCP cp)) s1) (S.mem (headCP (tailCP cp)) s2))\n true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
apply orb_true_iff in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.

*****
HElim : or (eq (S.mem (headCP (tailCP cp)) s1) true)\n (eq (S.mem (headCP (tailCP cp)) s2) true)
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
elim HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (headCP (tailCP cp)) s1) true)\n (eq (S.mem (headCP (tailCP cp)) s2) true)
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP (tailCP cp)) s1) true, app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP (tailCP cp)) s1) true, app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s1) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
apply ss_ok_inter_ok1 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s1) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s1) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s1 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s1) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s1) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP (tailCP cp)) s1) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (headCP (tailCP cp)) s1) true)\n (eq (S.mem (headCP (tailCP cp)) s2) true)
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP (tailCP cp)) s2) true, app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP (tailCP cp)) s2) true, app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s2) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
apply ss_ok_inter_ok2 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s2) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s2) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s2 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s2) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (headCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (headCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP (tailCP cp)) s2) true
HIn : InCP (headCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP (tailCP cp)) s2) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
assert (HIn : InCP (tailCP (tailCP cp)) cp).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
InCP (tailCP (tailCP cp)) cp
+++++
unfold InCP.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
unfold InCP.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
In (tailCP (tailCP cp)) (CPToList cp)
+++++
simpl.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
unfold InCP.
simpl.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) (snd (snd cp))) (or (eq (fst (snd cp)) (snd (snd cp))) (or (eq (snd (snd cp)) (snd (snd cp))) False))
+++++
auto.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (tailCP (tailCP cp)) (S.union s1 s2)) true
+++++
apply memCPAuxOK with 1 cp.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
apply memCPAuxOK with 1 cp.

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S O) cp (S.union s1 s2)) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
apply memCPAuxOK with 1 cp.

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
InCP (tailCP (tailCP cp)) cp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).

*****
HElim : eq (S.mem (tailCP (tailCP cp)) (S.union s1 s2)) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) (S.union s1 s2)) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
rewrite SWP.FM.union_b in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.

*****
HElim : eq\n (orb (S.mem (tailCP (tailCP cp)) s1) (S.mem (tailCP (tailCP cp)) s2))\n true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
apply orb_true_iff in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.

*****
HElim : or (eq (S.mem (tailCP (tailCP cp)) s1) true)\n (eq (S.mem (tailCP (tailCP cp)) s2) true)
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
elim HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (tailCP (tailCP cp)) s1) true)\n (eq (S.mem (tailCP (tailCP cp)) s2) true)
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (tailCP (tailCP cp)) s1) true, app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (tailCP (tailCP cp)) s1) true, app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s1) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
apply ss_ok_inter_ok1 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s1) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s1) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s1 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s1) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s1) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (tailCP (tailCP cp)) s1) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (tailCP (tailCP cp)) s1) true)\n (eq (S.mem (tailCP (tailCP cp)) s2) true)
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (tailCP (tailCP cp)) s2) true, app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (tailCP (tailCP cp)) s2) true, app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s2) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (tailCP (tailCP (interp_CP cp interp))) (interp_CP x interp)
+++++
apply ss_ok_inter_ok2 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s2) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s2) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s2 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s2) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
unfold pred_conj_aux.
unfold nat_rect.
split.
split.
assert (HIn : InCP (tailCP (tailCP cp)) cp).
idtac.
assert (HElim : S.mem (tailCP (tailCP cp)) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (tailCP (tailCP cp)) s2) true
HIn : InCP (tailCP (tailCP cp)) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S O) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S O)))
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (tailCP (tailCP cp)) s2) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.

*****
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S (S m))))) (s1 s2 : SS.elt) (ss : SS.t) (x : tST) (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp) (_ : SS.In s1 ss) (_ : SS.In s2 ss) (_ : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true) (_ : eq (pick_variety_aux (S.inter s1 s2) x) true), pred_conj_aux coinc (S (S (S m))) (interp_CP cp interp) (interp_CP x interp)
+++++
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj_aux coinc (S (S (S m))) (interp_CP cp interp) (interp_CP x interp)
+++++
rewrite pcaHdTl.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
and (app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)) (pred_conj_aux coinc (S (S m)) (tailCP (interp_CP cp interp)) (interp_CP x interp))
+++++
split.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
assert (HIn : InCP (headCP cp) cp).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp) cp
+++++
unfold InCP.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
unfold InCP.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
In (headCP cp) (CPToList cp)
+++++
simpl.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
unfold InCP.
simpl.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) (fst cp)) (or (eq (fst (snd cp)) (fst cp)) (or (eq (fst (snd (snd cp))) (fst cp)) (In (fst cp) (nat_rect (fun n : nat => forall _ : cartesianPower positive (S n), list positive) (fun cp : cartesianPower positive (S O) => cons cp nil) (fun (n : nat) (IHn : forall _ : cartesianPower positive (S n), list positive) (cp : cartesianPower positive (S (S n))) => cons (fst cp) (IHn (tailCP cp))) m (tailCP (snd (snd cp)))))))
+++++
auto.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp) (S.union s1 s2)) true
+++++
apply memCPAuxOK with (S (S m)) cp.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
apply memCPAuxOK with (S (S m)) cp.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
apply memCPAuxOK with (S (S m)) cp.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp) cp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).

*****
HElim : eq (S.mem (headCP cp) (S.union s1 s2)) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
idtac.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.

*****
HElim : eq (S.mem (headCP cp) (S.union s1 s2)) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
rewrite SWP.FM.union_b in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.

*****
HElim : eq (orb (S.mem (headCP cp) s1) (S.mem (headCP cp) s2)) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
apply orb_true_iff in HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.

*****
HElim : or (eq (S.mem (headCP cp) s1) true) (eq (S.mem (headCP cp) s2) true)
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
elim HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (headCP cp) s1) true) (eq (S.mem (headCP cp) s2) true)
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s1) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s1) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
apply ss_ok_inter_ok1 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s1 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok1 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s1) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp) s1) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.

*****
HElim : or (eq (S.mem (headCP cp) s1) true) (eq (S.mem (headCP cp) s2) true)
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s2) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
clear HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.

*****
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem (headCP cp) s2) true, app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
intro HElim.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
app_1_n coinc (headCP (interp_CP cp interp)) (interp_CP x interp)
+++++
apply ss_ok_inter_ok2 with ss s1 s2.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s2 ss
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
assert (HIn : InCP (headCP cp) cp).
idtac.
assert (HElim : S.mem (headCP cp) (S.union s1 s2) = true).
idtac.
rewrite SWP.FM.union_b in HElim.
apply orb_true_iff in HElim.
elim HElim.
clear HElim.
intro HElim.
apply ss_ok_inter_ok2 with ss s1 s2.

*****
HElim : eq (S.mem (headCP cp) s2) true
HIn : InCP (headCP cp) cp
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp) s2) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj_aux coinc (S (S m)) (tailCP (interp_CP cp interp)) (interp_CP x interp)
+++++
rewrite <- interp_CPTlOK.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj_aux coinc (S (S m)) (interp_CP (tailCP cp) interp) (interp_CP x interp)
+++++
apply IHm with s1 s2 ss.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
try assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s1 ss
+++++
try assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s2 ss
+++++
try assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S m) (tailCP cp) (S.union s1 s2)) true
+++++
try assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.
try assumption.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S m) (tailCP cp) (S.union s1 s2)) true
+++++
apply memCPAuxTlOK.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.
try assumption.
apply memCPAuxTlOK.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
+++++
assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.
intros cp s1 s2 ss x interp HSSOK HIn1 HIn2 Hmemcp Hhtspa.
rewrite pcaHdTl.
split.
rewrite <- interp_CPTlOK.
apply IHm with s1 s2 ss.

*****
Hhtspa : eq (pick_variety_aux (S.inter s1 s2) x) true
Hmemcp : eq (memCPAux (S (S m)) cp (S.union s1 s2)) true
HIn2 : SS.In s2 ss
HIn1 : SS.In s1 ss
HSSOK : ss_ok ss interp
interp : forall _ : positive, COINCpoint
x : tST
ss : SS\.t
s1,s2 : SS\.elt
cp : cartesianPower positive (S (S (S (S m))))
IHm : forall (cp : cartesianPower positive (S (S (S m)))) \n (s1 s2 : SS.elt) (ss : SS.t) (x : tST)\n (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp)\n (_ : SS.In s1 ss) (_ : SS.In s2 ss)\n (_ : eq (memCPAux (S m) cp (S.union s1 s2)) true)\n (_ : eq (pick_variety_aux (S.inter s1 s2) x) true),\npred_conj_aux coinc (S (S m)) (interp_CP cp interp)\n (interp_CP x interp)
m : nat
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
try assumption.
-----
Lemma mca_pick_variety_aux_pca : forall m cp s1 s2 ss x interp, ss_ok ss interp -> SS.In s1 ss -> SS.In s2 ss -> memCPAux (S m) cp (S.union s1 s2) = true -> pick_variety_aux (S.inter s1 s2) x = true -> pred_conj_aux coinc (S (S m)) (interp_CP cp interp) (interp_CP x interp).
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Definition st_ok (st : STt) (interp: positive -> COINCpoint) :=\n  forall t, STmem t st = true -> app wd (interp_CP t interp).
-----
Context {COT : Coinc_theory AR COP}.
-----
Lemma identify_varieties_ok : forall ss st interp,\n  ss_ok ss interp -> st_ok st interp ->\n  ss_ok (identify_varieties ss st) interp.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt) (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties ss st) interp
+++++
Proof.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt) (interp : forall _ : positive, COINCpoint) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties ss st) interp
+++++
intros ss st interp HSS HST.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties ss st) interp
+++++
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (_ : eq varieties None) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok ss interp
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (_ : eq varieties None) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok ss interp
+++++
intros.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
intros.

*****
H0 : st_ok st0 interp
H : ss_ok ss0 interp
e : eq varieties None
varieties : option (prod SS.elt SS.elt)
st0 : STt
ss0 : SS\.t
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss0 interp
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (s1 s2 : SS.elt) (_ : eq varieties (Some (pair s1 s2))), let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in forall (_ : forall (_ : ss_ok newss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (s1 s2 : SS.elt) (_ : eq varieties (Some (pair s1 s2))), let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in forall (_ : forall (_ : ss_ok newss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp
+++++
clear HSS.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.

*****
HST : st_ok st interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (s1 s2 : SS.elt) (_ : eq varieties (Some (pair s1 s2))), let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in forall (_ : forall (_ : ss_ok newss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp
+++++
clear HST.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.

*****
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (s1 s2 : SS.elt) (_ : eq varieties (Some (pair s1 s2))), let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in forall (_ : forall (_ : ss_ok newss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp
+++++
clear ss.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.

*****
interp : forall _ : positive, COINCpoint
st : STt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (s1 s2 : SS.elt) (_ : eq varieties (Some (pair s1 s2))), let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in forall (_ : forall (_ : ss_ok newss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp
+++++
clear st.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.

*****
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt), let varieties := pick_varieties ss st in forall (s1 s2 : SS.elt) (_ : eq varieties (Some (pair s1 s2))), let auxsetofsets := SS.remove s2 (SS.remove s1 ss) in let auxset := S.union s1 s2 in let newss := SS.add auxset auxsetofsets in forall (_ : forall (_ : ss_ok newss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp) (_ : ss_ok ss interp) (_ : st_ok st interp), ss_ok (identify_varieties newss st) interp
+++++
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.

*****
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties newss st) interp
+++++
assert (Hs1 := Hs1s2).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).

*****
Hs1 : eq varieties (Some (pair s1 s2))
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties newss st) interp
+++++
assert (Hs2 := Hs1s2).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).

*****
Hs1,Hs2 : eq varieties (Some (pair s1 s2))
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties newss st) interp
+++++
apply pick_varieties_ok_1 in Hs1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.

*****
Hs2 : eq varieties (Some (pair s1 s2))
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties newss st) interp
+++++
apply pick_varieties_ok_2 in Hs2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.

*****
Hs2 : SS.In s2 (SS.remove s1 ss)
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties newss st) interp
+++++
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.

*****
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties newss st) interp
+++++
apply H.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.

*****
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok newss interp
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.

*****
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok newss interp
+++++
clear H.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.

*****
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok newss interp
+++++
intros s Hmem cp Hmemcp.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.

*****
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s newss) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold newss in Hmem.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.

*****
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear newss.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.

*****
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
elim (SS.E.eq_dec auxset s).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).

*****
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : S.Equal auxset s, app coinc (interp_CP cp interp)
+++++
intro HEq.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.

*****
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
assert (HEq' : memCP cp auxset = memCP cp s).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).

*****
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP cp auxset) (memCP cp s)
+++++
apply memCPProper.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
apply memCPProper.

*****
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq cp cp
+++++
trivial.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
apply memCPProper.

*****
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
S.Equal auxset s
+++++
trivial.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).

*****
HEq' : eq (memCP cp auxset) (memCP cp s)
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
idtac.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.

*****
HEq' : eq (memCP cp auxset) (memCP cp s)
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite <- HEq in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.

*****
HEq' : eq (memCP cp auxset) (memCP cp s)
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite <- HEq' in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.

*****
HEq' : eq (memCP cp auxset) (memCP cp s)
HEq : S.Equal auxset s
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear HEq.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.

*****
HEq' : eq (memCP cp auxset) (memCP cp s)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear HEq'.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear s.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold varieties in Hs1s2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (pick_varieties ss st) (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear varieties.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (pick_varieties ss st) (Some (pair s1 s2))
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold pick_varieties in Hs1s2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) (Some e)), app coinc (interp_CP cp interp)
+++++
try (intro HEW; rewrite HEW in *; discriminate).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) (Some e)), app coinc (interp_CP cp interp)
+++++
intros e1 HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.

*****
HEW : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
e1 : SS\.elt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite HEW in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.

*****
HEW : eq\n (exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss) (Some e1)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (pick_varieties_aux e1 (SS.remove e1 ss) st) (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (pick_varieties_aux e1 (SS.remove e1 ss) st) (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold pick_varieties_aux in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) (Some e)), app coinc (interp_CP cp interp)
+++++
try (intro HEW; rewrite HEW in *; discriminate).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : SS.elt) (_ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) (Some e)), app coinc (interp_CP cp interp)
+++++
intros e2 HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
e2 : SS\.elt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite HEW in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair e1 e2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
injection Hs1s2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair e1 e2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (_ : eq e2 s2) (_ : eq e1 s1), app coinc (interp_CP cp interp)
+++++
intros He2s2 He1s1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.

*****
He1s1 : eq e1 s1
He2s2 : eq e2 s2
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some e2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair e1 e2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite He2s2 in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.

*****
He1s1 : eq e1 s1
He2s2 : eq e2 s2
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair e1 s2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite He1s1 in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.

*****
He1s1 : eq e1 s1
He2s2 : eq e2 s2
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair s1 s2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear He2s2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.

*****
He1s1 : eq e1 s1
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair s1 s2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear He1s1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq (Some (pair s1 s2)) (Some (pair s1 s2))
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear Hs1s2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2,e1,e2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear e2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
clear e1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
case_eq (pick_variety (S.inter s1 s2) st).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (pick_variety (S.inter s1 s2) st) true, app coinc (interp_CP cp interp)
+++++
clear HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (pick_variety (S.inter s1 s2) st) true, app coinc (interp_CP cp interp)
+++++
intro HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.

*****
HEW : eq (pick_variety (S.inter s1 s2) st) true
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold pick_variety in HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.

*****
HEW : eq (STexists_ (fun t : STelt => pick_variety_aux (S.inter s1 s2) t) st)\n true
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply STexists_mem_4 in HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.

*****
HEW : ex\n (fun x : STelt =>\n and (eq (STmem x st) true)\n (eq (pick_variety_aux (S.inter s1 s2) x) true))
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).

*****
HEW : ex\n (fun x : STelt =>\n and (eq (STmem x st) true)\n (eq (pick_variety_aux (S.inter s1 s2) x) true))
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
try (apply proper_00).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).

*****
HEW : ex\n (fun x : STelt =>\n and (eq (STmem x st) true)\n (eq (pick_variety_aux (S.inter s1 s2) x) true))
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
destruct HEW as [x [HmemST1 HmemST2]].
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : eq (STmem x st) true
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply HST in HmemST1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply coinc_n with (interp_CP x interp).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj coinc (interp_CP cp interp) (interp_CP x interp)
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj coinc (interp_CP cp interp) (interp_CP x interp)
+++++
unfold pred_conj.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.
unfold pred_conj.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
pred_conj_aux coinc (S (S n)) (interp_CP cp interp) (interp_CP x interp)
+++++
apply mca_pick_variety_aux_pca with s1 s2 ss.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.
unfold pred_conj.
apply mca_pick_variety_aux_pca with s1 s2 ss.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.
unfold pred_conj.
apply mca_pick_variety_aux_pca with s1 s2 ss.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s1 ss
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.
unfold pred_conj.
apply mca_pick_variety_aux_pca with s1 s2 ss.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s2 ss
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.
unfold pred_conj.
apply mca_pick_variety_aux_pca with s1 s2 ss.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux (S n) cp (S.union s1 s2)) true
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).
try assumption.
unfold pred_conj.
apply mca_pick_variety_aux_pca with s1 s2 ss.

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (pick_variety_aux (S.inter s1 s2) x) true
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
clear HEW.
intro HEW.
unfold pick_variety in HEW.
apply STexists_mem_4 in HEW.
try (intros x y Hxy; destruct Hxy as [Hxyfst Hxysnd]; rewrite Hxyfst; rewrite Hxysnd; reflexivity).
try (apply proper_00).
destruct HEW as [x [HmemST1 HmemST2]].
apply HST in HmemST1.
apply coinc_n with (interp_CP x interp).

*****
HmemST2 : eq (pick_variety_aux (S.inter s1 s2) x) true
HmemST1 : app wd (interp_CP x interp)
x : STelt
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP x interp)
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).

*****
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (pick_variety (S.inter s1 s2) st) false, app coinc (interp_CP cp interp)
+++++
intro HEW2.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : eq\n (exists_witness (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss)) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold exists_witness in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.
unfold exists_witness in *.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : eq\n (SS.choose\n (SS.filter (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss))) (Some s2)
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply SS.choose_spec1 in HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.
unfold exists_witness in *.
apply SS.choose_spec1 in HEW.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : SS.In s2\n (SS.filter (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss))
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply SSWEqP.MP.Dec.F.filter_2 in HEW.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.
unfold exists_witness in *.
apply SS.choose_spec1 in HEW.
apply SSWEqP.MP.Dec.F.filter_2 in HEW.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : eq (pick_variety (S.inter s1 s2) st) true
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
try apply proper_1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.
unfold exists_witness in *.
apply SS.choose_spec1 in HEW.
apply SSWEqP.MP.Dec.F.filter_2 in HEW.
try apply proper_1.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : eq (pick_variety (S.inter s1 s2) st) true
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite HEW2 in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.
unfold exists_witness in *.
apply SS.choose_spec1 in HEW.
apply SSWEqP.MP.Dec.F.filter_2 in HEW.
try apply proper_1.
rewrite HEW2 in *.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : eq false true
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
discriminate.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).
try (intro HEW; rewrite HEW in *; discriminate).
intros e2 HEW.
rewrite HEW in *.
injection Hs1s2.
intros He2s2 He1s1.
rewrite He2s2 in *.
rewrite He1s1 in *.
clear He2s2.
clear He1s1.
clear Hs1s2.
clear e2.
clear e1.
case_eq (pick_variety (S.inter s1 s2) st).
intro HEW2.
unfold exists_witness in *.
apply SS.choose_spec1 in HEW.
apply SSWEqP.MP.Dec.F.filter_2 in HEW.

*****
HEW2 : eq (pick_variety (S.inter s1 s2) st) false
HEW : SS.In s2\n (SS.filter (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)\n (SS.remove s1 ss))
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s2 : SS.elt => pick_variety (S.inter s1 s2) st)
+++++
try apply proper_1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).
try (intro HEW; rewrite HEW in *; discriminate).
intros e1 HEW.
rewrite HEW in *.
clear HEW.
unfold pick_varieties_aux in *.
case_eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)).

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st)\n (SS.remove e1 ss)\n with\n | Some s2 => Some (pair e1 s2)\n | None => None\n end (Some (pair s1 s2))
s1,s2,e1 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (exists_witness (fun s2 : SS.elt => pick_variety (S.inter e1 s2) st) (SS.remove e1 ss)) None, app coinc (interp_CP cp interp)
+++++
try (intro HEW; rewrite HEW in *; discriminate).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
assert (HEq' : memCP cp auxset = memCP cp s).
idtac.
rewrite <- HEq in *.
rewrite <- HEq' in *.
clear HEq.
clear HEq'.
clear s.
unfold varieties in Hs1s2.
clear varieties.
unfold pick_varieties in Hs1s2.
case_eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss).

*****
Hmemcp : eq (memCP cp auxset) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem auxset (SS.add auxset auxsetofsets)) true
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq\n match\n exists_witness\n (fun s : SS.elt =>\n match pick_varieties_aux s (SS.remove s ss) st with\n | Some _ => true\n | None => false\n end) ss\n with\n | Some s1 => pick_varieties_aux s1 (SS.remove s1 ss) st\n | None => None\n end (Some (pair s1 s2))
s1,s2 : SS\.elt
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (exists_witness (fun s : SS.elt => match pick_varieties_aux s (SS.remove s ss) st with | Some _ => true | None => false end) ss) None, app coinc (interp_CP cp interp)
+++++
try (intro HEW; rewrite HEW in *; discriminate).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).

*****
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : not (S.Equal auxset s), app coinc (interp_CP cp interp)
+++++
intro HEq.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite SSWP.Dec.F.add_neq_b in Hmem.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s auxsetofsets) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s auxsetofsets) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply HSS with s.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.
apply HSS with s.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s auxsetofsets) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s ss) true
+++++
unfold auxsetofsets in *.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.
apply HSS with s.
unfold auxsetofsets in *.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.remove s2 (SS.remove s1 ss))) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s ss) true
+++++
apply SSWEqP.MP.Dec.F.mem_2 in Hmem.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.
apply HSS with s.
unfold auxsetofsets in *.
apply SSWEqP.MP.Dec.F.mem_2 in Hmem.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : SS.In s (SS.remove s2 (SS.remove s1 ss))
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s ss) true
+++++
do 2 (apply SSWEqP.MP.Dec.F.remove_3 in Hmem).
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.
apply HSS with s.
unfold auxsetofsets in *.
apply SSWEqP.MP.Dec.F.mem_2 in Hmem.
do 2 (apply SSWEqP.MP.Dec.F.remove_3 in Hmem).

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : SS.In s ss
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s ss) true
+++++
apply SSWEqP.MP.Dec.F.mem_1.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.
apply HSS with s.
unfold auxsetofsets in *.
apply SSWEqP.MP.Dec.F.mem_2 in Hmem.
do 2 (apply SSWEqP.MP.Dec.F.remove_3 in Hmem).
apply SSWEqP.MP.Dec.F.mem_1.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : SS.In s ss
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s ss
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.
try assumption.
apply HSS with s.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s auxsetofsets) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP cp s) true
+++++
assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.
try assumption.
clear H.
intros s Hmem cp Hmemcp.
unfold newss in Hmem.
clear newss.
elim (SS.E.eq_dec auxset s).
intro HEq.
rewrite SSWP.Dec.F.add_neq_b in Hmem.

*****
HEq : not (S.Equal auxset s)
Hmemcp : eq (memCP cp s) true
cp : cartesianPower positive (S (S (S n)))
Hmem : eq (SS.mem s (SS.add auxset auxsetofsets)) true
s : SS\.elt
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
not (S.Equal auxset s)
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).
try assumption.
clear HSS.
clear HST.
clear ss.
clear st.
intros ss st varieties s1 s2 Hs1s2 auxsetofsets auxset newss H HSS HST.
assert (Hs1 := Hs1s2).
assert (Hs2 := Hs1s2).
apply pick_varieties_ok_1 in Hs1.
apply pick_varieties_ok_2 in Hs2.
apply SSWEqP.MP.Dec.F.remove_3 in Hs2.
apply H.

*****
Hs2 : SS.In s2 ss
Hs1 : SS.In s1 ss
HST : st_ok st interp
HSS : ss_ok ss interp
H : forall (_ : ss_ok newss interp) (_ : st_ok st interp),\nss_ok (identify_varieties newss st) interp
newss : SS\.t
auxset : S\.t
auxsetofsets : SS\.t
Hs1s2 : eq varieties (Some (pair s1 s2))
s1,s2 : SS\.elt
varieties : option (prod SS.elt SS.elt)
st : STt
ss : SS\.t
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
st_ok st interp
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).

*****
HST : st_ok st interp
HSS : ss_ok ss interp
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
st_ok st interp
+++++
try assumption.
-----
Lemma identify_varieties_ok : forall ss st interp, ss_ok ss interp -> st_ok st interp -> ss_ok (identify_varieties ss st) interp.
Proof.
intros ss st interp HSS HST.
apply (let P interp ss st newss := ss_ok ss interp -> st_ok st interp -> ss_ok newss interp in identify_varieties_ind (P interp)).

*****

*****

+++++
Qed.
-----
Lemma test_coinc_ok : forall ss st interp cp,\n  ss_ok ss interp -> st_ok st interp ->\n  test_coinc ss st cp = true ->\n  app coinc (interp_CP cp interp).
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt) (interp : forall _ : positive, COINCpoint) (cp : cartesianPower positive (S (S (S n)))) (_ : ss_ok ss interp) (_ : st_ok st interp) (_ : eq (test_coinc ss st cp) true), app coinc (interp_CP cp interp)
+++++
Proof.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (ss : SS.t) (st : STt) (interp : forall _ : positive, COINCpoint) (cp : cartesianPower positive (S (S (S n)))) (_ : ss_ok ss interp) (_ : st_ok st interp) (_ : eq (test_coinc ss st cp) true), app coinc (interp_CP cp interp)
+++++
intros ss st interp cp HSS HST HTC.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.

*****
HTC : eq (test_coinc ss st cp) true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold test_coinc in *.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.

*****
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).

*****
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (identify_varieties ss st) interp
+++++
apply identify_varieties_ok.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
apply identify_varieties_ok.

*****
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok ss interp
+++++
assumption.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
apply identify_varieties_ok.

*****
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
st_ok st interp
+++++
assumption.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).

*****
HSS2 : ss_ok (identify_varieties ss st) interp
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
idtac.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.

*****
HSS2 : ss_ok (identify_varieties ss st) interp
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold ss_ok in HSS2.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : SS.Exists (fun x : SS.elt => eq (memCP cp x) true)\n (identify_varieties ss st)
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
unfold SS.Exists in HTC.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
unfold SS.Exists in HTC.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : ex\n (fun x : SS.elt =>\n and (SS.In x (identify_varieties ss st)) (eq (memCP cp x) true))
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
destruct HTC as [s [HIn Hmem]].
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
unfold SS.Exists in HTC.
destruct HTC as [s [HIn Hmem]].

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
Hmem : eq (memCP cp s) true
HIn : SS.In s (identify_varieties ss st)
s : SS\.elt
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply HSS2 with s.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
unfold SS.Exists in HTC.
destruct HTC as [s [HIn Hmem]].
apply HSS2 with s.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
Hmem : eq (memCP cp s) true
HIn : SS.In s (identify_varieties ss st)
s : SS\.elt
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s (identify_varieties ss st)) true
+++++
apply SSWEqP.MP.Dec.F.mem_1.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
unfold SS.Exists in HTC.
destruct HTC as [s [HIn Hmem]].
apply HSS2 with s.
apply SSWEqP.MP.Dec.F.mem_1.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
Hmem : eq (memCP cp s) true
HIn : SS.In s (identify_varieties ss st)
s : SS\.elt
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s (identify_varieties ss st)
+++++
assumption.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
unfold SS.Exists in HTC.
destruct HTC as [s [HIn Hmem]].
apply HSS2 with s.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
Hmem : eq (memCP cp s) true
HIn : SS.In s (identify_varieties ss st)
s : SS\.elt
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP cp s) true
+++++
assumption.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.

*****
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Proper (respectful S.Equal eq) (fun s : SS.elt => memCP cp s)
+++++
intros x y Hxy.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
intros x y Hxy.

*****
Hxy : S.Equal x y
x,y : S\.t
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP cp x) (memCP cp y)
+++++
apply memCPProper.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
intros x y Hxy.
apply memCPProper.

*****
Hxy : S.Equal x y
x,y : S\.t
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq cp cp
+++++
trivial.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).
idtac.
unfold ss_ok in HSS2.
apply SSWEqP.MP.Dec.F.exists_2 in HTC.
intros x y Hxy.
apply memCPProper.

*****
Hxy : S.Equal x y
x,y : S\.t
HSS2 : forall (s : SS.elt) (_ : eq (SS.mem s (identify_varieties ss st)) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HTC : eq\n (SS.exists_ (fun s : SS.elt => memCP cp s) (identify_varieties ss st))\n true
HST : st_ok st interp
HSS : ss_ok ss interp
cp : cartesianPower positive (S (S (S n)))
interp : forall _ : positive, COINCpoint
st : STt
ss : SS\.t
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
S.Equal x y
+++++
trivial.
-----
Lemma test_coinc_ok : forall ss st interp cp, ss_ok ss interp -> st_ok st interp -> test_coinc ss st cp = true -> app coinc (interp_CP cp interp).
Proof.
intros ss st interp cp HSS HST HTC.
unfold test_coinc in *.
assert (HSS2 : ss_ok (identify_varieties ss st) interp).

*****

*****

+++++
Qed.
-----
Lemma ss_ok_empty : forall interp,\n  ss_ok SS.empty interp.
-----
Lemma ss_ok_empty : forall interp, ss_ok SS.empty interp.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall interp : forall _ : positive, COINCpoint, ss_ok SS.empty interp
+++++
Proof.
-----
Lemma ss_ok_empty : forall interp, ss_ok SS.empty interp.
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall interp : forall _ : positive, COINCpoint, ss_ok SS.empty interp
+++++
intros interp ss Hmem1 cp Hmem2.
-----
Lemma ss_ok_empty : forall interp, ss_ok SS.empty interp.
Proof.
intros interp ss Hmem1 cp Hmem2.

*****
Hmem2 : eq (memCP cp ss) true
cp : cartesianPower positive (S (S (S n)))
Hmem1 : eq (SS.mem ss SS.empty) true
ss : SS\.elt
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
rewrite SSWEqP.MP.Dec.F.empty_b in Hmem1.
-----
Lemma ss_ok_empty : forall interp, ss_ok SS.empty interp.
Proof.
intros interp ss Hmem1 cp Hmem2.
rewrite SSWEqP.MP.Dec.F.empty_b in Hmem1.

*****
Hmem2 : eq (memCP cp ss) true
cp : cartesianPower positive (S (S (S n)))
Hmem1 : eq false true
ss : SS\.elt
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
discriminate.
-----
Lemma ss_ok_empty : forall interp, ss_ok SS.empty interp.
Proof.
intros interp ss Hmem1 cp Hmem2.
rewrite SSWEqP.MP.Dec.F.empty_b in Hmem1.
discriminate.

*****

*****

+++++
Qed.
-----
Lemma st_ok_empty : forall interp,\n  st_ok STempty interp.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall interp : forall _ : positive, COINCpoint, st_ok STempty interp
+++++
Proof.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall interp : forall _ : positive, COINCpoint, st_ok STempty interp
+++++
intros.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.
Proof.
intros.

*****
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
st_ok STempty interp
+++++
unfold st_ok.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.
Proof.
intros.
unfold st_ok.

*****
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (t : tST) (_ : eq (STmem t STempty) true), app wd (interp_CP t interp)
+++++
intros t Ht.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.
Proof.
intros.
unfold st_ok.
intros t Ht.

*****
Ht : eq (STmem t STempty) true
t : tST
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP t interp)
+++++
rewrite STempty_b in Ht.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.
Proof.
intros.
unfold st_ok.
intros t Ht.
rewrite STempty_b in Ht.

*****
Ht : eq false true
t : tST
interp : forall _ : positive, COINCpoint
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP t interp)
+++++
discriminate.
-----
Lemma st_ok_empty : forall interp, st_ok STempty interp.
Proof.
intros.
unfold st_ok.
intros t Ht.
rewrite STempty_b in Ht.
discriminate.

*****

*****

+++++
Qed.
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.

*****
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS\.elt
+++++
Proof.
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
Proof.

*****
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS\.elt
+++++
induction m.
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
Proof.
induction m.

*****
cp : cartesianPower positive O
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS\.elt
+++++
exact S.empty.
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
Proof.
induction m.

*****
IHm : forall _ : cartesianPower positive m, SS.elt
cp : cartesianPower positive (S m)
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS\.elt
+++++
induction m.
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
Proof.
induction m.
induction m.

*****
IHm : forall _ : cartesianPower positive O, SS.elt
cp : cartesianPower positive (S O)
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS\.elt
+++++
exact (S.add cp S.empty).
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
Proof.
induction m.
induction m.

*****
IHm0 : forall (_ : cartesianPower positive (S m))\n (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt
IHm : forall _ : cartesianPower positive (S m), SS.elt
cp : cartesianPower positive (S (S m))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS\.elt
+++++
exact (S.add (headCP cp) (IHm (tailCP cp))).
-----
Definition CPToSS {m:nat} (cp : cartesianPower positive m) : SS.elt.
Proof.
induction m.

*****

*****

+++++
Defined.
-----
Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))),\n  CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).
-----
Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))), CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall cp : cartesianPower positive (S (S m)), eq (CPToSS cp) (S.add (headCP cp) (CPToSS (tailCP cp)))
+++++
Proof.
-----
Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))), CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).
Proof.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall cp : cartesianPower positive (S (S m)), eq (CPToSS cp) (S.add (headCP cp) (CPToSS (tailCP cp)))
+++++
simpl.
-----
Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))), CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).
Proof.
simpl.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall cp : cartesianPower positive (S (S m)), eq (S.add (fst cp) (nat_rect (fun m : nat => forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (fun (cp0 : cartesianPower positive (S O)) (_ : forall _ : cartesianPower positive O, SS.elt) => S.add cp0 S.empty) (fun (m : nat) (_ : forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (cp0 : cartesianPower positive (S (S m))) (IHm : forall _ : cartesianPower positive (S m), SS.elt) => S.add (fst cp0) (IHm (tailCP cp0))) m (tailCP cp) ((fix F (n : nat) : forall _ : cartesianPower positive n, SS.elt := match n as n0 return (forall _ : cartesianPower positive n0, SS.elt) with | O => fun _ : cartesianPower positive O => S.empty | S n0 => fun cp0 : cartesianPower positive (S n0) => nat_rect (fun m : nat => forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (fun (cp1 : cartesianPower positive (S O)) (_ : forall _ : cartesianPower positive O, SS.elt) => S.add cp1 S.empty) (fun (m : nat) (_ : forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (cp1 : cartesianPower positive (S (S m))) (IHm : forall _ : cartesianPower positive (S m), SS.elt) => S.add (fst cp1) (IHm (tailCP cp1))) n0 cp0 (F n0) end) m))) (S.add (fst cp) (nat_rect (fun m : nat => forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (fun (cp0 : cartesianPower positive (S O)) (_ : forall _ : cartesianPower positive O, SS.elt) => S.add cp0 S.empty) (fun (m : nat) (_ : forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (cp0 : cartesianPower positive (S (S m))) (IHm : forall _ : cartesianPower positive (S m), SS.elt) => S.add (fst cp0) (IHm (tailCP cp0))) m (tailCP cp) ((fix F (n : nat) : forall _ : cartesianPower positive n, SS.elt := match n as n0 return (forall _ : cartesianPower positive n0, SS.elt) with | O => fun _ : cartesianPower positive O => S.empty | S n0 => fun cp0 : cartesianPower positive (S n0) => nat_rect (fun m : nat => forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (fun (cp1 : cartesianPower positive (S O)) (_ : forall _ : cartesianPower positive O, SS.elt) => S.add cp1 S.empty) (fun (m : nat) (_ : forall (_ : cartesianPower positive (S m)) (_ : forall _ : cartesianPower positive m, SS.elt), SS.elt) (cp1 : cartesianPower positive (S (S m))) (IHm : forall _ : cartesianPower positive (S m), SS.elt) => S.add (fst cp1) (IHm (tailCP cp1))) n0 cp0 (F n0) end) m)))
+++++
reflexivity.
-----
Lemma CPToSSHdTl {m:nat} : forall (cp : cartesianPower positive (S (S m))), CPToSS cp = S.add (headCP cp) (CPToSS (tailCP cp)).
Proof.
simpl.
reflexivity.

*****

*****

+++++
Qed.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)),\n  S.mem e (CPToSS cp) = true ->\n  InCP e cp.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : S.elt) (cp : cartesianPower positive (S m)) (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
+++++
Proof.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : S.elt) (cp : cartesianPower positive (S m)) (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
+++++
induction m.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : S.elt) (cp : cartesianPower positive (S O)) (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
+++++
intros e cp Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.

*****
Hmem : eq (S.mem e (CPToSS cp)) true
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
unfold InCP.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
unfold InCP.

*****
Hmem : eq (S.mem e (CPToSS cp)) true
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
In e (CPToList cp)
+++++
simpl in *.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
unfold InCP.
simpl in *.

*****
Hmem : eq (S.mem e (S.add cp S.empty)) true
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq cp e) False
+++++
left.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
unfold InCP.
simpl in *.
left.

*****
Hmem : eq (S.mem e (S.add cp S.empty)) true
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq cp e
+++++
rewrite <- SWP.singleton_equal_add in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
unfold InCP.
simpl in *.
left.
rewrite <- SWP.singleton_equal_add in Hmem.

*****
Hmem : eq (S.mem e (S.singleton cp)) true
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq cp e
+++++
apply SWP.Dec.F.mem_2 in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
unfold InCP.
simpl in *.
left.
rewrite <- SWP.singleton_equal_add in Hmem.
apply SWP.Dec.F.mem_2 in Hmem.

*****
Hmem : S.In e (S.singleton cp)
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq cp e
+++++
apply SWP.Dec.F.singleton_1.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
unfold InCP.
simpl in *.
left.
rewrite <- SWP.singleton_equal_add in Hmem.
apply SWP.Dec.F.mem_2 in Hmem.
apply SWP.Dec.F.singleton_1.

*****
Hmem : S.In e (S.singleton cp)
cp : cartesianPower positive (S O)
e : S\.elt
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
S.In e (S.singleton cp)
+++++
assumption.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.

*****
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (e : S.elt) (cp : cartesianPower positive (S (S m))) (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
+++++
intros e cp Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.

*****
Hmem : eq (S.mem e (CPToSS cp)) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
apply InCPOK.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.

*****
Hmem : eq (S.mem e (CPToSS cp)) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
rewrite CPToSSHdTl in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.

*****
Hmem : eq (S.mem e (S.add (headCP cp) (CPToSS (tailCP cp)))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
rewrite SWP.Dec.F.add_b in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.

*****
Hmem : eq (orb (SWP.Dec.F.eqb (headCP cp) e) (S.mem e (CPToSS (tailCP cp))))\n true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
rewrite <- SWP.Dec.F.singleton_b in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.

*****
Hmem : eq\n (orb (S.mem e (S.singleton (headCP cp)))\n (S.mem e (CPToSS (tailCP cp)))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
apply orb_true_iff in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.

*****
Hmem : or (eq (S.mem e (S.singleton (headCP cp))) true)\n (eq (S.mem e (CPToSS (tailCP cp))) true)
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
elim Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.

*****
Hmem : or (eq (S.mem e (S.singleton (headCP cp))) true)\n (eq (S.mem e (CPToSS (tailCP cp))) true)
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem e (S.singleton (headCP cp))) true, or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
clear Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.

*****
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem e (S.singleton (headCP cp))) true, or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
intro Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.

*****
Hmem : eq (S.mem e (S.singleton (headCP cp))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
left.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.
left.

*****
Hmem : eq (S.mem e (S.singleton (headCP cp))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq e (headCP cp)
+++++
apply SWP.Dec.F.mem_2 in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.
left.
apply SWP.Dec.F.mem_2 in Hmem.

*****
Hmem : S.In e (S.singleton (headCP cp))
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq e (headCP cp)
+++++
apply SWP.Dec.F.singleton_1 in Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.
left.
apply SWP.Dec.F.mem_2 in Hmem.
apply SWP.Dec.F.singleton_1 in Hmem.

*****
Hmem : eq (headCP cp) e
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq e (headCP cp)
+++++
intuition.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.

*****
Hmem : or (eq (S.mem e (S.singleton (headCP cp))) true)\n (eq (S.mem e (CPToSS (tailCP cp))) true)
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem e (CPToSS (tailCP cp))) true, or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
clear Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.

*****
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : eq (S.mem e (CPToSS (tailCP cp))) true, or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
intro Hmem.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.

*****
Hmem : eq (S.mem e (CPToSS (tailCP cp))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq e (headCP cp)) (InCP e (tailCP cp))
+++++
right.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.
right.

*****
Hmem : eq (S.mem e (CPToSS (tailCP cp))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e (tailCP cp)
+++++
apply IHm.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.
intros e cp Hmem.
apply InCPOK.
rewrite CPToSSHdTl in Hmem.
rewrite SWP.Dec.F.add_b in Hmem.
rewrite <- SWP.Dec.F.singleton_b in Hmem.
apply orb_true_iff in Hmem.
elim Hmem.
clear Hmem.
intro Hmem.
right.
apply IHm.

*****
Hmem : eq (S.mem e (CPToSS (tailCP cp))) true
cp : cartesianPower positive (S (S m))
e : S\.elt
IHm : forall (e : S.elt) (cp : cartesianPower positive (S m))\n (_ : eq (S.mem e (CPToSS cp)) true), InCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem e (CPToSS (tailCP cp))) true
+++++
assumption.
-----
Lemma memCPToSSOK {m : nat} : forall e (cp : cartesianPower positive (S m)), S.mem e (CPToSS cp) = true -> InCP e cp.
Proof.
induction m.

*****

*****

+++++
Qed.
-----
Lemma CPToSSOKAux {m m' : nat} :\n  forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s,\n  S.Equal (CPToSS cp) s ->\n  memCPAux m' cp' s = true ->\n  InCP e cp' ->\n  InCP e cp.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.

*****
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) (e : positive) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), InCP e cp
+++++
Proof.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.

*****
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) (e : positive) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), InCP e cp
+++++
induction m'.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S O))) (e : positive) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), InCP e cp
+++++
induction m; intros cp cp' e s HEq Hmem HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.

*****
HIn : InCP e cp'
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
unfold InCP in *.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.

*****
HIn : In e (CPToList cp')
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
In e (CPToList cp)
+++++
simpl in *.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem : eq (andb (S.mem (fst cp') s) (S.mem (snd cp') s)) true
HEq : S.Equal (S.add (fst cp) (S.add (snd cp) S.empty)) s
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
apply andb_true_iff in Hmem.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem : and (eq (S.mem (fst cp') s) true) (eq (S.mem (snd cp') s) true)
HEq : S.Equal (S.add (fst cp) (S.add (snd cp) S.empty)) s
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
destruct Hmem as [Hmem1 Hmem2].
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq (S.mem (snd cp') s) true
Hmem1 : eq (S.mem (fst cp') s) true
HEq : S.Equal (S.add (fst cp) (S.add (snd cp) S.empty)) s
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq (S.mem (snd cp') s) true
Hmem1 : eq (S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty))) true
HEq : S.Equal (S.add (fst cp) (S.add (snd cp) S.empty)) s
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq (S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty))) true
Hmem1 : eq (S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
rewrite SWP.Dec.F.add_b in Hmem1.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq (S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty))) true
Hmem1 : eq\n (orb (SWP.Dec.F.eqb (fst cp) (fst cp'))\n (S.mem (fst cp') (S.add (snd cp) S.empty))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq (S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty))) true
Hmem1 : eq\n (orb (S.mem (fst cp') (S.singleton (fst cp)))\n (S.mem (fst cp') (S.add (snd cp) S.empty))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq (S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty))) true
Hmem1 : eq\n (orb (S.mem (fst cp') (S.singleton (fst cp)))\n (S.mem (fst cp') (S.singleton (snd cp)))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
rewrite SWP.Dec.F.add_b in Hmem2.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq\n (orb (SWP.Dec.F.eqb (fst cp) (snd cp'))\n (S.mem (snd cp') (S.add (snd cp) S.empty))) true
Hmem1 : eq\n (orb (S.mem (fst cp') (S.singleton (fst cp)))\n (S.mem (fst cp') (S.singleton (snd cp)))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq\n (orb (S.mem (snd cp') (S.singleton (fst cp)))\n (S.mem (snd cp') (S.add (snd cp) S.empty))) true
Hmem1 : eq\n (orb (S.mem (fst cp') (S.singleton (fst cp)))\n (S.mem (fst cp') (S.singleton (snd cp)))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq\n (orb (S.mem (snd cp') (S.singleton (fst cp)))\n (S.mem (snd cp') (S.singleton (snd cp)))) true
Hmem1 : eq\n (orb (S.mem (fst cp') (S.singleton (fst cp)))\n (S.mem (fst cp') (S.singleton (snd cp)))) true
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
apply orb_true_iff in Hmem1.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : eq\n (orb (S.mem (snd cp') (S.singleton (fst cp)))\n (S.mem (snd cp') (S.singleton (snd cp)))) true
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
apply orb_true_iff in Hmem2.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.

*****
HIn : or (eq (fst cp') e) (or (eq (snd cp') e) False)
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
elim HIn; clear HIn; intro HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.

*****
HIn : eq (fst cp') e
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
subst.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.

*****
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) (fst cp')) (or (eq (snd cp) (fst cp')) False)
+++++
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.

*****
HIn : or (eq (snd cp') e) False
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
elim HIn; clear HIn; intro HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.

*****
HIn : eq (snd cp') e
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
subst.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.

*****
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) (snd cp')) (or (eq (snd cp) (snd cp')) False)
+++++
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.

*****
HIn : False
Hmem2 : or (eq (S.mem (snd cp') (S.singleton (fst cp))) true)\n (eq (S.mem (snd cp') (S.singleton (snd cp))) true)
Hmem1 : or (eq (S.mem (fst cp') (S.singleton (fst cp))) true)\n (eq (S.mem (fst cp') (S.singleton (snd cp))) true)
s : S\.t
e : positive
cp,cp' : cartesianPower positive (S (S O))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
or (eq (fst cp) e) (or (eq (snd cp) e) False)
+++++
intuition.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.

*****
HIn : InCP e cp'
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
elim HIn; clear HIn; intro HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.

*****
HIn : eq (headCP cp') e
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.

*****
HIn : eq (headCP cp') e
Hmem : eq (memCPAux O cp' (CPToSS cp)) true
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
subst.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.

*****
Hmem : eq (memCPAux O cp' (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).

*****
HIn : InCP (headCP cp') cp'
Hmem : eq (memCPAux O cp' (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.

*****
Hmem : eq (S.mem (headCP cp') (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
apply memCPToSSOK.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.

*****
Hmem : eq (S.mem (headCP cp') (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp') (CPToSS cp)) true
+++++
assumption.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.

*****
HIn : In e\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (headCP cp) (IHn (tailCP cp))) O (tailCP cp'))
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
unfold InCP in HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.

*****
HIn : In e\n (nat_rect\n (fun n : nat =>\n forall _ : cartesianPower positive (S n), list positive)\n (fun cp : cartesianPower positive (S O) => cons cp nil)\n (fun (n : nat)\n (IHn : forall _ : cartesianPower positive (S n), list positive)\n (cp : cartesianPower positive (S (S n))) =>\n cons (headCP cp) (IHn (tailCP cp))) O (tailCP cp'))
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
simpl in HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.

*****
HIn : or (eq (snd cp') e) False
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
elim HIn; clear HIn; intro HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.

*****
HIn : eq (snd cp') e
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.

*****
HIn : eq (snd cp') e
Hmem : eq (memCPAux O cp' (CPToSS cp)) true
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
subst.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.

*****
Hmem : eq (memCPAux O cp' (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (snd cp') cp
+++++
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).

*****
HIn : InCP (tailCP cp') cp'
Hmem : eq (memCPAux O cp' (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (snd cp') cp
+++++
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.

*****
Hmem : eq (S.mem (tailCP cp') (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (snd cp') cp
+++++
apply memCPToSSOK.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.

*****
Hmem : eq (S.mem (tailCP cp') (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (snd cp') (CPToSS cp)) true
+++++
assumption.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.

*****
HIn : False
Hmem : eq (memCPAux O cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S O))
cp : cartesianPower positive (S (S (S m)))
IHm : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S O))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux O cp' s) true) (_ : InCP e cp'), \nInCP e cp
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
intuition.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.

*****
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S (S m')))) (e : positive) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCPAux (S m') cp' s) true) (_ : InCP e cp'), InCP e cp
+++++
intros cp cp' e s HEq Hmem HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.

*****
HIn : InCP e cp'
Hmem : eq (memCPAux (S m') cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
apply InCPOK in HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.

*****
HIn : or (eq e (headCP cp')) (InCP e (tailCP cp'))
Hmem : eq (memCPAux (S m') cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
elim HIn; clear HIn; intro HIn.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.

*****
HIn : eq e (headCP cp')
Hmem : eq (memCPAux (S m') cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
subst.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.

*****
Hmem : eq (memCPAux (S m') cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.

*****
Hmem : eq (memCPAux (S m') cp' (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).

*****
HIn : InCP (headCP cp') cp'
Hmem : eq (memCPAux (S m') cp' (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.

*****
Hmem : eq (S.mem (headCP cp') (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP (headCP cp') cp
+++++
apply memCPToSSOK.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.

*****
Hmem : eq (S.mem (headCP cp') (CPToSS cp)) true
s : S\.t
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (S.mem (headCP cp') (CPToSS cp)) true
+++++
assumption.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.

*****
HIn : InCP e (tailCP cp')
Hmem : eq (memCPAux (S m') cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
InCP e cp
+++++
apply IHm' with (tailCP cp') s; try assumption.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
apply IHm' with (tailCP cp') s; try assumption.

*****
HIn : InCP e (tailCP cp')
Hmem : eq (memCPAux (S m') cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
e : positive
cp' : cartesianPower positive (S (S (S m')))
cp : cartesianPower positive (S (S m))
IHm' : forall (cp : cartesianPower positive (S (S m)))\n (cp' : cartesianPower positive (S (S m'))) (e : positive) \n (s : S.t) (_ : S.Equal (CPToSS cp) s)\n (_ : eq (memCPAux m' cp' s) true) (_ : InCP e cp'), \nInCP e cp
m,m' : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCPAux m' (tailCP cp') s) true
+++++
apply memCPAuxTlOK; assumption.
-----
Lemma CPToSSOKAux {m m' : nat} : forall (cp : cartesianPower positive (S (S m))) (cp' : cartesianPower positive (S (S m'))) e s, S.Equal (CPToSS cp) s -> memCPAux m' cp' s = true -> InCP e cp' -> InCP e cp.
Proof.
induction m'.
induction m; intros cp cp' e s HEq Hmem HIn.
unfold InCP in *.
simpl in *.
apply andb_true_iff in Hmem.
destruct Hmem as [Hmem1 Hmem2].
assert (HmemEq : S.mem (fst cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (fst cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem1; clear HmemEq.
assert (HmemEq : S.mem (snd cp') (S.add (fst cp) (S.add (snd cp) S.empty)) = S.mem (snd cp') s) by (apply SWP.FM.mem_m; trivial); simpl in *;rewrite <- HmemEq in Hmem2; clear HmemEq; clear HEq.
rewrite SWP.Dec.F.add_b in Hmem1.
rewrite <- SWP.Dec.F.singleton_b in Hmem1.
assert (HmemEq : S.mem (fst cp') (S.add (snd cp) S.empty) = S.mem (fst cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem1; clear HmemEq.
rewrite SWP.Dec.F.add_b in Hmem2.
rewrite <- SWP.Dec.F.singleton_b in Hmem2.
assert (HmemEq : S.mem (snd cp') (S.add (snd cp) S.empty) = S.mem (snd cp') (S.singleton (snd cp))) by (apply SWP.FM.mem_m; trivial; apply SWP.singleton_equal_add); simpl in *;rewrite HmemEq in Hmem2; clear HmemEq.
apply orb_true_iff in Hmem1.
apply orb_true_iff in Hmem2.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem1; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
elim HIn; clear HIn; intro HIn.
subst.
elim Hmem2; clear Hmem1; clear Hmem2; intro HEq; apply SWP.Dec.F.mem_2 in HEq; apply SWP.Dec.F.singleton_1 in HEq; auto.
intuition.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
unfold InCP in HIn.
simpl in HIn.
elim HIn; clear HIn; intro HIn.
assert (HmemEq : memCPAux 0 cp' (CPToSS cp) = memCPAux 0 cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm.
subst.
assert (HIn : InCP (tailCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK 0 cp' (CPToSS cp) (tailCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
intuition.
intros cp cp' e s HEq Hmem HIn.
apply InCPOK in HIn.
elim HIn; clear HIn; intro HIn.
subst.
assert (HmemEq : memCPAux (S m') cp' (CPToSS cp) = memCPAux (S m') cp' s) by (apply memCPAuxProperOK; trivial); rewrite <- HmemEq in Hmem; clear HmemEq; clear HEq; clear IHm'.
assert (HIn : InCP (headCP cp') cp') by (unfold InCP; simpl; auto).
assert (H := memCPAuxOK (S m') cp' (CPToSS cp) (headCP cp') Hmem HIn); clear HIn; clear Hmem; rename H into Hmem.
apply memCPToSSOK.
assumption.
apply IHm' with (tailCP cp') s; try assumption.
apply memCPAuxTlOK; assumption.

*****

*****

+++++
Qed.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s,\n  S.Equal (CPToSS cp) s ->\n  memCP cp' s = true ->\n  incl (CPToList cp') (CPToList cp).
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp cp' : cartesianPower positive (S (S (S n)))) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCP cp' s) true), incl (CPToList cp') (CPToList cp)
+++++
Proof.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp cp' : cartesianPower positive (S (S (S n)))) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCP cp' s) true), incl (CPToList cp') (CPToList cp)
+++++
unfold incl.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.
unfold incl.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp cp' : cartesianPower positive (S (S (S n)))) (s : S.t) (_ : S.Equal (CPToSS cp) s) (_ : eq (memCP cp' s) true) (a : positive) (_ : In a (CPToList cp')), In a (CPToList cp)
+++++
intros cp cp' s HEq Hmem e HIn.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.
unfold incl.
intros cp cp' s HEq Hmem e HIn.

*****
HIn : In e (CPToList cp')
e : positive
Hmem : eq (memCP cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
cp,cp' : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
In e (CPToList cp)
+++++
assert (H := CPToSSOKAux cp cp' e s HEq Hmem).
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.
unfold incl.
intros cp cp' s HEq Hmem e HIn.
assert (H := CPToSSOKAux cp cp' e s HEq Hmem).

*****
H : forall _ : InCP e cp', InCP e cp
HIn : In e (CPToList cp')
e : positive
Hmem : eq (memCP cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
cp,cp' : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
In e (CPToList cp)
+++++
unfold InCP in H.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.
unfold incl.
intros cp cp' s HEq Hmem e HIn.
assert (H := CPToSSOKAux cp cp' e s HEq Hmem).
unfold InCP in H.

*****
H : forall _ : In e (CPToList cp'), In e (CPToList cp)
HIn : In e (CPToList cp')
e : positive
Hmem : eq (memCP cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
cp,cp' : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
In e (CPToList cp)
+++++
apply H.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.
unfold incl.
intros cp cp' s HEq Hmem e HIn.
assert (H := CPToSSOKAux cp cp' e s HEq Hmem).
unfold InCP in H.
apply H.

*****
H : forall _ : In e (CPToList cp'), In e (CPToList cp)
HIn : In e (CPToList cp')
e : positive
Hmem : eq (memCP cp' s) true
HEq : S.Equal (CPToSS cp) s
s : S\.t
cp,cp' : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
In e (CPToList cp')
+++++
assumption.
-----
Lemma CPToSSOK : forall (cp cp' : cartesianPower positive (S (S (S n)))) s, S.Equal (CPToSS cp) s -> memCP cp' s = true -> incl (CPToList cp') (CPToList cp).
Proof.
unfold incl.
intros cp cp' s HEq Hmem e HIn.
assert (H := CPToSSOKAux cp cp' e s HEq Hmem).
unfold InCP in H.
apply H.
assumption.

*****

*****

+++++
Qed.
-----
Lemma CoappDupPerm {m : nat} :\n  forall (cp : cartesianPower positive m),\n  ~ List.NoDup (CPToList cp) ->\n  exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive m) (_ : not (NoDup (CPToList cp))), ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
Proof.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive m) (_ : not (NoDup (CPToList cp))), ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
intros cp HDup.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.

*****
HDup : not (NoDup (CPToList cp))
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
apply NotNoDupDup in HDup.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.

*****
HDup : ex\n (fun e : positive =>\n ex\n (fun l1 : list positive =>\n ex\n (fun l2 : list positive =>\n and (eq (CPToList cp) (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
try apply Pos.eq_dec.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.

*****
HDup : ex\n (fun e : positive =>\n ex\n (fun l1 : list positive =>\n ex\n (fun l2 : list positive =>\n and (eq (CPToList cp) (Datatypes.app l1 (cons e l2)))\n (In e (Datatypes.app l1 l2)))))
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].

*****
HIn : In e (Datatypes.app l1 l2)
HEq : eq (CPToList cp) (Datatypes.app l1 (cons e l2))
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
apply in_split in HIn.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.

*****
HIn : ex\n (fun l3 : list positive =>\n ex\n (fun l4 : list positive =>\n eq (Datatypes.app l1 l2) (Datatypes.app l3 (cons e l4))))
HEq : eq (CPToList cp) (Datatypes.app l1 (cons e l2))
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
destruct HIn as [l3 [l4 HEq']].
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].

*****
HEq' : eq (Datatypes.app l1 l2) (Datatypes.app l3 (cons e l4))
l3,l4 : list positive
HEq : eq (CPToList cp) (Datatypes.app l1 (cons e l2))
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 l2))\n (Datatypes.app l1 (cons e l2))
HEq' : eq (Datatypes.app l1 l2) (Datatypes.app l3 (cons e l4))
l3,l4 : list positive
HEq : eq (CPToList cp) (Datatypes.app l1 (cons e l2))
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
rewrite <- HEq in HPerm.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 l2)) (CPToList cp)
HEq' : eq (Datatypes.app l1 l2) (Datatypes.app l3 (cons e l4))
l3,l4 : list positive
HEq : eq (CPToList cp) (Datatypes.app l1 (cons e l2))
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
clear HEq.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 l2)) (CPToList cp)
HEq' : eq (Datatypes.app l1 l2) (Datatypes.app l3 (cons e l4))
l1,l2,l3,l4 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
rewrite HEq' in HPerm.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l3 (cons e l4)))\n (CPToList cp)
HEq' : eq (Datatypes.app l1 l2) (Datatypes.app l3 (cons e l4))
l1,l2,l3,l4 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
clear HEq'.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l3 (cons e l4)))\n (CPToList cp)
l1,l2,l3,l4 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
clear l1.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l3 (cons e l4)))\n (CPToList cp)
l2,l3,l4 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
clear l2.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l3 (cons e l4)))\n (CPToList cp)
l3,l4 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
rename l3 into l1.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 (cons e l4)))\n (CPToList cp)
l1,l4 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
rename l4 into l2.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.

*****
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 (cons e l2)))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).

*****
HPerm' : Permutation.Permutation (cons e (Datatypes.app l1 l2))\n (Datatypes.app l1 (cons e l2))
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 (cons e l2)))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
apply (Permutation.perm_skip e) in HPerm'.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.

*****
HPerm' : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (cons e (Datatypes.app l1 (cons e l2)))
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 (cons e l2)))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).

*****
HPerm'' : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (CPToList cp)
HPerm' : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (cons e (Datatypes.app l1 (cons e l2)))
HPerm : Permutation.Permutation (cons e (Datatypes.app l1 (cons e l2)))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
clear HPerm.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
clear HPerm.

*****
HPerm'' : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (CPToList cp)
HPerm' : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (cons e (Datatypes.app l1 (cons e l2)))
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
clear HPerm'.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
clear HPerm.
clear HPerm'.

*****
HPerm'' : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
rename HPerm'' into HPerm.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
clear HPerm.
clear HPerm'.
rename HPerm'' into HPerm.

*****
HPerm : Permutation.Permutation (cons e (cons e (Datatypes.app l1 l2)))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
rewrite <- CPLOK with (e :: e :: l1 ++ l2) e in HPerm.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
clear HPerm.
clear HPerm'.
rename HPerm'' into HPerm.
rewrite <- CPLOK with (e :: e :: l1 ++ l2) e in HPerm.

*****
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (Datatypes.app l1 l2))) e))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp)))
+++++
exists e.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
clear HPerm.
clear HPerm'.
rename HPerm'' into HPerm.
rewrite <- CPLOK with (e :: e :: l1 ++ l2) e in HPerm.
exists e.

*****
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (Datatypes.app l1 l2))) e))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun l : list positive => Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e)) (CPToList cp))
+++++
exists (l1 ++ l2).
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.
try apply Pos.eq_dec.
destruct HDup as [e [l1 [l2 [HEq HIn]]]].
apply in_split in HIn.
destruct HIn as [l3 [l4 HEq']].
assert (HPerm := Permutation.Permutation_middle l1 l2 e).
rewrite <- HEq in HPerm.
clear HEq.
rewrite HEq' in HPerm.
clear HEq'.
clear l1.
clear l2.
rename l3 into l1.
rename l4 into l2.
assert (HPerm' := Permutation.Permutation_middle l1 l2 e).
apply (Permutation.perm_skip e) in HPerm'.
assert (HPerm'' := Permutation.perm_trans HPerm' HPerm).
clear HPerm.
clear HPerm'.
rename HPerm'' into HPerm.
rewrite <- CPLOK with (e :: e :: l1 ++ l2) e in HPerm.
exists e.
exists (l1 ++ l2).

*****
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (Datatypes.app l1 l2))) e))\n (CPToList cp)
l1,l2 : list positive
e : positive
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (CPToList (ListToCP (cons e (cons e (Datatypes.app l1 l2))) e)) (CPToList cp)
+++++
assumption.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.

*****
HDup : not (NoDup (CPToList cp))
cp : cartesianPower positive m
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall x y : positive, sumbool (eq x y) (not (eq x y))
+++++
try apply Pos.eq_dec.
-----
Lemma CoappDupPerm {m : nat} : forall (cp : cartesianPower positive m), ~ List.NoDup (CPToList cp) -> exists e, exists l, Permutation.Permutation (CPToList (ListToCP (e :: e :: l) e)) (CPToList cp).
Proof.
intros cp HDup.
apply NotNoDupDup in HDup.

*****

*****

+++++
Qed.
-----
Lemma CoappDupAux {m : nat} :\n  forall (cp : cartesianPower positive (S (S (S m)))),\n  ~ List.NoDup (CPToList cp) ->\n  exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))),\n  Permutation.Permutation (CPToList cp') (CPToList cp) /\ headCP cp' = e /\ headCP (tailCP cp') = e.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (_ : not (NoDup (CPToList cp))), ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
Proof.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.

*****
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S m)))) (_ : not (NoDup (CPToList cp))), ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
intros cp H.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.

*****
H : not (NoDup (CPToList cp))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
apply CoappDupPerm in H.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.

*****
H : ex\n (fun e : positive =>\n ex\n (fun l : list positive =>\n Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e l)) e)) \n (CPToList cp)))
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
destruct H as [e[l HPerm]].
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].

*****
HPerm : Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e))\n (CPToList cp)
l : list positive
e : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
assert (Hl := Permutation.Permutation_length HPerm).
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).

*****
Hl : eq (length (CPToList (ListToCP (cons e (cons e l)) e)))\n (length (CPToList cp))
HPerm : Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e))\n (CPToList cp)
l : list positive
e : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
rewrite CPLOK in Hl.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.

*****
Hl : eq (length (cons e (cons e l))) (length (CPToList cp))
HPerm : Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e))\n (CPToList cp)
l : list positive
e : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
rewrite <- lengthOfCPToList in Hl.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.

*****
Hl : eq (length (cons e (cons e l))) (S (S (S m)))
HPerm : Permutation.Permutation (CPToList (ListToCP (cons e (cons e l)) e))\n (CPToList cp)
l : list positive
e : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
induction l.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.

*****
Hl : eq (length (cons e (cons e nil))) (S (S (S m)))
HPerm : Permutation.Permutation (CPToList (ListToCP (cons e (cons e nil)) e))\n (CPToList cp)
e : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
try (simpl in Hl; discriminate).
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.

*****
IHl : forall\n (_ : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e l)) e)) \n (CPToList cp))\n (_ : eq (length (cons e (cons e l))) (S (S (S m)))),\nex\n (fun e : positive =>\n ex\n (fun _ : list positive =>\n ex\n (fun m' : nat =>\n ex\n (fun cp' : cartesianPower positive (S (S (S m'))) =>\n and (Permutation.Permutation (CPToList cp') (CPToList cp))\n (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
try (simpl in Hl; discriminate).
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).

*****
IHl : forall\n (_ : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e l)) e)) \n (CPToList cp))\n (_ : eq (length (cons e (cons e l))) (S (S (S m)))),\nex\n (fun e : positive =>\n ex\n (fun _ : list positive =>\n ex\n (fun m' : nat =>\n ex\n (fun cp' : cartesianPower positive (S (S (S m'))) =>\n and (Permutation.Permutation (CPToList cp') (CPToList cp))\n (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
clear IHl.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun e : positive => ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
+++++
exists e.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun _ : list positive => ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e)))))
+++++
exists (a :: l).
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun m' : nat => ex (fun cp' : cartesianPower positive (S (S (S m'))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))
+++++
exists (length l).
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ex (fun cp' : cartesianPower positive (S (S (S (length l)))) => and (Permutation.Permutation (CPToList cp') (CPToList cp)) (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e)))
+++++
exists (ListToCP (e :: e :: a :: l) e).
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
and (Permutation.Permutation (CPToList (ListToCP (cons e (cons e (cons a l))) e)) (CPToList cp)) (and (eq (headCP (ListToCP (cons e (cons e (cons a l))) e)) e) (eq (headCP (tailCP (ListToCP (cons e (cons e (cons a l))) e))) e))
+++++
split.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).
split.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (CPToList (ListToCP (cons e (cons e (cons a l))) e)) (CPToList cp)
+++++
try assumption.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).
split.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
and (eq (headCP (ListToCP (cons e (cons e (cons a l))) e)) e) (eq (headCP (tailCP (ListToCP (cons e (cons e (cons a l))) e))) e)
+++++
try assumption.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).
split.
try assumption.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
and (eq (headCP (ListToCP (cons e (cons e (cons a l))) e)) e) (eq (headCP (tailCP (ListToCP (cons e (cons e (cons a l))) e))) e)
+++++
simpl.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).
split.
try assumption.
simpl.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
and (eq e e) (eq e e)
+++++
split.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).
split.
try assumption.
simpl.
split.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq e e
+++++
reflexivity.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.
try (simpl in Hl; discriminate).
clear IHl.
exists e.
exists (a :: l).
exists (length l).
exists (ListToCP (e :: e :: a :: l) e).
split.
try assumption.
simpl.
split.

*****
Hl : eq (length (cons e (cons e (cons a l)))) (S (S (S m)))
HPerm : Permutation.Permutation\n (CPToList (ListToCP (cons e (cons e (cons a l))) e)) \n (CPToList cp)
l : list positive
e,a : positive
cp : cartesianPower positive (S (S (S m)))
m : nat
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq e e
+++++
reflexivity.
-----
Lemma CoappDupAux {m : nat} : forall (cp : cartesianPower positive (S (S (S m)))), ~ List.NoDup (CPToList cp) -> exists e, exists (l : list positive), exists m', exists (cp' : cartesianPower positive (S (S (S m')))), Permutation.Permutation (CPToList cp') (CPToList cp) /\\ headCP cp' = e /\\ headCP (tailCP cp') = e.
Proof.
intros cp H.
apply CoappDupPerm in H.
destruct H as [e[l HPerm]].
assert (Hl := Permutation.Permutation_length HPerm).
rewrite CPLOK in Hl.
rewrite <- lengthOfCPToList in Hl.
induction l.

*****

*****

+++++
Qed.
-----
Lemma CoappDup : forall cp interp,\n  ~ List.NoDup (CPToList cp) ->\n  app coinc (interp_CP cp interp).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S n)))) (interp : forall _ : positive, COINCpoint) (_ : not (NoDup (CPToList cp))), app coinc (interp_CP cp interp)
+++++
Proof.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S n)))) (interp : forall _ : positive, COINCpoint) (_ : not (NoDup (CPToList cp))), app coinc (interp_CP cp interp)
+++++
intros cp interp H.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.

*****
H : not (NoDup (CPToList cp))
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply CoappDupAux in H.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.

*****
H : ex\n (fun e : positive =>\n ex\n (fun _ : list positive =>\n ex\n (fun m' : nat =>\n ex\n (fun cp' : cartesianPower positive (S (S (S m'))) =>\n and (Permutation.Permutation (CPToList cp') (CPToList cp))\n (and (eq (headCP cp') e) (eq (headCP (tailCP cp')) e))))))
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].

*****
Hsnd : eq (headCP (tailCP cp')) e
Hfst : eq (headCP cp') e
HPerm : Permutation.Permutation (CPToList cp') (CPToList cp)
cp' : cartesianPower positive (S (S (S m')))
m' : nat
l : list positive
e : positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
assert (Hmn := Permutation.Permutation_length HPerm).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).

*****
Hmn : eq (length (CPToList cp')) (length (CPToList cp))
Hsnd : eq (headCP (tailCP cp')) e
Hfst : eq (headCP cp') e
HPerm : Permutation.Permutation (CPToList cp') (CPToList cp)
cp' : cartesianPower positive (S (S (S m')))
m' : nat
l : list positive
e : positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.

*****
Hmn : eq (length (CPToList cp')) (length (CPToList cp))
Hsnd : eq (headCP (tailCP cp')) e
Hfst : eq (headCP cp') e
HPerm : Permutation.Permutation (map interp (CPToList cp'))\n (map interp (CPToList cp))
cp' : cartesianPower positive (S (S (S m')))
m' : nat
l : list positive
e : positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
do 2 (rewrite <- interp_CPOK in HPerm).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).

*****
Hmn : eq (length (CPToList cp')) (length (CPToList cp))
Hsnd : eq (headCP (tailCP cp')) e
Hfst : eq (headCP cp') e
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
cp' : cartesianPower positive (S (S (S m')))
m' : nat
l : list positive
e : positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
do 2 (rewrite <- lengthOfCPToList in Hmn).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).

*****
Hmn : eq (S (S (S m'))) (S (S (S n)))
Hsnd : eq (headCP (tailCP cp')) e
Hfst : eq (headCP cp') e
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
cp' : cartesianPower positive (S (S (S m')))
m' : nat
l : list positive
e : positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
do 3 (apply eq_add_S in Hmn).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).

*****
Hmn : eq m' n
Hsnd : eq (headCP (tailCP cp')) e
Hfst : eq (headCP cp') e
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
cp' : cartesianPower positive (S (S (S m')))
m' : nat
l : list positive
e : positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
subst.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
apply PermCoincOK with (interp_CP cp' interp).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
try assumption.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
clear HPerm.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app_2_n coinc (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp)
+++++
rewrite Hsnd.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).
rewrite Hsnd.

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app_2_n coinc (interp (headCP cp')) (interp (headCP cp')) (interp_CP (tailCP (tailCP cp')) interp)
+++++
apply coinc_bd.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (headCP (interp_CP cp' interp)) (interp (headCP cp'))
+++++
rewrite <- interp_CPHdOK.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).
rewrite <- interp_CPHdOK.

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (interp_CP (headCPbis cp') interp) (interp (headCP cp'))
+++++
reflexivity.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (headCP (tailCP (interp_CP cp' interp))) (interp (headCP (tailCP cp')))
+++++
rewrite <- interp_CPTlOK.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).
rewrite <- interp_CPTlOK.

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (headCP (interp_CP (tailCP cp') interp)) (interp (headCP (tailCP cp')))
+++++
rewrite <- interp_CPHdOK.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).
rewrite <- interp_CPTlOK.
rewrite <- interp_CPHdOK.

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (interp_CP (headCPbis (tailCP cp')) interp) (interp (headCP (tailCP cp')))
+++++
reflexivity.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (tailCP (tailCP (interp_CP cp' interp))) (interp_CP (tailCP (tailCP cp')) interp)
+++++
do 2 (rewrite <- interp_CPTlOK).
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).
try assumption.
clear HPerm.
apply app_2_n_app with (interp (headCP cp')) (interp (headCP (tailCP cp'))) (interp_CP (tailCP (tailCP cp')) interp).
do 2 (rewrite <- interp_CPTlOK).

*****
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (interp_CP (tailCP (tailCP cp')) interp) (interp_CP (tailCP (tailCP cp')) interp)
+++++
reflexivity.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hsnd : eq (headCP (tailCP cp')) (headCP cp')
cp' : cartesianPower positive (S (S (S n)))
l : list positive
interp : forall _ : positive, COINCpoint
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (CPToList (interp_CP cp' interp)) (CPToList (interp_CP cp interp))
+++++
try assumption.
-----
Lemma CoappDup : forall cp interp, ~ List.NoDup (CPToList cp) -> app coinc (interp_CP cp interp).
Proof.
intros cp interp H.
apply CoappDupAux in H.
destruct H as [e [l [m' [cp' [HPerm [Hfst Hsnd]]]]]].
assert (Hmn := Permutation.Permutation_length HPerm).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
do 2 (rewrite <- lengthOfCPToList in Hmn).
do 3 (apply eq_add_S in Hmn).
subst.
apply PermCoincOK with (interp_CP cp' interp).

*****

*****

+++++
Qed.
-----
Lemma collect_coincs :\nforall cp ss interp,\n  app coinc (interp_CP cp interp) ->\n  ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S n)))) (ss : SS.t) (interp : forall _ : positive, COINCpoint) (_ : app coinc (interp_CP cp interp)) (_ : ss_ok ss interp), ss_ok (SS.add (CPToSS cp) ss) interp
+++++
Proof.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S n)))) (ss : SS.t) (interp : forall _ : positive, COINCpoint) (_ : app coinc (interp_CP cp interp)) (_ : ss_ok ss interp), ss_ok (SS.add (CPToSS cp) ss) interp
+++++
intros cp ss interp HCoapp HSS.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.

*****
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
ss_ok (SS.add (CPToSS cp) ss) interp
+++++
unfold ss_ok.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.

*****
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (s : SS.elt) (_ : eq (SS.mem s (SS.add (CPToSS cp) ss)) true) (cp : cartesianPower positive (S (S (S n)))) (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
+++++
intros s Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.

*****
Hs : eq (SS.mem s (SS.add (CPToSS cp) ss)) true
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S (S n)))) (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
+++++
intros cp' Hmem.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
Hs : eq (SS.mem s (SS.add (CPToSS cp) ss)) true
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
Hs : SS.In s (SS.add (CPToSS cp) ss)
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply SSWEqP.MP.Dec.F.add_iff in Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
Hs : or (S.Equal (CPToSS cp) s) (SS.In s ss)
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
elim Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
Hs : or (S.Equal (CPToSS cp) s) (SS.In s ss)
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : S.Equal (CPToSS cp) s, app coinc (interp_CP cp' interp)
+++++
clear Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : S.Equal (CPToSS cp) s, app coinc (interp_CP cp' interp)
+++++
intro Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.

*****
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).

*****
HDup : or (NoDup (CPToList cp')) (not (NoDup (CPToList cp')))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
elim HDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.

*****
HDup : or (NoDup (CPToList cp')) (not (NoDup (CPToList cp')))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : NoDup (CPToList cp'), app coinc (interp_CP cp' interp)
+++++
clear HDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.

*****
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : NoDup (CPToList cp'), app coinc (interp_CP cp' interp)
+++++
intro HDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.

*****
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).

*****
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).

*****
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (length (CPToList cp')) (length (CPToList cp))
+++++
do 2 (rewrite <- lengthOfCPToList).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
do 2 (rewrite <- lengthOfCPToList).

*****
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (S (S (S n))) (S (S (S n)))
+++++
reflexivity.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).

*****
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
idtac.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.

*****
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).

*****
HPerm : Permutation.Permutation (CPToList cp') (CPToList cp)
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.

*****
HPerm : Permutation.Permutation (map interp (CPToList cp'))\n (map interp (CPToList cp))
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
do 2 (rewrite <- interp_CPOK in HPerm).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hincl : incl (CPToList cp') (CPToList cp)
HDup : NoDup (CPToList cp')
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
clear HDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
clear HDup.

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hincl : incl (CPToList cp') (CPToList cp)
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
clear Hincl.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
clear HDup.
clear Hincl.

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hlength : eq (length (CPToList cp')) (length (CPToList cp))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
clear Hlength.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
clear HDup.
clear Hincl.
clear Hlength.

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp' interp))\n (CPToList (interp_CP cp interp))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply Permutation.Permutation_sym in HPerm.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
clear HDup.
clear Hincl.
clear Hlength.
apply Permutation.Permutation_sym in HPerm.

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp interp))\n (CPToList (interp_CP cp' interp))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply PermCoincOK with (interp_CP cp interp).
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
clear HDup.
clear Hincl.
clear Hlength.
apply Permutation.Permutation_sym in HPerm.
apply PermCoincOK with (interp_CP cp interp).

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp interp))\n (CPToList (interp_CP cp' interp))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp interp)
+++++
assumption.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
assert (Hincl := CPToSSOK cp cp' s Hs Hmem).
assert (Hlength : length (CPToList cp') = length (CPToList cp)).
idtac.
assert (HPerm := NoDupOK (CPToList cp') (CPToList cp) Hincl Hlength HDup).
apply Permutation.Permutation_map with positive COINCpoint interp (CPToList cp') (CPToList cp) in HPerm.
do 2 (rewrite <- interp_CPOK in HPerm).
clear HDup.
clear Hincl.
clear Hlength.
apply Permutation.Permutation_sym in HPerm.
apply PermCoincOK with (interp_CP cp interp).

*****
HPerm : Permutation.Permutation (CPToList (interp_CP cp interp))\n (CPToList (interp_CP cp' interp))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (CPToList (interp_CP cp interp)) (CPToList (interp_CP cp' interp))
+++++
assumption.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.

*****
HDup : or (NoDup (CPToList cp')) (not (NoDup (CPToList cp')))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : not (NoDup (CPToList cp')), app coinc (interp_CP cp' interp)
+++++
clear HDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.

*****
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : not (NoDup (CPToList cp')), app coinc (interp_CP cp' interp)
+++++
intro HDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.

*****
HDup : not (NoDup (CPToList cp'))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply CoappDup.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
assert (HDup := NoDup_dec (CPToList cp') Pos.eq_dec).
elim HDup.
clear HDup.
intro HDup.
apply CoappDup.

*****
HDup : not (NoDup (CPToList cp'))
Hs : S.Equal (CPToSS cp) s
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
not (NoDup (CPToList cp'))
+++++
assumption.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
Hs : or (S.Equal (CPToSS cp) s) (SS.In s ss)
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : SS.In s ss, app coinc (interp_CP cp' interp)
+++++
clear Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.

*****
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall _ : SS.In s ss, app coinc (interp_CP cp' interp)
+++++
intro Hs.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.

*****
Hs : SS.In s ss
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : ss_ok ss interp
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
unfold ss_ok in HSS.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
unfold ss_ok in HSS.

*****
Hs : SS.In s ss
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app coinc (interp_CP cp' interp)
+++++
apply HSS with s.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
unfold ss_ok in HSS.
apply HSS with s.

*****
Hs : SS.In s ss
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s ss) true
+++++
try assumption.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
unfold ss_ok in HSS.
apply HSS with s.
try assumption.

*****
Hs : SS.In s ss
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (SS.mem s ss) true
+++++
apply SSWEqP.MP.Dec.F.mem_1.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
unfold ss_ok in HSS.
apply HSS with s.
try assumption.
apply SSWEqP.MP.Dec.F.mem_1.

*****
Hs : SS.In s ss
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
SS.In s ss
+++++
assumption.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.
clear Hs.
intro Hs.
unfold ss_ok in HSS.
apply HSS with s.

*****
Hs : SS.In s ss
Hmem : eq (memCP cp' s) true
cp' : cartesianPower positive (S (S (S n)))
s : SS\.elt
HSS : forall (s : SS.elt) (_ : eq (SS.mem s ss) true)\n (cp : cartesianPower positive (S (S (S n))))\n (_ : eq (memCP cp s) true), app coinc (interp_CP cp interp)
HCoapp : app coinc (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
ss : SS\.t
cp : cartesianPower positive (S (S (S n)))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
eq (memCP cp' s) true
+++++
try assumption.
-----
Lemma collect_coincs : forall cp ss interp, app coinc (interp_CP cp interp) -> ss_ok ss interp -> ss_ok (SS.add (CPToSS cp) ss) interp.
Proof.
intros cp ss interp HCoapp HSS.
unfold ss_ok.
intros s Hs.
intros cp' Hmem.
apply SSWEqP.MP.Dec.F.mem_2 in Hs.
apply SSWEqP.MP.Dec.F.add_iff in Hs.
elim Hs.

*****

*****

+++++
Qed.
-----
Lemma collect_wds :\n  forall cp st interp,\n  app wd (interp_CP cp interp) ->\n  st_ok st interp -> st_ok (STadd cp st) interp.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S n))) (st : STt) (interp : forall _ : positive, COINCpoint) (_ : app wd (interp_CP cp interp)) (_ : st_ok st interp), st_ok (STadd cp st) interp
+++++
Proof.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (cp : cartesianPower positive (S (S n))) (st : STt) (interp : forall _ : positive, COINCpoint) (_ : app wd (interp_CP cp interp)) (_ : st_ok st interp), st_ok (STadd cp st) interp
+++++
intros cp st interp HWd HST.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.

*****
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
st_ok (STadd cp st) interp
+++++
unfold st_ok.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.

*****
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall (t : tST) (_ : eq (STmem t (STadd cp st)) true), app wd (interp_CP t interp)
+++++
intros cp' Hmem.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.

*****
Hmem : eq (STmem cp' (STadd cp st)) true
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
apply STadd_iff in Hmem.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.

*****
Hmem : or (eqST cp cp') (eq (STmem cp' st) true)
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].

*****
Hmem : eqST cp cp'
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).

*****
Hcp : Permutation.Permutation (CPToList cp) (sets.PosSort.sort (CPToList cp))
Hmem : eqST cp cp'
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp) (sets.PosSort.sort (CPToList cp))
Hmem : eqST cp cp'
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
apply eqListOK in Hmem.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp) (sets.PosSort.sort (CPToList cp))
Hmem : eq (sets.PosSort.sort (CPToList cp)) (sets.PosSort.sort (CPToList cp'))
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
rewrite Hmem in Hcp.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.
rewrite Hmem in Hcp.

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp)\n (sets.PosSort.sort (CPToList cp'))
Hmem : eq (sets.PosSort.sort (CPToList cp)) (sets.PosSort.sort (CPToList cp'))
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
app wd (interp_CP cp' interp)
+++++
apply PermWdOK with (interp_CP cp interp); try assumption.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.
rewrite Hmem in Hcp.
apply PermWdOK with (interp_CP cp interp); try assumption.

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp)\n (sets.PosSort.sort (CPToList cp'))
Hmem : eq (sets.PosSort.sort (CPToList cp)) (sets.PosSort.sort (CPToList cp'))
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (CPToList (interp_CP cp interp)) (CPToList (interp_CP cp' interp))
+++++
do 2 (rewrite interp_CPOK).
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.
rewrite Hmem in Hcp.
apply PermWdOK with (interp_CP cp interp); try assumption.
do 2 (rewrite interp_CPOK).

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp)\n (sets.PosSort.sort (CPToList cp'))
Hmem : eq (sets.PosSort.sort (CPToList cp)) (sets.PosSort.sort (CPToList cp'))
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (map interp (CPToList cp)) (map interp (CPToList cp'))
+++++
apply Permutation.Permutation_map.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.
rewrite Hmem in Hcp.
apply PermWdOK with (interp_CP cp interp); try assumption.
do 2 (rewrite interp_CPOK).
apply Permutation.Permutation_map.

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp)\n (sets.PosSort.sort (CPToList cp'))
Hmem : eq (sets.PosSort.sort (CPToList cp)) (sets.PosSort.sort (CPToList cp'))
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (CPToList cp) (CPToList cp')
+++++
transitivity (PosSort.sort (CPToList cp')); try assumption.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.
rewrite Hmem in Hcp.
apply PermWdOK with (interp_CP cp interp); try assumption.
do 2 (rewrite interp_CPOK).
apply Permutation.Permutation_map.
transitivity (PosSort.sort (CPToList cp')); try assumption.

*****
Hcp' : Permutation.Permutation (CPToList cp')\n (sets.PosSort.sort (CPToList cp'))
Hcp : Permutation.Permutation (CPToList cp)\n (sets.PosSort.sort (CPToList cp'))
Hmem : eq (sets.PosSort.sort (CPToList cp)) (sets.PosSort.sort (CPToList cp'))
cp' : tST
HST : st_ok st interp
HWd : app wd (interp_CP cp interp)
interp : forall _ : positive, COINCpoint
st : STt
cp : cartesianPower positive (S (S n))
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
Permutation.Permutation (sort (CPToList cp')) (CPToList cp')
+++++
apply Permutation.Permutation_sym; assumption.
-----
Lemma collect_wds : forall cp st interp, app wd (interp_CP cp interp) -> st_ok st interp -> st_ok (STadd cp st) interp.
Proof.
intros cp st interp HWd HST.
unfold st_ok.
intros cp' Hmem.
apply STadd_iff in Hmem.
elim Hmem; clear Hmem; intro Hmem; [|apply HST; apply Hmem].
assert (Hcp := sets.PosSort.Permuted_sort (CPToList cp)).
assert (Hcp' := sets.PosSort.Permuted_sort (CPToList cp')).
apply eqListOK in Hmem.
rewrite Hmem in Hcp.
apply PermWdOK with (interp_CP cp interp); try assumption.
do 2 (rewrite interp_CPOK).
apply Permutation.Permutation_map.
transitivity (PosSort.sort (CPToList cp')); try assumption.
apply Permutation.Permutation_sym; assumption.

*****

*****

+++++
Qed.
-----
Definition list_assoc_inv :=\n  (fix list_assoc_inv_rec (A:Type) (B:Set)\n                          (eq_dec:forall e1 e2:B, {e1 = e2} + {e1 <> e2})\n                          (lst : list (prodT A B)) {struct lst} : B -> A -> A :=\n  fun (key:B) (default:A) =>\n    match lst with\n      | nil => default\n      | cons (pairT v e) l =>\n        match eq_dec e key with\n          | left _ => v\n          | right _ => list_assoc_inv_rec A B eq_dec l key default\n        end\n    end).
-----
Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.
-----
Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall p1 p2 : positive, sumbool (eq p1 p2) (not (eq p1 p2))
+++++
Proof.
-----
Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.
Proof.

*****
COT : Coinc_theory AR COP
COP : Coinc_predicates AR
AR : Arity
*****
forall p1 p2 : positive, sumbool (eq p1 p2) (not (eq p1 p2))
+++++
decide equality.
-----
Lemma positive_dec : forall (p1 p2:positive), {p1=p2}+{~p1=p2}.
Proof.
decide equality.

*****

*****

+++++
Defined.
-----
Definition interp (lvar : list (COINCpoint * positive)) (Default : COINCpoint) : positive -> COINCpoint := \n  fun p => list_assoc_inv COINCpoint positive positive_dec lvar p Default.
-----
End Coinc_refl.
-----
Ltac add_to_distinct_list x xs :=\n  match xs with\n    | nil     => constr:(x::xs)\n    | x::_    => fail 1\n    | ?y::?ys => let zs := add_to_distinct_list x ys in constr:(y::zs)\n  end.
-----
Ltac collect_points_list Tpoint xs :=\n  match goal with\n    | N : Tpoint |- _ => let ys := add_to_distinct_list N xs in\n                           collect_points_list Tpoint ys\n    | _               => xs\n  end.
-----
Ltac collect_points Tpoint := collect_points_list Tpoint (@nil Tpoint).
-----
Ltac number_aux Tpoint lvar cpt :=\n  match constr:(lvar) with\n    | nil          => constr:(@nil (prodT Tpoint positive))\n    | cons ?H ?T => let scpt := eval vm_compute in (Pos.succ cpt) in\n                    let lvar2 := number_aux Tpoint T scpt in\n                      constr:(cons (@pairT  Tpoint positive H cpt) lvar2)\n  end.
-----
Ltac number Tpoint lvar := number_aux Tpoint lvar (1%positive).
-----
Ltac build_numbered_points_list Tpoint := let lvar := collect_points Tpoint in number Tpoint lvar.
-----
Ltac List_assoc Tpoint elt lst :=\n  match constr:(lst) with\n    | nil => fail\n    | (cons (@pairT Tpoint positive ?X1 ?X2) ?X3) =>\n      match constr:(elt = X1) with\n        | (?X1 = ?X1) => constr:(X2)\n        | _ => List_assoc Tpoint elt X3\n      end\n  end.
-----
Definition Tagged P : Prop := P.
-----
Lemma PropToTagged : forall P : Prop, P -> Tagged P.
-----
Lemma PropToTagged : forall P : Prop, P -> Tagged P.

*****

*****
forall (P : Prop) (_ : P), Tagged P
+++++
Proof.
-----
Lemma PropToTagged : forall P : Prop, P -> Tagged P.
Proof.

*****

*****
forall (P : Prop) (_ : P), Tagged P
+++++
trivial.
-----
Lemma PropToTagged : forall P : Prop, P -> Tagged P.
Proof.
trivial.

*****

*****

+++++
Qed.
-----
