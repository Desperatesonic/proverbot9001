From Coq Require Import Bool.
-----
Require Import Coq.Bool.Sumbool.
-----
Require Import Coq.NArith.NArith.
-----
Require Import Coq.NArith.Ndigits.
-----
Require Import Coq.NArith.Ndec.
-----
Require Import Map.
-----
Require Import Fset.
-----
Require Import Mapaxioms.
-----
Require Import Mapiter.
-----
Require Import Lsort.
-----
Require Import Mapsubset.
-----
From Coq Require Import List.
-----
Section MapFoldResults.
-----
Variable A : Type.
-----
Variable M : Type.
-----
Variable neutral : M.
-----
Variable op : M -> M -> M.
-----
Variable nleft : forall a:M, op neutral a = a.
-----
Variable nright : forall a:M, op a neutral = a.
-----
Variable assoc : forall a b c:M, op (op a b) c = op a (op b c).
-----
Lemma MapFold_ext :\n   forall (f:ad -> A -> M) (m m':Map A),\n     eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m m' : Map A) (_ : eqmap A m m'), eq (MapFold A M neutral op f m) (MapFold A M neutral op f m')
+++++
Proof.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m m' : Map A) (_ : eqmap A m m'), eq (MapFold A M neutral op f m) (MapFold A M neutral op f m')
+++++
intros.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op f m) (MapFold A M neutral op f m')
+++++
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m)) (MapFold A M neutral op f m')
+++++
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m'))
+++++
cut (alist_of_Map A m = alist_of_Map A m').
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (alist_of_Map A m) (alist_of_Map A m'), eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m'))
+++++
intro.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
intro.

*****
H0 : eq (alist_of_Map A m) (alist_of_Map A m')
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m)) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m'))
+++++
rewrite H0.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
intro.
rewrite H0.

*****
H0 : eq (alist_of_Map A m) (alist_of_Map A m')
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m')) (fold_right (fun (r : prod ad A) (m : M) => let (a, y) := r in op (f a y) m) neutral (alist_of_Map A m'))
+++++
reflexivity.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (alist_of_Map A m) (alist_of_Map A m')
+++++
apply alist_canonical.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (alist_semantics A (alist_of_Map A m)) (alist_semantics A (alist_of_Map A m'))
+++++
unfold eqmap in H.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.
unfold eqmap in H.

*****
H : eqm A (MapGet A m) (MapGet A m')
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (alist_semantics A (alist_of_Map A m)) (alist_semantics A (alist_of_Map A m'))
+++++
apply eqm_trans with (f' := MapGet A m).
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.
unfold eqmap in H.
apply eqm_trans with (f' := MapGet A m).

*****
H : eqm A (MapGet A m) (MapGet A m')
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (alist_semantics A (alist_of_Map A m)) (MapGet A m)
+++++
apply eqm_sym.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.
unfold eqmap in H.
apply eqm_trans with (f' := MapGet A m).
apply eqm_sym.

*****
H : eqm A (MapGet A m) (MapGet A m')
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (MapGet A m) (alist_semantics A (alist_of_Map A m))
+++++
apply alist_of_Map_semantics.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.
unfold eqmap in H.
apply eqm_trans with (f' := MapGet A m).

*****
H : eqm A (MapGet A m) (MapGet A m')
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (MapGet A m) (alist_semantics A (alist_of_Map A m'))
+++++
apply eqm_trans with (f' := MapGet A m').
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.
unfold eqmap in H.
apply eqm_trans with (f' := MapGet A m).
apply eqm_trans with (f' := MapGet A m').

*****
H : eqm A (MapGet A m) (MapGet A m')
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (MapGet A m) (MapGet A m')
+++++
assumption.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.
unfold eqmap in H.
apply eqm_trans with (f' := MapGet A m).
apply eqm_trans with (f' := MapGet A m').

*****
H : eqm A (MapGet A m) (MapGet A m')
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqm A (MapGet A m') (alist_semantics A (alist_of_Map A m'))
+++++
apply alist_of_Map_semantics.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
alist_sorted_2 A (alist_of_Map A m)
+++++
apply alist_of_Map_sorts2.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').
apply alist_canonical.

*****
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
alist_sorted_2 A (alist_of_Map A m')
+++++
apply alist_of_Map_sorts2.
-----
Lemma MapFold_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> MapFold _ _ neutral op f m = MapFold _ _ neutral op f m'.
Proof.
intros.
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m).
rewrite (MapFold_as_fold A M neutral op assoc nleft nright f m').
cut (alist_of_Map A m = alist_of_Map A m').

*****

*****

+++++
Qed.
-----
Lemma MapFold_ext_f_1 :\n   forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad),\n     (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) ->\n     MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f (pf a) y) (g (pf a) y)), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op g pf m)
+++++
Proof.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f (pf a) y) (g (pf a) y)), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op g pf m)
+++++
simple induction m.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A (M0 A) a) (Some y)), eq (f (pf a) y) (g (pf a) y)), eq (MapFold1 A M neutral op f pf (M0 A)) (MapFold1 A M neutral op g pf (M0 A))
+++++
trivial.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a1 : ad) (y : A) (_ : eq (MapGet A (M1 A a a0) a1) (Some y)), eq (f (pf a1) y) (g (pf a1) y)), eq (MapFold1 A M neutral op f pf (M1 A a a0)) (MapFold1 A M neutral op g pf (M1 A a a0))
+++++
simpl in |- *.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
simpl in |- *.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a1 : ad) (y : A) (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)), eq (f (pf a1) y) (g (pf a1) y)), eq (f (pf a) a0) (g (pf a) a0)
+++++
intros.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
simpl in |- *.
intros.

*****
H : forall (a1 : ad) (y : A)\n (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)),\neq (f (pf a1) y) (g (pf a1) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf a) a0) (g (pf a) a0)
+++++
apply H.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
simpl in |- *.
intros.
apply H.

*****
H : forall (a1 : ad) (y : A)\n (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)),\neq (f (pf a1) y) (g (pf a1) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (if N.eqb a a then Some a0 else None) (Some a0)
+++++
rewrite (Neqb_correct a).
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
simpl in |- *.
intros.
apply H.
rewrite (Neqb_correct a).

*****
H : forall (a1 : ad) (y : A)\n (_ : eq (if N.eqb a a1 then Some a0 else None) (Some y)),\neq (f (pf a1) y) (g (pf a1) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (Some a0) (Some a0)
+++++
reflexivity.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (_ : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f (pf a) y) (g (pf a) y)), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op g pf m)) (m0 : Map A) (_ : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)), eq (f (pf a) y) (g (pf a) y)), eq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)) (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m m0) a) (Some y)), eq (f (pf a) y) (g (pf a) y)), eq (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op g pf (M2 A m m0))
+++++
intros.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.

*****
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A m0 m1)) (MapFold1 A M neutral op g pf (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 A M neutral op g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).

*****
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 A M neutral op g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op g (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 A M neutral op g (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op g (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
reflexivity.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)), eq (f (pf (N.succ_double a)) y) (g (pf (N.succ_double a)) y)
+++++
intros.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).
intros.

*****
H2 : eq (MapGet A m1 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf (N.succ_double a)) y) (g (pf (N.succ_double a)) y)
+++++
apply H1.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).
intros.
apply H1.

*****
H2 : eq (MapGet A m1 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A (M2 A m0 m1) (N.succ_double a)) (Some y)
+++++
rewrite MapGet_M2_bit_0_1.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).
intros.
apply H1.
rewrite MapGet_M2_bit_0_1.

*****
H2 : eq (MapGet A m1 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m1 (N.div2 (N.succ_double a))) (Some y)
+++++
rewrite Ndouble_plus_one_div2.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).
intros.
apply H1.
rewrite MapGet_M2_bit_0_1.
rewrite Ndouble_plus_one_div2.

*****
H2 : eq (MapGet A m1 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m1 a) (Some y)
+++++
assumption.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 f g (fun a0:ad => pf (Ndouble_plus_one a0))).
intros.
apply H1.
rewrite MapGet_M2_bit_0_1.

*****
H2 : eq (MapGet A m1 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd (N.succ_double a)) true
+++++
apply Ndouble_plus_one_bit0.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).

*****
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)), eq (f (pf (N.double a)) y) (g (pf (N.double a)) y)
+++++
intros.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
intros.

*****
H2 : eq (MapGet A m0 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf (N.double a)) y) (g (pf (N.double a)) y)
+++++
apply H1.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
intros.
apply H1.

*****
H2 : eq (MapGet A m0 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A (M2 A m0 m1) (N.double a)) (Some y)
+++++
rewrite MapGet_M2_bit_0_0.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
intros.
apply H1.
rewrite MapGet_M2_bit_0_0.

*****
H2 : eq (MapGet A m0 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m0 (N.div2 (N.double a))) (Some y)
+++++
rewrite Ndouble_div2.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
intros.
apply H1.
rewrite MapGet_M2_bit_0_0.
rewrite Ndouble_div2.

*****
H2 : eq (MapGet A m0 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m0 a) (Some y)
+++++
assumption.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f g (fun a0:ad => pf (Ndouble a0))).
intros.
apply H1.
rewrite MapGet_M2_bit_0_0.

*****
H2 : eq (MapGet A m0 a) (Some y)
y : A
a : ad
H1 : forall (a : ad) (y : A) (_ : eq (MapGet A (M2 A m0 m1) a) (Some y)),\neq (f (pf a) y) (g (pf a) y)
pf : forall _ : ad, ad
f,g : forall (_ : ad) (_ : A), M
H0 : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m1 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op g pf m1)
m1 : Map A
H : forall (f g : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m0 a) (Some y)),\n eq (f (pf a) y) (g (pf a) y)),\neq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op g pf m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd (N.double a)) false
+++++
apply Ndouble_bit0.
-----
Lemma MapFold_ext_f_1 : forall (m:Map A) (f g:ad -> A -> M) (pf:ad -> ad), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f (pf a) y = g (pf a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op g pf m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_ext_f :\n   forall (f g:ad -> A -> M) (m:Map A),\n     (forall (a:ad) (y:A), MapGet _ m a = Some y -> f a y = g a y) ->\n     MapFold _ _ neutral op f m = MapFold _ _ neutral op g m.
-----
Lemma MapFold_ext_f : forall (f g:ad -> A -> M) (m:Map A), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f a y = g a y) -> MapFold _ _ neutral op f m = MapFold _ _ neutral op g m.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f g : forall (_ : ad) (_ : A), M) (m : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f a y) (g a y)), eq (MapFold A M neutral op f m) (MapFold A M neutral op g m)
+++++
Proof.
-----
Lemma MapFold_ext_f : forall (f g:ad -> A -> M) (m:Map A), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f a y = g a y) -> MapFold _ _ neutral op f m = MapFold _ _ neutral op g m.
Proof.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f g : forall (_ : ad) (_ : A), M) (m : Map A) (_ : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)), eq (f a y) (g a y)), eq (MapFold A M neutral op f m) (MapFold A M neutral op g m)
+++++
intros.
-----
Lemma MapFold_ext_f : forall (f g:ad -> A -> M) (m:Map A), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f a y = g a y) -> MapFold _ _ neutral op f m = MapFold _ _ neutral op g m.
Proof.
intros.

*****
H : forall (a : ad) (y : A) (_ : eq (MapGet A m a) (Some y)),\neq (f a y) (g a y)
m : Map A
f,g : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op f m) (MapFold A M neutral op g m)
+++++
exact (MapFold_ext_f_1 m f g (fun a0:ad => a0) H).
-----
Lemma MapFold_ext_f : forall (f g:ad -> A -> M) (m:Map A), (forall (a:ad) (y:A), MapGet _ m a = Some y -> f a y = g a y) -> MapFold _ _ neutral op f m = MapFold _ _ neutral op g m.
Proof.
intros.
exact (MapFold_ext_f_1 m f g (fun a0:ad => a0) H).

*****

*****

+++++
Qed.
-----
Lemma MapFold1_as_Fold_1 :\n   forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad),\n     (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) ->\n     MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f' pf' m)
+++++
Proof.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f' pf' m)
+++++
simple induction m.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)), eq (MapFold1 A M neutral op f pf (M0 A)) (MapFold1 A M neutral op f' pf' (M0 A))
+++++
trivial.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a1 : ad) (y : A), eq (f (pf a1) y) (f' (pf' a1) y)), eq (MapFold1 A M neutral op f pf (M1 A a a0)) (MapFold1 A M neutral op f' pf' (M1 A a a0))
+++++
intros.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.

*****
H : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M1 A a a0)) (MapFold1 A M neutral op f' pf' (M1 A a a0))
+++++
simpl in |- *.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
a0 : A
a : ad
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf a) a0) (f' (pf' a) a0)
+++++
apply H.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.

*****
m : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (_ : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f' pf' m)) (m0 : Map A) (_ : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)), eq (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op f' pf' m0)) (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad) (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)), eq (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f' pf' (M2 A m m0))
+++++
intros.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.

*****
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A m0 m1)) (MapFold1 A M neutral op f' pf' (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.double a0)) m0) (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.succ_double a0)) m1))
+++++
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).

*****
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.double a0)) m0) (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.succ_double a0)) m1))
+++++
rewrite (H0 f f' (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => pf' (Ndouble_plus_one a0))).
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).
rewrite (H0 f f' (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => pf' (Ndouble_plus_one a0))).

*****
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.double a0)) m0) (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.succ_double a0)) m1)) (op (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.double a0)) m0) (MapFold1 A M neutral op f' (fun a0 : ad => pf' (N.succ_double a0)) m1))
+++++
reflexivity.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).
rewrite (H0 f f' (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => pf' (Ndouble_plus_one a0))).

*****
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (y : A), eq (f (pf (N.succ_double a)) y) (f' (pf' (N.succ_double a)) y)
+++++
intros.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).
rewrite (H0 f f' (fun a0:ad => pf (Ndouble_plus_one a0)) (fun a0:ad => pf' (Ndouble_plus_one a0))).
intros.

*****
y : A
a : ad
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf (N.succ_double a)) y) (f' (pf' (N.succ_double a)) y)
+++++
apply H1.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).

*****
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (y : A), eq (f (pf (N.double a)) y) (f' (pf' (N.double a)) y)
+++++
intros.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H f f' (fun a0:ad => pf (Ndouble a0)) (fun a0:ad => pf' (Ndouble a0))).
intros.

*****
y : A
a : ad
H1 : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)
pf,pf' : forall _ : ad, ad
f,f' : forall (_ : ad) (_ : A), M
H0 : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m1)\n (MapFold1 A M neutral op f' pf' m1)
m1 : Map A
H : forall (f f' : forall (_ : ad) (_ : A), M) (pf pf' : forall _ : ad, ad)\n (_ : forall (a : ad) (y : A), eq (f (pf a) y) (f' (pf' a) y)),\neq (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f' pf' m0)
m,m0 : Map A
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf (N.double a)) y) (f' (pf' (N.double a)) y)
+++++
apply H1.
-----
Lemma MapFold1_as_Fold_1 : forall (m:Map A) (f f':ad -> A -> M) (pf pf':ad -> ad), (forall (a:ad) (y:A), f (pf a) y = f' (pf' a) y) -> MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f' pf' m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold1_as_Fold :\n   forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A),\n     MapFold1 _ _ neutral op f pf m =\n     MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.
-----
Lemma MapFold1_as_Fold : forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A), MapFold1 _ _ neutral op f pf m = MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (m : Map A), eq (MapFold1 A M neutral op f pf m) (MapFold A M neutral op (fun (a : ad) (y : A) => f (pf a) y) m)
+++++
Proof.
-----
Lemma MapFold1_as_Fold : forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A), MapFold1 _ _ neutral op f pf m = MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.
Proof.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (m : Map A), eq (MapFold1 A M neutral op f pf m) (MapFold A M neutral op (fun (a : ad) (y : A) => f (pf a) y) m)
+++++
intros.
-----
Lemma MapFold1_as_Fold : forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A), MapFold1 _ _ neutral op f pf m = MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.
Proof.
intros.

*****
m : Map A
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf m) (MapFold A M neutral op (fun (a : ad) (y : A) => f (pf a) y) m)
+++++
unfold MapFold in |- *.
-----
Lemma MapFold1_as_Fold : forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A), MapFold1 _ _ neutral op f pf m = MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.
Proof.
intros.
unfold MapFold in |- *.

*****
m : Map A
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op (fun (a : ad) (y : A) => f (pf a) y) (fun a : ad => a) m)
+++++
apply MapFold1_as_Fold_1.
-----
Lemma MapFold1_as_Fold : forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A), MapFold1 _ _ neutral op f pf m = MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.
Proof.
intros.
unfold MapFold in |- *.
apply MapFold1_as_Fold_1.

*****
m : Map A
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (y : A), eq (f (pf a) y) (f (pf a) y)
+++++
trivial.
-----
Lemma MapFold1_as_Fold : forall (f:ad -> A -> M) (pf:ad -> ad) (m:Map A), MapFold1 _ _ neutral op f pf m = MapFold _ _ neutral op (fun (a:ad) (y:A) => f (pf a) y) m.
Proof.
intros.
unfold MapFold in |- *.
apply MapFold1_as_Fold_1.
trivial.

*****

*****

+++++
Qed.
-----
Lemma MapFold1_ext :\n   forall (f:ad -> A -> M) (m m':Map A),\n     eqmap A m m' ->\n     forall pf:ad -> ad,\n       MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m m' : Map A) (_ : eqmap A m m') (pf : forall _ : ad, ad), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f pf m')
+++++
Proof.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
Proof.

*****
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m m' : Map A) (_ : eqmap A m m') (pf : forall _ : ad, ad), eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f pf m')
+++++
intros.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
Proof.
intros.

*****
pf : forall _ : ad, ad
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f pf m')
+++++
rewrite MapFold1_as_Fold.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
Proof.
intros.
rewrite MapFold1_as_Fold.

*****
pf : forall _ : ad, ad
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op (fun (a : ad) (y : A) => f (pf a) y) m) (MapFold1 A M neutral op f pf m')
+++++
rewrite MapFold1_as_Fold.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
Proof.
intros.
rewrite MapFold1_as_Fold.
rewrite MapFold1_as_Fold.

*****
pf : forall _ : ad, ad
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op (fun (a : ad) (y : A) => f (pf a) y) m) (MapFold A M neutral op (fun (a : ad) (y : A) => f (pf a) y) m')
+++++
apply MapFold_ext.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
Proof.
intros.
rewrite MapFold1_as_Fold.
rewrite MapFold1_as_Fold.
apply MapFold_ext.

*****
pf : forall _ : ad, ad
H : eqmap A m m'
m,m' : Map A
f : forall (_ : ad) (_ : A), M
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A m m'
+++++
assumption.
-----
Lemma MapFold1_ext : forall (f:ad -> A -> M) (m m':Map A), eqmap A m m' -> forall pf:ad -> ad, MapFold1 _ _ neutral op f pf m = MapFold1 _ _ neutral op f pf m'.
Proof.
intros.
rewrite MapFold1_as_Fold.
rewrite MapFold1_as_Fold.
apply MapFold_ext.
assumption.

*****

*****

+++++
Qed.
-----
Variable comm : forall a b:M, op a b = op b a.
-----
Lemma MapFold_Put_disjoint_1 :\n   forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) \n     (a1 a2:ad) (y1 y2:A),\n     Nxor a1 a2 = Npos p ->\n     MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) =\n     op (f (pf a1) y1) (f (pf a2) y2).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p)), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
Proof.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p)), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simple induction p.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.

*****
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p)), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a1) y1) (f (pf a2) y2))) (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos (xI p))), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 (xI p))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intros.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.

*****
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 (xI p0))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.

*****
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
elim (sumbool_of_bool (Nbit0 a1)).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).

*****
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a1) true, eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intro H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.double (N.div2 a2))) y2) (f (pf (N.succ_double (N.div2 a1))) y1)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.double (N.div2 a2))) y2) (f (pf a1) y1)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a2) y2) (f (pf a1) y1)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
apply comm.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a2
+++++
change (Nbit0 a2 = negb true) in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb true)
+++++
rewrite <- H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.
rewrite <- H1.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (N.odd a1))
+++++
rewrite (Nneg_bit0_2 _ _ _ H0).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.
rewrite <- H1.
rewrite (Nneg_bit0_2 _ _ _ H0).

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (negb (N.odd a2)))
+++++
rewrite negb_elim.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.
rewrite <- H1.
rewrite (Nneg_bit0_2 _ _ _ H0).
rewrite negb_elim.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (N.odd a2)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a1
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).

*****
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a1) false, eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intro H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.double (N.div2 a1))) y1) (f (pf (N.succ_double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf (N.succ_double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf a2) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a2
+++++
change (Nbit0 a2 = negb false) in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb false)
+++++
rewrite <- H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.
rewrite <- H1.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (N.odd a1))
+++++
rewrite (Nneg_bit0_2 _ _ _ H0).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.
rewrite <- H1.
rewrite (Nneg_bit0_2 _ _ _ H0).

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (negb (N.odd a2)))
+++++
rewrite negb_elim.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.
rewrite <- H1.
rewrite (Nneg_bit0_2 _ _ _ H0).
rewrite negb_elim.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (N.odd a2)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xI p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a1
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.

*****
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p)), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a1) y1) (f (pf a2) y2))) (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos (xO p))), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 (xO p))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.

*****
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p)), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a1) y1) (f (pf a2) y2))) (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos (xO p))), eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p) else M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intros.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.

*****
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) else M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
elim (sumbool_of_bool (Nbit0 a1)).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).

*****
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a1) true, eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) else M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intro H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) else M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op neutral (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite nleft.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.succ_double (N.div2 a1))) y1) (f (pf (N.succ_double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf (N.succ_double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf a2) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a2
+++++
unfold Nodd.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double_plus_one.
unfold Nodd.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) true
+++++
rewrite <- (Nsame_bit0 _ _ _ H0).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double_plus_one.
rewrite Ndiv2_double_plus_one.
unfold Nodd.
rewrite <- (Nsame_bit0 _ _ _ H0).

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a1) true
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double_plus_one.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a1
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.lxor (N.div2 a1) (N.div2 a2)) (Npos p0)
+++++
rewrite <- Nxor_div2.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite <- Nxor_div2.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.div2 (N.lxor a1 a2)) (Npos p0)
+++++
rewrite H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nleft.
rewrite (H f (fun a0:ad => pf (Ndouble_plus_one a0)) ( Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite <- Nxor_div2.
rewrite H0.

*****
H1 : eq (N.odd a1) true
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.div2 (Npos (xO p0))) (Npos p0)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).

*****
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a1) false, eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) else M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intro H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M0 A) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) else M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite H1.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0) (M0 A))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0)) neutral) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite nright.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) (MapPut1 A (N.div2 a1) y1 (N.div2 a2) y2 p0)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.double (N.div2 a1))) y1) (f (pf (N.double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf (N.double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double.
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf a2) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double.
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a2
+++++
unfold Neven.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double.
rewrite Ndiv2_double.
unfold Neven.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) false
+++++
rewrite <- (Nsame_bit0 _ _ _ H0).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double.
rewrite Ndiv2_double.
unfold Neven.
rewrite <- (Nsame_bit0 _ _ _ H0).

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a1) false
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite Ndiv2_double.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a1
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.lxor (N.div2 a1) (N.div2 a2)) (Npos p0)
+++++
rewrite <- Nxor_div2.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite <- Nxor_div2.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.div2 (N.lxor a1 a2)) (Npos p0)
+++++
rewrite H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
simpl in |- *.
intros.
elim (sumbool_of_bool (Nbit0 a1)).
intro H1.
rewrite H1.
simpl in |- *.
rewrite nright.
rewrite (H f (fun a0:ad => pf (Ndouble a0)) (Ndiv2 a1) (Ndiv2 a2) y1 y2).
rewrite <- Nxor_div2.
rewrite H0.

*****
H1 : eq (N.odd a1) false
H0 : eq (N.lxor a1 a2) (Npos (xO p0))
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
H : forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad)\n (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos p0)),\neq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p0))\n (op (f (pf a1) y1) (f (pf a2) y2))
p,p0 : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.div2 (Npos (xO p0))) (Npos p0)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.

*****
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (pf : forall _ : ad, ad) (a1 a2 : ad) (y1 y2 : A) (_ : eq (N.lxor a1 a2) (Npos xH)), eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 xH)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intros.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.

*****
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 xH)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.

*****
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
elim (sumbool_of_bool (Nbit0 a1)).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).

*****
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a1) true, eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intro H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.double (N.div2 a2))) y2) (f (pf (N.succ_double (N.div2 a1))) y1)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a2) y2) (f (pf (N.succ_double (N.div2 a1))) y1)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a2) y2) (f (pf a1) y1)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
apply comm.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a1
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a2
+++++
change (Nbit0 a2 = negb true) in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb true)
+++++
rewrite <- H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.
rewrite <- H0.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (N.odd a1))
+++++
rewrite (Nneg_bit0_1 _ _ H).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.
rewrite <- H0.
rewrite (Nneg_bit0_1 _ _ H).

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (negb (N.odd a2)))
+++++
rewrite negb_elim.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
change (Nbit0 a2 = negb true) in |- *.
rewrite <- H0.
rewrite (Nneg_bit0_1 _ _ H).
rewrite negb_elim.

*****
H0 : eq (N.odd a1) true
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (N.odd a2)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).

*****
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a1) false, eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
intro H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (if N.odd a1 then M2 A (M1 A (N.div2 a2) y2) (M1 A (N.div2 a1) y1) else M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (M1 A (N.div2 a1) y1) (M1 A (N.div2 a2) y2))) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf (N.double (N.div2 a1))) y1) (f (pf (N.succ_double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf (N.succ_double (N.div2 a2))) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a1) y1) (f (pf a2) y2)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a2
+++++
change (Nbit0 a2 = negb false) in |- *.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb false)
+++++
rewrite <- H0.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.
rewrite <- H0.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (N.odd a1))
+++++
rewrite (Nneg_bit0_1 _ _ H).
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.
rewrite <- H0.
rewrite (Nneg_bit0_1 _ _ H).

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (negb (negb (N.odd a2)))
+++++
rewrite negb_elim.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.
rewrite Ndiv2_double_plus_one.
change (Nbit0 a2 = negb false) in |- *.
rewrite <- H0.
rewrite (Nneg_bit0_1 _ _ H).
rewrite negb_elim.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (N.odd a2) (N.odd a2)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.
intros.
simpl in |- *.
elim (sumbool_of_bool (Nbit0 a1)).
intro H0.
rewrite H0.
simpl in |- *.
rewrite Ndiv2_double.

*****
H0 : eq (N.odd a1) false
H : eq (N.lxor a1 a2) (Npos xH)
y1,y2 : A
a1,a2 : ad
pf : forall _ : ad, ad
f : forall (_ : ad) (_ : A), M
p : positive
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a1
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_1 : forall (p:positive) (f:ad -> A -> M) (pf:ad -> ad) (a1 a2:ad) (y1 y2:A), Nxor a1 a2 = Npos p -> MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p) = op (f (pf a1) y1) (f (pf a2) y2).
Proof.
simple induction p.

*****

*****

+++++
Qed.
-----
Lemma MapFold_Put_disjoint_2 :\n   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad),\n     MapGet A m a = None ->\n     MapFold1 A M neutral op f pf (MapPut A m a y) =\n     op (f (pf a) y) (MapFold1 A M neutral op f pf m).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A m a) None), eq (MapFold1 A M neutral op f pf (MapPut A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
Proof.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A m a) None), eq (MapFold1 A M neutral op f pf (MapPut A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
simple induction m.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A (M0 A) a) None), eq (MapFold1 A M neutral op f pf (MapPut A (M0 A) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M0 A)))
+++++
intros.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.

*****
H : eq (MapGet A (M0 A) a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M0 A) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M0 A)))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
simpl in |- *.

*****
H : eq (MapGet A (M0 A) a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf a) y) (op (f (pf a) y) neutral)
+++++
rewrite (nright (f (pf a) y)).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (nright (f (pf a) y)).

*****
H : eq (MapGet A (M0 A) a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (f (pf a) y) (f (pf a) y)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (a1 : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A (M1 A a a0) a1) None), eq (MapFold1 A M neutral op f pf (MapPut A (M1 A a a0) a1 y)) (op (f (pf a1) y) (MapFold1 A M neutral op f pf (M1 A a a0)))
+++++
intros a1 y1 a2 y2 pf H.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.

*****
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M1 A a1 y1) a2 y2)) (op (f (pf a2) y2) (MapFold1 A M neutral op f pf (M1 A a1 y1)))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.

*****
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
elim (Ndiscr (Nxor a1 a2)).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).

*****
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : sig (fun p : positive => eq (N.lxor a1 a2) (Npos p)), eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
intro H0.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.

*****
H0 : sig (fun p : positive => eq (N.lxor a1 a2) (Npos p))
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
elim H0.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.
elim H0.

*****
H0 : sig (fun p : positive => eq (N.lxor a1 a2) (Npos p))
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (x : positive) (_ : eq (N.lxor a1 a2) (Npos x)), eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p0 => MapPut1 A a1 y1 a2 y2 p0 end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
intros p H1.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.
elim H0.
intros p H1.

*****
H1 : eq (N.lxor a1 a2) (Npos p)
p : positive
H0 : sig (fun p : positive => eq (N.lxor a1 a2) (Npos p))
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
rewrite H1.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.
elim H0.
intros p H1.
rewrite H1.

*****
H1 : eq (N.lxor a1 a2) (Npos p)
p : positive
H0 : sig (fun p : positive => eq (N.lxor a1 a2) (Npos p))
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
rewrite comm.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.
elim H0.
intros p H1.
rewrite H1.
rewrite comm.

*****
H1 : eq (N.lxor a1 a2) (Npos p)
p : positive
H0 : sig (fun p : positive => eq (N.lxor a1 a2) (Npos p))
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut1 A a1 y1 a2 y2 p)) (op (f (pf a1) y1) (f (pf a2) y2))
+++++
exact (MapFold_Put_disjoint_1 p f pf a1 a2 y1 y2 H1).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).

*****
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.lxor a1 a2) N0, eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
intro H0.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.

*****
H0 : eq (N.lxor a1 a2) N0
H : eq (MapGet A (M1 A a1 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
rewrite (Neqb_complete _ _ (Nxor_eq_true _ _ H0)) in H.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.
rewrite (Neqb_complete _ _ (Nxor_eq_true _ _ H0)) in H.

*****
H0 : eq (N.lxor a1 a2) N0
H : eq (MapGet A (M1 A a2 y1) a2) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
rewrite (M1_semantics_1 A a2 y1) in H.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros a1 y1 a2 y2 pf H.
simpl in |- *.
elim (Ndiscr (Nxor a1 a2)).
intro H0.
rewrite (Neqb_complete _ _ (Nxor_eq_true _ _ H0)) in H.
rewrite (M1_semantics_1 A a2 y1) in H.

*****
H0 : eq (N.lxor a1 a2) N0
H : eq (Some y1) None
pf : forall _ : ad, ad
y2 : A
a2 : ad
y1 : A
a1 : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf match N.lxor a1 a2 with | N0 => M1 A a2 y2 | Npos p => MapPut1 A a1 y1 a2 y2 p end) (op (f (pf a2) y2) (f (pf a1) y1))
+++++
discriminate H.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (_ : forall (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A m a) None), eq (MapFold1 A M neutral op f pf (MapPut A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))) (m0 : Map A) (_ : forall (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A m0 a) None), eq (MapFold1 A M neutral op f pf (MapPut A m0 a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))) (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A (M2 A m m0) a) None), eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m m0) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m m0)))
+++++
intros.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
elim (sumbool_of_bool (Nbit0 a)).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a) true, eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
intro H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).

*****
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y)), eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
intro.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
rewrite H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A m0 (MapPut A m1 (N.div2 a) y))) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) (MapPut A m1 (N.div2 a) y))) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (op (f (pf (N.succ_double (N.div2 a))) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1))) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite Ndiv2_double_plus_one.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
rewrite Ndiv2_double_plus_one.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (op (f (pf a) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1))) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite <- assoc.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
rewrite Ndiv2_double_plus_one.
rewrite <- assoc.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (f (pf a) y)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite (comm (MapFold1 A M neutral op f (fun a0:ad => pf (Ndouble a0)) m0) (f (pf a) y)).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
rewrite Ndiv2_double_plus_one.
rewrite <- assoc.
rewrite (comm (MapFold1 A M neutral op f (fun a0:ad => pf (Ndouble a0)) m0) (f (pf a) y)).

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (f (pf a) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite assoc.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
rewrite Ndiv2_double_plus_one.
rewrite <- assoc.
rewrite (comm (MapFold1 A M neutral op f (fun a0:ad => pf (Ndouble a0)) m0) (f (pf a) y)).
rewrite assoc.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1))) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
rewrite Ndiv2_double_plus_one.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Nodd a
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m1 (N.div2 a)) None
+++++
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H1.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
intro.
rewrite H3.
simpl in |- *.
rewrite (H0 (Ndiv2 a) y (fun a0:ad => pf (Ndouble_plus_one a0))).
rewrite (MapGet_M2_bit_0_1 A a H2 m0 m1) in H1.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
H2 : eq (N.odd a) true
H1 : eq (MapGet A m1 (N.div2 a)) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m1 (N.div2 a)) None
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).

*****
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapPut A (M2 A m0 m1) a y) (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.

*****
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
elim (Ndiscr a).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).

*****
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : sig (fun p : positive => eq a (Npos p)), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
intro H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.

*****
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
elim H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.

*****
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (x : positive) (_ : eq a (Npos x)), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
intro p.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq a (Npos p), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
elim p.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall _ : eq a (Npos p), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))) (_ : eq a (Npos (xI p))), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
intros p0 H4 H5.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.

*****
H5 : eq a (Npos (xI p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A m0 (MapPut A m1 (N.div2 a) y))
p,p0 : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
rewrite H5.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.
rewrite H5.

*****
H5 : eq a (Npos (xI p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A m0 (MapPut A m1 (N.div2 a) y))
p,p0 : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (M2 A m0 (MapPut A m1 (Npos p0) y)) (M2 A m0 (MapPut A m1 (N.div2 (Npos (xI p0))) y))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall _ : eq a (Npos p), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))) (_ : eq a (Npos (xO p))), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
intros p0 H4 H5.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.

*****
H5 : eq a (Npos (xO p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A m0 (MapPut A m1 (N.div2 a) y))
p,p0 : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
rewrite H5 in H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.
rewrite H5 in H2.

*****
H5 : eq a (Npos (xO p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A m0 (MapPut A m1 (N.div2 a) y))
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd (Npos (xO p0))) true
p0 : positive
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
discriminate H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq a (Npos xH), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
intro H4.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intro H4.

*****
H4 : eq a (Npos xH)
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
rewrite H4.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intro H4.
rewrite H4.

*****
H4 : eq a (Npos xH)
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (M2 A m0 (MapPut A m1 N0 y)) (M2 A m0 (MapPut A m1 (N.div2 (Npos xH)) y))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).

*****
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq a N0, eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
intro H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.

*****
H3 : eq a N0
H2 : eq (N.odd a) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
rewrite H3 in H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A m0 (MapPut A m1 (Ndiv2 a) y)).
simpl in |- *.
elim (Ndiscr a).
intro H3.
rewrite H3 in H2.

*****
H3 : eq a N0
H2 : eq (N.odd N0) true
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A m0 (MapPut A m1 (N.div2 a) y))
+++++
discriminate H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).

*****
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.odd a) false, eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
intro H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.

*****
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).

*****
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1), eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
intro.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m0 m1) a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
rewrite H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (M2 A (MapPut A m0 (N.div2 a) y) m1)) (op (f (pf a) y) (MapFold1 A M neutral op f pf (M2 A m0 m1)))
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) (MapPut A m0 (N.div2 a) y)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (f (pf (N.double (N.div2 a))) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite Ndiv2_double.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).
rewrite Ndiv2_double.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (f (pf a) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (f (pf a) y) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)))
+++++
rewrite <- assoc.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).
rewrite Ndiv2_double.
rewrite <- assoc.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (f (pf a) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) (op (op (f (pf a) y) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).
rewrite Ndiv2_double.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
Neven a
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m0 (N.div2 a)) None
+++++
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H1.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
intro.
rewrite H3.
simpl in |- *.
rewrite (H (Ndiv2 a) y (fun a0:ad => pf (Ndouble a0))).
rewrite (MapGet_M2_bit_0_0 A a H2 m0 m1) in H1.

*****
H3 : eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
H2 : eq (N.odd a) false
H1 : eq (MapGet A m0 (N.div2 a)) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m0 (N.div2 a)) None
+++++
assumption.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).

*****
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapPut A (M2 A m0 m1) a y) (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
simpl in |- *.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.

*****
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
elim (Ndiscr a).
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).

*****
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : sig (fun p : positive => eq a (Npos p)), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
intro H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.

*****
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
elim H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.

*****
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (x : positive) (_ : eq a (Npos x)), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
intro p.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq a (Npos p), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
elim p.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall _ : eq a (Npos p), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)) (_ : eq a (Npos (xI p))), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
intros p0 H4 H5.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.

*****
H5 : eq a (Npos (xI p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A (MapPut A m0 (N.div2 a) y) m1)
p,p0 : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
rewrite H5 in H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.
rewrite H5 in H2.

*****
H5 : eq a (Npos (xI p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A (MapPut A m0 (N.div2 a) y) m1)
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd (Npos (xI p0))) false
p0 : positive
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
discriminate H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (p : positive) (_ : forall _ : eq a (Npos p), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)) (_ : eq a (Npos (xO p))), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p2) => M2 A m0 (MapPut A m1 (Npos p2) y) | Npos (xO p2) => M2 A (MapPut A m0 (Npos p2) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
intros p0 H4 H5.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.

*****
H5 : eq a (Npos (xO p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A (MapPut A m0 (N.div2 a) y) m1)
p,p0 : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
rewrite H5.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intros p0 H4 H5.
rewrite H5.

*****
H5 : eq a (Npos (xO p0))
H4 : forall _ : eq a (Npos p0),\neq\n match a with\n | N0 => M2 A (MapPut A m0 N0 y) m1\n | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y)\n | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1\n | Npos xH => M2 A m0 (MapPut A m1 N0 y)\n end (M2 A (MapPut A m0 (N.div2 a) y) m1)
p,p0 : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (M2 A (MapPut A m0 (Npos p0) y) m1) (M2 A (MapPut A m0 (N.div2 (Npos (xO p0))) y) m1)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.

*****
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq a (Npos xH), eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p1) => M2 A m0 (MapPut A m1 (Npos p1) y) | Npos (xO p1) => M2 A (MapPut A m0 (Npos p1) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
intro H4.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intro H4.

*****
H4 : eq a (Npos xH)
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
rewrite H4 in H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
elim H3.
intro p.
elim p.
intro H4.
rewrite H4 in H2.

*****
H4 : eq a (Npos xH)
p : positive
H3 : sig (fun p : positive => eq a (Npos p))
H2 : eq (N.odd (Npos xH)) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
discriminate H2.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).

*****
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq a N0, eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
intro H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.

*****
H3 : eq a N0
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq match a with | N0 => M2 A (MapPut A m0 N0 y) m1 | Npos (xI p) => M2 A m0 (MapPut A m1 (Npos p) y) | Npos (xO p) => M2 A (MapPut A m0 (Npos p) y) m1 | Npos xH => M2 A m0 (MapPut A m1 N0 y) end (M2 A (MapPut A m0 (N.div2 a) y) m1)
+++++
rewrite H3.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.
intros.
elim (sumbool_of_bool (Nbit0 a)).
intro H2.
cut (MapPut A (M2 A m0 m1) a y = M2 A (MapPut A m0 (Ndiv2 a) y) m1).
simpl in |- *.
elim (Ndiscr a).
intro H3.
rewrite H3.

*****
H3 : eq a N0
H2 : eq (N.odd a) false
H1 : eq (MapGet A (M2 A m0 m1) a) None
pf : forall _ : ad, ad
y : A
a : ad
H0 : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m1 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m1 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m1))
m1 : Map A
H : forall (a : ad) (y : A) (pf : forall _ : ad, ad)\n (_ : eq (MapGet A m0 a) None),\neq (MapFold1 A M neutral op f pf (MapPut A m0 a y))\n (op (f (pf a) y) (MapFold1 A M neutral op f pf m0))
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (M2 A (MapPut A m0 N0 y) m1) (M2 A (MapPut A m0 (N.div2 N0) y) m1)
+++++
reflexivity.
-----
Lemma MapFold_Put_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_Put_disjoint :\n   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A),\n     MapGet A m a = None ->\n     MapFold A M neutral op f (MapPut A m a y) =\n     op (f a y) (MapFold A M neutral op f m).
-----
Lemma MapFold_Put_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut A m a y) = op (f a y) (MapFold A M neutral op f m).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) None), eq (MapFold A M neutral op f (MapPut A m a y)) (op (f a y) (MapFold A M neutral op f m))
+++++
Proof.
-----
Lemma MapFold_Put_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut A m a y) = op (f a y) (MapFold A M neutral op f m).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) None), eq (MapFold A M neutral op f (MapPut A m a y)) (op (f a y) (MapFold A M neutral op f m))
+++++
intros.
-----
Lemma MapFold_Put_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut A m a y) = op (f a y) (MapFold A M neutral op f m).
Proof.
intros.

*****
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op f (MapPut A m a y)) (op (f a y) (MapFold A M neutral op f m))
+++++
exact (MapFold_Put_disjoint_2 f m a y (fun a0:ad => a0) H).
-----
Lemma MapFold_Put_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut A m a y) = op (f a y) (MapFold A M neutral op f m).
Proof.
intros.
exact (MapFold_Put_disjoint_2 f m a y (fun a0:ad => a0) H).

*****

*****

+++++
Qed.
-----
Lemma MapFold_Put_behind_disjoint_2 :\n   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad),\n     MapGet A m a = None ->\n     MapFold1 A M neutral op f pf (MapPut_behind A m a y) =\n     op (f (pf a) y) (MapFold1 A M neutral op f pf m).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A m a) None), eq (MapFold1 A M neutral op f pf (MapPut_behind A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
Proof.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (pf : forall _ : ad, ad) (_ : eq (MapGet A m a) None), eq (MapFold1 A M neutral op f pf (MapPut_behind A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
intros.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut_behind A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eqmap A (MapPut_behind A m a y) (MapPut A m a y), eq (MapFold1 A M neutral op f pf (MapPut_behind A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
intro.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
intro.

*****
H0 : eqmap A (MapPut_behind A m a y) (MapPut A m a y)
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut_behind A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
rewrite (MapFold1_ext f _ _ H0 pf).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
intro.
rewrite (MapFold1_ext f _ _ H0 pf).

*****
H0 : eqmap A (MapPut_behind A m a y) (MapPut A m a y)
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A m a y)) (op (f (pf a) y) (MapFold1 A M neutral op f pf m))
+++++
apply MapFold_Put_disjoint_2.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
intro.
rewrite (MapFold1_ext f _ _ H0 pf).
apply MapFold_Put_disjoint_2.

*****
H0 : eqmap A (MapPut_behind A m a y) (MapPut A m a y)
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m a) None
+++++
assumption.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapPut_behind A m a y) (MapPut A m a y)
+++++
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapPut_behind A m a y) (MapMerge A (M1 A a y) m)
+++++
apply MapPut_behind_as_Merge.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapMerge A (M1 A a y) m) (MapPut A m a y)
+++++
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapMerge A (M1 A a y) m) (MapMerge A m (M1 A a y))
+++++
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapMerge A (M1 A a y) m) (MapDelta A (M1 A a y) m)
+++++
apply eqmap_sym.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapDelta A (M1 A a y) m) (MapMerge A (M1 A a y) m)
+++++
apply MapDelta_disjoint.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
MapDisjoint A A (M1 A a y) m
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a0 : ad) (_ : eq (in_dom A a0 (M1 A a y)) true) (_ : eq (in_dom A a0 m) true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a0 : ad) (_ : eq match MapGet A (M1 A a y) a0 with | Some _ => true | None => false end true) (_ : eq match MapGet A m a0 with | Some _ => true | None => false end true), False
+++++
simpl in |- *.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a0 : ad) (_ : eq match (if N.eqb a a0 then Some y else None) with | Some _ => true | None => false end true) (_ : eq match MapGet A m a0 with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.

*****
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.eqb a a0) true, False
+++++
intro H2.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.

*****
H2 : eq (N.eqb a a0) true
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
rewrite (Neqb_complete _ _ H2) in H.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H.

*****
H2 : eq (N.eqb a a0) true
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H : eq (MapGet A m a0) None
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
rewrite H in H1.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H.
rewrite H in H1.

*****
H2 : eq (N.eqb a a0) true
H1 : eq false true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H : eq (MapGet A m a0) None
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
discriminate H1.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.eqb a a0) false, False
+++++
intro H2.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.

*****
H2 : eq (N.eqb a a0) false
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
rewrite H2 in H0.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_sym.
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.
rewrite H2 in H0.

*****
H2 : eq (N.eqb a a0) false
H1 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H0 : eq false true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
discriminate H0.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapDelta A (M1 A a y) m) (MapMerge A m (M1 A a y))
+++++
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapDelta A (M1 A a y) m) (MapDelta A m (M1 A a y))
+++++
apply MapDelta_sym.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapDelta A m (M1 A a y)) (MapMerge A m (M1 A a y))
+++++
apply MapDelta_disjoint.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
MapDisjoint A A m (M1 A a y)
+++++
unfold MapDisjoint in |- *.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a0 : ad) (_ : eq (in_dom A a0 m) true) (_ : eq (in_dom A a0 (M1 A a y)) true), False
+++++
unfold in_dom in |- *.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a0 : ad) (_ : eq match MapGet A m a0 with | Some _ => true | None => false end true) (_ : eq match MapGet A (M1 A a y) a0 with | Some _ => true | None => false end true), False
+++++
simpl in |- *.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a0 : ad) (_ : eq match MapGet A m a0 with | Some _ => true | None => false end true) (_ : eq match (if N.eqb a a0 then Some y else None) with | Some _ => true | None => false end true), False
+++++
intros.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.

*****
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
elim (sumbool_of_bool (Neqb a a0)).
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.eqb a a0) true, False
+++++
intro H2.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.

*****
H2 : eq (N.eqb a a0) true
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
rewrite (Neqb_complete _ _ H2) in H.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H.

*****
H2 : eq (N.eqb a a0) true
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
H : eq (MapGet A m a0) None
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
rewrite H in H0.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.
rewrite (Neqb_complete _ _ H2) in H.
rewrite H in H0.

*****
H2 : eq (N.eqb a a0) true
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq false true
H : eq (MapGet A m a0) None
a0 : ad
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
discriminate H0.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).

*****
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : eq (N.eqb a a0) false, False
+++++
intro H2.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.

*****
H2 : eq (N.eqb a a0) false
H1 : eq\n match (if N.eqb a a0 then Some y else None) with\n | Some _ => true\n | None => false\n end true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
rewrite H2 in H1.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_trans with (m' := MapDelta A (M1 A a y) m).
apply eqmap_trans with (m' := MapDelta A m (M1 A a y)).
apply MapDelta_disjoint.
unfold MapDisjoint in |- *.
unfold in_dom in |- *.
simpl in |- *.
intros.
elim (sumbool_of_bool (Neqb a a0)).
intro H2.
rewrite H2 in H1.

*****
H2 : eq (N.eqb a a0) false
H1 : eq false true
H0 : eq match MapGet A m a0 with\n | Some _ => true\n | None => false\n end true
a0 : ad
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
False
+++++
discriminate H1.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapMerge A m (M1 A a y)) (MapPut A m a y)
+++++
apply eqmap_sym.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).
apply eqmap_trans with (m' := MapMerge A (M1 A a y) m).
apply eqmap_trans with (m' := MapMerge A m (M1 A a y)).
apply eqmap_sym.

*****
H : eq (MapGet A m a) None
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eqmap A (MapPut A m a y) (MapMerge A m (M1 A a y))
+++++
apply MapPut_as_Merge.
-----
Lemma MapFold_Put_behind_disjoint_2 : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A) (pf:ad -> ad), MapGet A m a = None -> MapFold1 A M neutral op f pf (MapPut_behind A m a y) = op (f (pf a) y) (MapFold1 A M neutral op f pf m).
Proof.
intros.
cut (eqmap A (MapPut_behind A m a y) (MapPut A m a y)).

*****

*****

+++++
Qed.
-----
Lemma MapFold_Put_behind_disjoint :\n   forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A),\n     MapGet A m a = None ->\n     MapFold A M neutral op f (MapPut_behind A m a y) =\n     op (f a y) (MapFold A M neutral op f m).
-----
Lemma MapFold_Put_behind_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut_behind A m a y) = op (f a y) (MapFold A M neutral op f m).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) None), eq (MapFold A M neutral op f (MapPut_behind A m a y)) (op (f a y) (MapFold A M neutral op f m))
+++++
Proof.
-----
Lemma MapFold_Put_behind_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut_behind A m a y) = op (f a y) (MapFold A M neutral op f m).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (a : ad) (y : A) (_ : eq (MapGet A m a) None), eq (MapFold A M neutral op f (MapPut_behind A m a y)) (op (f a y) (MapFold A M neutral op f m))
+++++
intros.
-----
Lemma MapFold_Put_behind_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut_behind A m a y) = op (f a y) (MapFold A M neutral op f m).
Proof.
intros.

*****
H : eq (MapGet A m a) None
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op f (MapPut_behind A m a y)) (op (f a y) (MapFold A M neutral op f m))
+++++
exact (MapFold_Put_behind_disjoint_2 f m a y (fun a0:ad => a0) H).
-----
Lemma MapFold_Put_behind_disjoint : forall (f:ad -> A -> M) (m:Map A) (a:ad) (y:A), MapGet A m a = None -> MapFold A M neutral op f (MapPut_behind A m a y) = op (f a y) (MapFold A M neutral op f m).
Proof.
intros.
exact (MapFold_Put_behind_disjoint_2 f m a y (fun a0:ad => a0) H).

*****

*****

+++++
Qed.
-----
Lemma MapFold_Merge_disjoint_1 :\n   forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad),\n     MapDisjoint A A m1 m2 ->\n     MapFold1 A M neutral op f pf (MapMerge A m1 m2) =\n     op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m1 m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m1 m2), eq (MapFold1 A M neutral op f pf (MapMerge A m1 m2)) (op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2))
+++++
Proof.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m1 m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m1 m2), eq (MapFold1 A M neutral op f pf (MapMerge A m1 m2)) (op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2))
+++++
simple induction m1.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.

*****
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M0 A) m2), eq (MapFold1 A M neutral op f pf (MapMerge A (M0 A) m2)) (op (MapFold1 A M neutral op f pf (M0 A)) (MapFold1 A M neutral op f pf m2))
+++++
simpl in |- *.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simpl in |- *.

*****
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M0 A) m2), eq (MapFold1 A M neutral op f pf m2) (op neutral (MapFold1 A M neutral op f pf m2))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simpl in |- *.
intros.

*****
H : MapDisjoint A A (M0 A) m2
pf : forall _ : ad, ad
m1,m2 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf m2) (op neutral (MapFold1 A M neutral op f pf m2))
+++++
rewrite nleft.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simpl in |- *.
intros.
rewrite nleft.

*****
H : MapDisjoint A A (M0 A) m2
pf : forall _ : ad, ad
m1,m2 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf m2) (MapFold1 A M neutral op f pf m2)
+++++
reflexivity.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.

*****
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M1 A a a0) m2), eq (MapFold1 A M neutral op f pf (MapMerge A (M1 A a a0) m2)) (op (MapFold1 A M neutral op f pf (M1 A a a0)) (MapFold1 A M neutral op f pf m2))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
intros.

*****
H : MapDisjoint A A (M1 A a a0) m2
pf : forall _ : ad, ad
m2 : Map A
a0 : A
a : ad
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapMerge A (M1 A a a0) m2)) (op (MapFold1 A M neutral op f pf (M1 A a a0)) (MapFold1 A M neutral op f pf m2))
+++++
unfold MapMerge in |- *.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
intros.
unfold MapMerge in |- *.

*****
H : MapDisjoint A A (M1 A a a0) m2
pf : forall _ : ad, ad
m2 : Map A
a0 : A
a : ad
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut_behind A m2 a a0)) (op (MapFold1 A M neutral op f pf (M1 A a a0)) (MapFold1 A M neutral op f pf m2))
+++++
apply (MapFold_Put_behind_disjoint_2 f m2 a a0 pf).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
intros.
unfold MapMerge in |- *.
apply (MapFold_Put_behind_disjoint_2 f m2 a a0 pf).

*****
H : MapDisjoint A A (M1 A a a0) m2
pf : forall _ : ad, ad
m2 : Map A
a0 : A
a : ad
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A m2 a) None
+++++
apply in_dom_none.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
intros.
unfold MapMerge in |- *.
apply (MapFold_Put_behind_disjoint_2 f m2 a a0 pf).
apply in_dom_none.

*****
H : MapDisjoint A A (M1 A a a0) m2
pf : forall _ : ad, ad
m2 : Map A
a0 : A
a : ad
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (in_dom A a m2) false
+++++
exact (MapDisjoint_M1_l _ _ m2 a a0 H).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.

*****
m1 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (_ : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2), eq (MapFold1 A M neutral op f pf (MapMerge A m m2)) (op (MapFold1 A M neutral op f pf m) (MapFold1 A M neutral op f pf m2))) (m0 : Map A) (_ : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m0 m2), eq (MapFold1 A M neutral op f pf (MapMerge A m0 m2)) (op (MapFold1 A M neutral op f pf m0) (MapFold1 A M neutral op f pf m2))) (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m2), eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m2)) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf m2))
+++++
simple induction m2.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.

*****
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) (M0 A)), eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) (M0 A))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M0 A)))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.

*****
H1 : MapDisjoint A A (M2 A m m0) (M0 A)
pf : forall _ : ad, ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) (M0 A))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M0 A)))
+++++
simpl in |- *.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.

*****
H1 : MapDisjoint A A (M2 A m m0) (M0 A)
pf : forall _ : ad, ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) neutral)
+++++
rewrite nright.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite nright.

*****
H1 : MapDisjoint A A (M2 A m m0) (M0 A)
pf : forall _ : ad, ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0))
+++++
reflexivity.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.

*****
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) (M1 A a a0)), eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) (M1 A a a0))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M1 A a a0)))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.

*****
H1 : MapDisjoint A A (M2 A m m0) (M1 A a a0)
pf : forall _ : ad, ad
a0 : A
a : ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) (M1 A a a0))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M1 A a a0)))
+++++
unfold MapMerge in |- *.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
unfold MapMerge in |- *.

*****
H1 : MapDisjoint A A (M2 A m m0) (M1 A a a0)
pf : forall _ : ad, ad
a0 : A
a : ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapPut A (M2 A m m0) a a0)) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M1 A a a0)))
+++++
rewrite (MapFold_Put_disjoint_2 f (M2 A m m0) a a0 pf).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
unfold MapMerge in |- *.
rewrite (MapFold_Put_disjoint_2 f (M2 A m m0) a a0 pf).

*****
H1 : MapDisjoint A A (M2 A m m0) (M1 A a a0)
pf : forall _ : ad, ad
a0 : A
a : ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (f (pf a) a0) (MapFold1 A M neutral op f pf (M2 A m m0))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M1 A a a0)))
+++++
apply comm.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
unfold MapMerge in |- *.
rewrite (MapFold_Put_disjoint_2 f (M2 A m m0) a a0 pf).

*****
H1 : MapDisjoint A A (M2 A m m0) (M1 A a a0)
pf : forall _ : ad, ad
a0 : A
a : ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapGet A (M2 A m m0) a) None
+++++
apply in_dom_none.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
unfold MapMerge in |- *.
rewrite (MapFold_Put_disjoint_2 f (M2 A m m0) a a0 pf).
apply in_dom_none.

*****
H1 : MapDisjoint A A (M2 A m m0) (M1 A a a0)
pf : forall _ : ad, ad
a0 : A
a : ad
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (in_dom A a (M2 A m m0)) false
+++++
exact (MapDisjoint_M1_r _ _ (M2 A m m0) a a0 H1).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.

*****
m2 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m1 : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m1), eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m1)) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf m1))) (m2 : Map A) (_ : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m2), eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m2)) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf m2))) (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) (M2 A m1 m2)), eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) (M2 A m1 m2))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M2 A m1 m2)))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) (M2 A m3 m4))) (op (MapFold1 A M neutral op f pf (M2 A m m0)) (MapFold1 A M neutral op f pf (M2 A m3 m4)))
+++++
simpl in |- *.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) (MapMerge A m m3)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) (MapMerge A m0 m4))) (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4)))
+++++
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3)) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) (MapMerge A m0 m4))) (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4)))
+++++
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4))) (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4)))
+++++
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall _ : forall a b c d : M, eq (op (op a b) (op c d)) (op (op a c) (op b d)), eq (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4))) (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4)))
+++++
intro.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intro.

*****
H4 : forall a b c d : M, eq (op (op a b) (op c d)) (op (op a c) (op b d))
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4))) (op (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m0)) (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m3) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m4)))
+++++
apply H4.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall a b c d : M, eq (op (op a b) (op c d)) (op (op a c) (op b d))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intros.

*****
a,b,c,d : M
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op (op a b) (op c d)) (op (op a c) (op b d))
+++++
rewrite assoc.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intros.
rewrite assoc.

*****
a,b,c,d : M
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op a (op b (op c d))) (op (op a c) (op b d))
+++++
rewrite <- (assoc b c d).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intros.
rewrite assoc.
rewrite <- (assoc b c d).

*****
a,b,c,d : M
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op a (op (op b c) d)) (op (op a c) (op b d))
+++++
rewrite (comm b c).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intros.
rewrite assoc.
rewrite <- (assoc b c d).
rewrite (comm b c).

*****
a,b,c,d : M
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op a (op (op c b) d)) (op (op a c) (op b d))
+++++
rewrite (assoc c b d).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intros.
rewrite assoc.
rewrite <- (assoc b c d).
rewrite (comm b c).
rewrite (assoc c b d).

*****
a,b,c,d : M
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op a (op c (op b d))) (op (op a c) (op b d))
+++++
rewrite assoc.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).
cut (forall a b c d:M, op (op a b) (op c d) = op (op a c) (op b d)).
intros.
rewrite assoc.
rewrite <- (assoc b c d).
rewrite (comm b c).
rewrite (assoc c b d).
rewrite assoc.

*****
a,b,c,d : M
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op a (op c (op b d))) (op a (op c (op b d)))
+++++
reflexivity.
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 m4 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
MapDisjoint A A m0 m4
+++++
exact (MapDisjoint_M2_r _ _ _ _ _ _ H3).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.
simple induction m2.
intros.
simpl in |- *.
rewrite (H m3 (fun a0:ad => pf (Ndouble a0))).

*****
H3 : MapDisjoint A A (M2 A m m0) (M2 A m3 m4)
pf : forall _ : ad, ad
H2 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m4),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m4))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m4))
m4 : Map A
H1 : forall (pf : forall _ : ad, ad) (_ : MapDisjoint A A (M2 A m m0) m3),\neq (MapFold1 A M neutral op f pf (MapMerge A (M2 A m m0) m3))\n (op (MapFold1 A M neutral op f pf (M2 A m m0))\n (MapFold1 A M neutral op f pf m3))
m2,m3 : Map A
H0 : forall (m2 : Map A) (pf : forall _ : ad, ad)\n (_ : MapDisjoint A A m0 m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m0 m2))\n (op (MapFold1 A M neutral op f pf m0)\n (MapFold1 A M neutral op f pf m2))
m0 : Map A
H : forall (m2 : Map A) (pf : forall _ : ad, ad) (_ : MapDisjoint A A m m2),\neq (MapFold1 A M neutral op f pf (MapMerge A m m2))\n (op (MapFold1 A M neutral op f pf m)\n (MapFold1 A M neutral op f pf m2))
m1,m : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
MapDisjoint A A m m3
+++++
exact (MapDisjoint_M2_l _ _ _ _ _ _ H3).
-----
Lemma MapFold_Merge_disjoint_1 : forall (f:ad -> A -> M) (m1 m2:Map A) (pf:ad -> ad), MapDisjoint A A m1 m2 -> MapFold1 A M neutral op f pf (MapMerge A m1 m2) = op (MapFold1 A M neutral op f pf m1) (MapFold1 A M neutral op f pf m2).
Proof.
simple induction m1.

*****

*****

+++++
Qed.
-----
Lemma MapFold_Merge_disjoint :\n   forall (f:ad -> A -> M) (m1 m2:Map A),\n     MapDisjoint A A m1 m2 ->\n     MapFold A M neutral op f (MapMerge A m1 m2) =\n     op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2).
-----
Lemma MapFold_Merge_disjoint : forall (f:ad -> A -> M) (m1 m2:Map A), MapDisjoint A A m1 m2 -> MapFold A M neutral op f (MapMerge A m1 m2) = op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2).

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m1 m2 : Map A) (_ : MapDisjoint A A m1 m2), eq (MapFold A M neutral op f (MapMerge A m1 m2)) (op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2))
+++++
Proof.
-----
Lemma MapFold_Merge_disjoint : forall (f:ad -> A -> M) (m1 m2:Map A), MapDisjoint A A m1 m2 -> MapFold A M neutral op f (MapMerge A m1 m2) = op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2).
Proof.

*****
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m1 m2 : Map A) (_ : MapDisjoint A A m1 m2), eq (MapFold A M neutral op f (MapMerge A m1 m2)) (op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2))
+++++
intros.
-----
Lemma MapFold_Merge_disjoint : forall (f:ad -> A -> M) (m1 m2:Map A), MapDisjoint A A m1 m2 -> MapFold A M neutral op f (MapMerge A m1 m2) = op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2).
Proof.
intros.

*****
H : MapDisjoint A A m1 m2
m1,m2 : Map A
f : forall (_ : ad) (_ : A), M
comm : forall a b : M, eq (op a b) (op b a)
assoc : forall a b c : M, eq (op (op a b) c) (op a (op b c))
nright : forall a : M, eq (op a neutral) a
nleft : forall a : M, eq (op neutral a) a
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (MapFold A M neutral op f (MapMerge A m1 m2)) (op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2))
+++++
exact (MapFold_Merge_disjoint_1 f m1 m2 (fun a0:ad => a0) H).
-----
Lemma MapFold_Merge_disjoint : forall (f:ad -> A -> M) (m1 m2:Map A), MapDisjoint A A m1 m2 -> MapFold A M neutral op f (MapMerge A m1 m2) = op (MapFold A M neutral op f m1) (MapFold A M neutral op f m2).
Proof.
intros.
exact (MapFold_Merge_disjoint_1 f m1 m2 (fun a0:ad => a0) H).

*****

*****

+++++
Qed.
-----
End MapFoldResults.
-----
Section MapFoldDistr.
-----
Variable A : Type.
-----
Variable M : Type.
-----
Variable neutral : M.
-----
Variable op : M -> M -> M.
-----
Variable M' : Type.
-----
Variable neutral' : M'.
-----
Variable op' : M' -> M' -> M'.
-----
Variable N : Type.
-----
Variable times : M -> N -> M'.
-----
Variable absorb : forall c:N, times neutral c = neutral'.
-----
Variable\n    distr :\n      forall (a b:M) (c:N), times (op a b) c = op' (times a c) (times b c).
-----
Lemma MapFold_distr_r_1 :\n   forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad),\n     times (MapFold1 A M neutral op f pf m) c =\n     MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.

*****
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf m) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf m)
+++++
Proof.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.

*****
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf m) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf m)
+++++
simple induction m.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf (M0 A)) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf (M0 A))
+++++
intros.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
c : N
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (times (MapFold1 A M neutral op f pf (M0 A)) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf (M0 A))
+++++
exact (absorb c).
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a : ad) (a0 : A) (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf (M1 A a a0)) c) (MapFold1 A M' neutral' op' (fun (a1 : ad) (y : A) => times (f a1 y) c) pf (M1 A a a0))
+++++
trivial.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (m : Map A) (_ : forall (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf m) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf m)) (m0 : Map A) (_ : forall (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf m0) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf m0)) (c : N) (pf : forall _ : ad, ad), eq (times (MapFold1 A M neutral op f pf (M2 A m m0)) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf (M2 A m m0))
+++++
intros.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
c : N
H0 : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m1) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m1)
m1 : Map A
H : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m0) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m0)
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (times (MapFold1 A M neutral op f pf (M2 A m0 m1)) c) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) pf (M2 A m0 m1))
+++++
simpl in |- *.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
pf : forall _ : ad, ad
c : N
H0 : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m1) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m1)
m1 : Map A
H : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m0) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m0)
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (times (op (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1)) c) (op' (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite distr.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite distr.

*****
pf : forall _ : ad, ad
c : N
H0 : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m1) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m1)
m1 : Map A
H : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m0) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m0)
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op' (times (MapFold1 A M neutral op f (fun a0 : ad => pf (N.double a0)) m0) c) (times (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1) c)) (op' (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite H.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite distr.
rewrite H.

*****
pf : forall _ : ad, ad
c : N
H0 : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m1) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m1)
m1 : Map A
H : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m0) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m0)
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op' (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.double a0)) m0) (times (MapFold1 A M neutral op f (fun a0 : ad => pf (N.succ_double a0)) m1) c)) (op' (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
rewrite H0.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite distr.
rewrite H.
rewrite H0.

*****
pf : forall _ : ad, ad
c : N
H0 : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m1) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m1)
m1 : Map A
H : forall (c : N) (pf : forall _ : ad, ad),\neq (times (MapFold1 A M neutral op f pf m0) c)\n (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c)\n pf m0)
m,m0 : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (op' (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.succ_double a0)) m1)) (op' (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) (fun a0 : ad => pf (N.succ_double a0)) m1))
+++++
reflexivity.
-----
Lemma MapFold_distr_r_1 : forall (f:ad -> A -> M) (m:Map A) (c:N) (pf:ad -> ad), times (MapFold1 A M neutral op f pf m) c = MapFold1 A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) pf m.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_distr_r :\n   forall (f:ad -> A -> M) (m:Map A) (c:N),\n     times (MapFold A M neutral op f m) c =\n     MapFold A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) m.
-----
Lemma MapFold_distr_r : forall (f:ad -> A -> M) (m:Map A) (c:N), times (MapFold A M neutral op f m) c = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) m.

*****
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (c : N), eq (times (MapFold A M neutral op f m) c) (MapFold A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) m)
+++++
Proof.
-----
Lemma MapFold_distr_r : forall (f:ad -> A -> M) (m:Map A) (c:N), times (MapFold A M neutral op f m) c = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) m.
Proof.

*****
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (c : N), eq (times (MapFold A M neutral op f m) c) (MapFold A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) m)
+++++
intros.
-----
Lemma MapFold_distr_r : forall (f:ad -> A -> M) (m:Map A) (c:N), times (MapFold A M neutral op f m) c = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) m.
Proof.
intros.

*****
c : N
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times (op a b) c) (op' (times a c) (times b c))
absorb : forall c : N, eq (times neutral c) neutral'
times : forall (_ : M) (_ : N), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (times (MapFold A M neutral op f m) c) (MapFold A M' neutral' op' (fun (a : ad) (y : A) => times (f a y) c) m)
+++++
exact (MapFold_distr_r_1 f m c (fun a:ad => a)).
-----
Lemma MapFold_distr_r : forall (f:ad -> A -> M) (m:Map A) (c:N), times (MapFold A M neutral op f m) c = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times (f a y) c) m.
Proof.
intros.
exact (MapFold_distr_r_1 f m c (fun a:ad => a)).

*****

*****

+++++
Qed.
-----
End MapFoldDistr.
-----
Section MapFoldDistrL.
-----
Variable A : Type.
-----
Variable M : Type.
-----
Variable neutral : M.
-----
Variable op : M -> M -> M.
-----
Variable M' : Type.
-----
Variable neutral' : M'.
-----
Variable op' : M' -> M' -> M'.
-----
Variable N : Type.
-----
Variable times : N -> M -> M'.
-----
Variable absorb : forall c:N, times c neutral = neutral'.
-----
Variable\n    distr :\n      forall (a b:M) (c:N), times c (op a b) = op' (times c a) (times c b).
-----
Lemma MapFold_distr_l :\n   forall (f:ad -> A -> M) (m:Map A) (c:N),\n     times c (MapFold A M neutral op f m) =\n     MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.
-----
Lemma MapFold_distr_l : forall (f:ad -> A -> M) (m:Map A) (c:N), times c (MapFold A M neutral op f m) = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.

*****
distr : forall (a b : M) (c : N),\neq (times c (op a b)) (op' (times c a) (times c b))
absorb : forall c : N, eq (times c neutral) neutral'
times : forall (_ : N) (_ : M), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (c : N), eq (times c (MapFold A M neutral op f m)) (MapFold A M' neutral' op' (fun (a : ad) (y : A) => times c (f a y)) m)
+++++
Proof.
-----
Lemma MapFold_distr_l : forall (f:ad -> A -> M) (m:Map A) (c:N), times c (MapFold A M neutral op f m) = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.
Proof.

*****
distr : forall (a b : M) (c : N),\neq (times c (op a b)) (op' (times c a) (times c b))
absorb : forall c : N, eq (times c neutral) neutral'
times : forall (_ : N) (_ : M), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (f : forall (_ : ad) (_ : A), M) (m : Map A) (c : N), eq (times c (MapFold A M neutral op f m)) (MapFold A M' neutral' op' (fun (a : ad) (y : A) => times c (f a y)) m)
+++++
intros.
-----
Lemma MapFold_distr_l : forall (f:ad -> A -> M) (m:Map A) (c:N), times c (MapFold A M neutral op f m) = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.
Proof.
intros.

*****
c : N
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times c (op a b)) (op' (times c a) (times c b))
absorb : forall c : N, eq (times c neutral) neutral'
times : forall (_ : N) (_ : M), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
eq (times c (MapFold A M neutral op f m)) (MapFold A M' neutral' op' (fun (a : ad) (y : A) => times c (f a y)) m)
+++++
apply MapFold_distr_r with (times := fun (a:M) (b:N) => times b a).
-----
Lemma MapFold_distr_l : forall (f:ad -> A -> M) (m:Map A) (c:N), times c (MapFold A M neutral op f m) = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.
Proof.
intros.
apply MapFold_distr_r with (times := fun (a:M) (b:N) => times b a).

*****
c : N
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times c (op a b)) (op' (times c a) (times c b))
absorb : forall c : N, eq (times c neutral) neutral'
times : forall (_ : N) (_ : M), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall c : N, eq (times c neutral) neutral'
+++++
assumption.
-----
Lemma MapFold_distr_l : forall (f:ad -> A -> M) (m:Map A) (c:N), times c (MapFold A M neutral op f m) = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.
Proof.
intros.
apply MapFold_distr_r with (times := fun (a:M) (b:N) => times b a).

*****
c : N
m : Map A
f : forall (_ : ad) (_ : A), M
distr : forall (a b : M) (c : N),\neq (times c (op a b)) (op' (times c a) (times c b))
absorb : forall c : N, eq (times c neutral) neutral'
times : forall (_ : N) (_ : M), M'
N : Type
op' : forall (_ : M') (_ : M'), M'
neutral' : M'
M' : Type
op : forall (_ : M) (_ : M), M
neutral : M
M : Type
A : Type
*****
forall (a b : M) (c : N), eq (times c (op a b)) (op' (times c a) (times c b))
+++++
assumption.
-----
Lemma MapFold_distr_l : forall (f:ad -> A -> M) (m:Map A) (c:N), times c (MapFold A M neutral op f m) = MapFold A M' neutral' op' (fun (a:ad) (y:A) => times c (f a y)) m.
Proof.
intros.
apply MapFold_distr_r with (times := fun (a:M) (b:N) => times b a).

*****

*****

+++++
Qed.
-----
End MapFoldDistrL.
-----
Section MapFoldExists.
-----
Variable A : Type.
-----
Lemma MapFold_orb_1 :\n   forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad),\n     MapFold1 A bool false orb f pf m =\n     match MapSweep1 A f pf m with\n     | Some _ => true\n     | _ => false\n     end.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.

*****
A : Type
*****
forall (f : forall (_ : ad) (_ : A), bool) (m : Map A) (pf : forall _ : ad, ad), eq (MapFold1 A bool false orb f pf m) match MapSweep1 A f pf m with | Some _ => true | None => false end
+++++
Proof.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.

*****
A : Type
*****
forall (f : forall (_ : ad) (_ : A), bool) (m : Map A) (pf : forall _ : ad, ad), eq (MapFold1 A bool false orb f pf m) match MapSweep1 A f pf m with | Some _ => true | None => false end
+++++
simple induction m.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall pf : forall _ : ad, ad, eq (MapFold1 A bool false orb f pf (M0 A)) match MapSweep1 A f pf (M0 A) with | Some _ => true | None => false end
+++++
trivial.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (a : ad) (a0 : A) (pf : forall _ : ad, ad), eq (MapFold1 A bool false orb f pf (M1 A a a0)) match MapSweep1 A f pf (M1 A a a0) with | Some _ => true | None => false end
+++++
intros a y pf.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros a y pf.

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapFold1 A bool false orb f pf (M1 A a y)) match MapSweep1 A f pf (M1 A a y) with | Some _ => true | None => false end
+++++
simpl in |- *.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros a y pf.
simpl in |- *.

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) match MapSweep2 A f (pf a) y with | Some _ => true | None => false end
+++++
unfold MapSweep2 in |- *.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros a y pf.
simpl in |- *.
unfold MapSweep2 in |- *.

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (f (pf a) y) match (if f (pf a) y then Some (pair (pf a) y) else None) with | Some _ => true | None => false end
+++++
case (f (pf a) y).
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros a y pf.
simpl in |- *.
unfold MapSweep2 in |- *.
case (f (pf a) y).

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros a y pf.
simpl in |- *.
unfold MapSweep2 in |- *.
case (f (pf a) y).

*****
pf : forall _ : ad, ad
y : A
a : ad
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq false false
+++++
reflexivity.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall (m : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A bool false orb f pf m) match MapSweep1 A f pf m with | Some _ => true | None => false end) (m0 : Map A) (_ : forall pf : forall _ : ad, ad, eq (MapFold1 A bool false orb f pf m0) match MapSweep1 A f pf m0 with | Some _ => true | None => false end) (pf : forall _ : ad, ad), eq (MapFold1 A bool false orb f pf (M2 A m m0)) match MapSweep1 A f pf (M2 A m m0) with | Some _ => true | None => false end
+++++
intros.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m1)\n match MapSweep1 A f pf m1 with\n | Some _ => true\n | None => false\n end
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m0)\n match MapSweep1 A f pf m0 with\n | Some _ => true\n | None => false\n end
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapFold1 A bool false orb f pf (M2 A m0 m1)) match MapSweep1 A f pf (M2 A m0 m1) with | Some _ => true | None => false end
+++++
simpl in |- *.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros.
simpl in |- *.

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m1)\n match MapSweep1 A f pf m1 with\n | Some _ => true\n | None => false\n end
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m0)\n match MapSweep1 A f pf m0 with\n | Some _ => true\n | None => false\n end
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (orb (MapFold1 A bool false orb f (fun a0 : ad => pf (N.double a0)) m0) (MapFold1 A bool false orb f (fun a0 : ad => pf (N.succ_double a0)) m1)) match match MapSweep1 A f (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 A f (fun a : ad => pf (N.succ_double a)) m1 end with | Some _ => true | None => false end
+++++
rewrite (H (fun a0:ad => pf (Ndouble a0))).
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H (fun a0:ad => pf (Ndouble a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m1)\n match MapSweep1 A f pf m1 with\n | Some _ => true\n | None => false\n end
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m0)\n match MapSweep1 A f pf m0 with\n | Some _ => true\n | None => false\n end
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (orb match MapSweep1 A f (fun a0 : ad => pf (N.double a0)) m0 with | Some _ => true | None => false end (MapFold1 A bool false orb f (fun a0 : ad => pf (N.succ_double a0)) m1)) match match MapSweep1 A f (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 A f (fun a : ad => pf (N.succ_double a)) m1 end with | Some _ => true | None => false end
+++++
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m1)\n match MapSweep1 A f pf m1 with\n | Some _ => true\n | None => false\n end
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m0)\n match MapSweep1 A f pf m0 with\n | Some _ => true\n | None => false\n end
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (orb match MapSweep1 A f (fun a0 : ad => pf (N.double a0)) m0 with | Some _ => true | None => false end match MapSweep1 A f (fun a0 : ad => pf (N.succ_double a0)) m1 with | Some _ => true | None => false end) match match MapSweep1 A f (fun a : ad => pf (N.double a)) m0 with | Some r => Some r | None => MapSweep1 A f (fun a : ad => pf (N.succ_double a)) m1 end with | Some _ => true | None => false end
+++++
case (MapSweep1 A f (fun a0:ad => pf (Ndouble a0)) m0).
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).
case (MapSweep1 A f (fun a0:ad => pf (Ndouble a0)) m0).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m1)\n match MapSweep1 A f pf m1 with\n | Some _ => true\n | None => false\n end
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m0)\n match MapSweep1 A f pf m0 with\n | Some _ => true\n | None => false\n end
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
forall _ : prod ad A, eq (orb true match MapSweep1 A f (fun a0 : ad => pf (N.succ_double a0)) m1 with | Some _ => true | None => false end) true
+++++
reflexivity.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.
intros.
simpl in |- *.
rewrite (H (fun a0:ad => pf (Ndouble a0))).
rewrite (H0 (fun a0:ad => pf (Ndouble_plus_one a0))).
case (MapSweep1 A f (fun a0:ad => pf (Ndouble a0)) m0).

*****
pf : forall _ : ad, ad
H0 : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m1)\n match MapSweep1 A f pf m1 with\n | Some _ => true\n | None => false\n end
m1 : Map A
H : forall pf : forall _ : ad, ad,\neq (MapFold1 A bool false orb f pf m0)\n match MapSweep1 A f pf m0 with\n | Some _ => true\n | None => false\n end
m,m0 : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (orb false match MapSweep1 A f (fun a0 : ad => pf (N.succ_double a0)) m1 with | Some _ => true | None => false end) match MapSweep1 A f (fun a : ad => pf (N.succ_double a)) m1 with | Some _ => true | None => false end
+++++
reflexivity.
-----
Lemma MapFold_orb_1 : forall (f:ad -> A -> bool) (m:Map A) (pf:ad -> ad), MapFold1 A bool false orb f pf m = match MapSweep1 A f pf m with | Some _ => true | _ => false end.
Proof.
simple induction m.

*****

*****

+++++
Qed.
-----
Lemma MapFold_orb :\n   forall (f:ad -> A -> bool) (m:Map A),\n     MapFold A bool false orb f m =\n     match MapSweep A f m with\n     | Some _ => true\n     | _ => false\n     end.
-----
Lemma MapFold_orb : forall (f:ad -> A -> bool) (m:Map A), MapFold A bool false orb f m = match MapSweep A f m with | Some _ => true | _ => false end.

*****
A : Type
*****
forall (f : forall (_ : ad) (_ : A), bool) (m : Map A), eq (MapFold A bool false orb f m) match MapSweep A f m with | Some _ => true | None => false end
+++++
Proof.
-----
Lemma MapFold_orb : forall (f:ad -> A -> bool) (m:Map A), MapFold A bool false orb f m = match MapSweep A f m with | Some _ => true | _ => false end.
Proof.

*****
A : Type
*****
forall (f : forall (_ : ad) (_ : A), bool) (m : Map A), eq (MapFold A bool false orb f m) match MapSweep A f m with | Some _ => true | None => false end
+++++
intros.
-----
Lemma MapFold_orb : forall (f:ad -> A -> bool) (m:Map A), MapFold A bool false orb f m = match MapSweep A f m with | Some _ => true | _ => false end.
Proof.
intros.

*****
m : Map A
f : forall (_ : ad) (_ : A), bool
A : Type
*****
eq (MapFold A bool false orb f m) match MapSweep A f m with | Some _ => true | None => false end
+++++
exact (MapFold_orb_1 f m (fun a:ad => a)).
-----
Lemma MapFold_orb : forall (f:ad -> A -> bool) (m:Map A), MapFold A bool false orb f m = match MapSweep A f m with | Some _ => true | _ => false end.
Proof.
intros.
exact (MapFold_orb_1 f m (fun a:ad => a)).

*****

*****

+++++
Qed.
-----
End MapFoldExists.
-----
Section DMergeDef.
-----
Variable A : Type.
-----
Definition DMerge :=\n    MapFold (Map A) (Map A) (M0 A) (MapMerge A) (fun (_:ad) (m:Map A) => m).
-----
Lemma in_dom_DMerge_1 :\n   forall (m:Map (Map A)) (a:ad),\n     in_dom A a (DMerge m) =\n     match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with\n     | Some _ => true\n     | _ => false\n     end.
-----
Lemma in_dom_DMerge_1 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with | Some _ => true | _ => false end.

*****
A : Type
*****
forall (m : Map (Map A)) (a : ad), eq (in_dom A a (DMerge m)) match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end
+++++
Proof.
-----
Lemma in_dom_DMerge_1 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with | Some _ => true | _ => false end.
Proof.

*****
A : Type
*****
forall (m : Map (Map A)) (a : ad), eq (in_dom A a (DMerge m)) match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end
+++++
unfold DMerge in |- *.
-----
Lemma in_dom_DMerge_1 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with | Some _ => true | _ => false end.
Proof.
unfold DMerge in |- *.

*****
A : Type
*****
forall (m : Map (Map A)) (a : ad), eq (in_dom A a (MapFold (Map A) (Map A) (M0 A) (MapMerge A) (fun (_ : ad) (m0 : Map A) => m0) m)) match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end
+++++
intros.
-----
Lemma in_dom_DMerge_1 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with | Some _ => true | _ => false end.
Proof.
unfold DMerge in |- *.
intros.

*****
a : ad
m : Map (Map A)
A : Type
*****
eq (in_dom A a (MapFold (Map A) (Map A) (M0 A) (MapMerge A) (fun (_ : ad) (m : Map A) => m) m)) match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end
+++++
rewrite (MapFold_distr_l (Map A) (Map A) (M0 A) (MapMerge A) bool false orb ad (in_dom A) (fun c:ad => refl_equal _) (in_dom_merge A)).
-----
Lemma in_dom_DMerge_1 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with | Some _ => true | _ => false end.
Proof.
unfold DMerge in |- *.
intros.
rewrite (MapFold_distr_l (Map A) (Map A) (M0 A) (MapMerge A) bool false orb ad (in_dom A) (fun c:ad => refl_equal _) (in_dom_merge A)).

*****
a : ad
m : Map (Map A)
A : Type
*****
eq (MapFold (Map A) bool false orb (fun (_ : ad) (y : Map A) => in_dom A a y) m) match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end
+++++
apply MapFold_orb.
-----
Lemma in_dom_DMerge_1 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = match MapSweep _ (fun (_:ad) (m0:Map A) => in_dom A a m0) m with | Some _ => true | _ => false end.
Proof.
unfold DMerge in |- *.
intros.
rewrite (MapFold_distr_l (Map A) (Map A) (M0 A) (MapMerge A) bool false orb ad (in_dom A) (fun c:ad => refl_equal _) (in_dom_merge A)).
apply MapFold_orb.

*****

*****

+++++
Qed.
-----
Lemma in_dom_DMerge_2 :\n   forall (m:Map (Map A)) (a:ad),\n     in_dom A a (DMerge m) = true ->\n     {b : ad & \n     {m0 : Map A | MapGet _ m b = Some m0 /\ in_dom A a m0 = true}}.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.

*****
A : Type
*****
forall (m : Map (Map A)) (a : ad) (_ : eq (in_dom A a (DMerge m)) true), sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
Proof.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.

*****
A : Type
*****
forall (m : Map (Map A)) (a : ad) (_ : eq (in_dom A a (DMerge m)) true), sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intros m a.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.

*****
a : ad
m : Map (Map A)
A : Type
*****
forall _ : eq (in_dom A a (DMerge m)) true, sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
rewrite in_dom_DMerge_1.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.

*****
a : ad
m : Map (Map A)
A : Type
*****
forall _ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true, sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).

*****
a : ad
m : Map (Map A)
A : Type
*****
forall (_ : sig (fun y : prod ad (Map A) => eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m) (Some y))) (_ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true), sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intro H.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.

*****
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
forall _ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true, sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
elim H.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.

*****
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
forall (x : prod ad (Map A)) (_ : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m) (Some x)) (_ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true), sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intro r.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.

*****
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
forall (_ : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m) (Some r)) (_ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true), sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
elim r.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.

*****
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
forall (a0 : ad) (b : Map A) (_ : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m) (Some (pair a0 b))) (_ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true), sigT (fun b0 : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b0) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intros b m0 H0.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.
intros b m0 H0.

*****
H0 : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some (pair b m0))
m0 : Map A
b : ad
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
forall _ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true, sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intro.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.
intros b m0 H0.
intro.

*****
H1 : eq\n match\n MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m\n with\n | Some _ => true\n | None => false\n end true
H0 : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some (pair b m0))
m0 : Map A
b : ad
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
split with b.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.
intros b m0 H0.
intro.
split with b.

*****
H1 : eq\n match\n MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m\n with\n | Some _ => true\n | None => false\n end true
H0 : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some (pair b m0))
m0 : Map A
b : ad
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true))
+++++
split with m0.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.
intros b m0 H0.
intro.
split with b.
split with m0.

*****
H1 : eq\n match\n MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m\n with\n | Some _ => true\n | None => false\n end true
H0 : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some (pair b m0))
m0 : Map A
b : ad
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)
+++++
split.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.
intros b m0 H0.
intro.
split with b.
split with m0.
split.

*****
H1 : eq\n match\n MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m\n with\n | Some _ => true\n | None => false\n end true
H0 : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some (pair b m0))
m0 : Map A
b : ad
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
eq (MapGet (Map A) m b) (Some m0)
+++++
exact (MapSweep_semantics_2 _ _ _ _ _ H0).
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
elim H.
intro r.
elim r.
intros b m0 H0.
intro.
split with b.
split with m0.
split.

*****
H1 : eq\n match\n MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m\n with\n | Some _ => true\n | None => false\n end true
H0 : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some (pair b m0))
m0 : Map A
b : ad
r : prod ad (Map A)
H : sig\n (fun y : prod ad (Map A) =>\n eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n (Some y))
a : ad
m : Map (Map A)
A : Type
*****
eq (in_dom A a m0) true
+++++
exact (MapSweep_semantics_1 _ _ _ _ _ H0).
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).

*****
a : ad
m : Map (Map A)
A : Type
*****
forall (_ : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m) None) (_ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true), sigT (fun b0 : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b0) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intro H.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.

*****
H : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n None
a : ad
m : Map (Map A)
A : Type
*****
forall _ : eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m with | Some _ => true | None => false end true, sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
rewrite H.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
rewrite H.

*****
H : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n None
a : ad
m : Map (Map A)
A : Type
*****
forall _ : eq false true, sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
intro.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).
intro H.
rewrite H.
intro.

*****
H0 : eq false true
H : eq (MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A a m0) m)\n None
a : ad
m : Map (Map A)
A : Type
*****
sigT (fun b : ad => sig (fun m0 : Map A => and (eq (MapGet (Map A) m b) (Some m0)) (eq (in_dom A a m0) true)))
+++++
discriminate H0.
-----
Lemma in_dom_DMerge_2 : forall (m:Map (Map A)) (a:ad), in_dom A a (DMerge m) = true -> {b : ad & {m0 : Map A | MapGet _ m b = Some m0 /\\ in_dom A a m0 = true}}.
Proof.
intros m a.
rewrite in_dom_DMerge_1.
elim (option_sum _ (MapSweep (Map A) (fun (_:ad) (m0:Map A) => in_dom A a m0) m)).

*****

*****

+++++
Qed.
-----
Lemma in_dom_DMerge_3 :\n   forall (m:Map (Map A)) (a b:ad) (m0:Map A),\n     MapGet _ m a = Some m0 ->\n     in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.

*****
A : Type
*****
forall (m : Map (Map A)) (a b : ad) (m0 : Map A) (_ : eq (MapGet (Map A) m a) (Some m0)) (_ : eq (in_dom A b m0) true), eq (in_dom A b (DMerge m)) true
+++++
Proof.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.

*****
A : Type
*****
forall (m : Map (Map A)) (a b : ad) (m0 : Map A) (_ : eq (MapGet (Map A) m a) (Some m0)) (_ : eq (in_dom A b m0) true), eq (in_dom A b (DMerge m)) true
+++++
intros m a b m0 H H0.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.

*****
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
eq (in_dom A b (DMerge m)) true
+++++
rewrite in_dom_DMerge_1.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.

*****
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A b m0) m with | Some _ => true | None => false end true
+++++
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).

*****
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
forall (x : ad) (_ : sig (fun y' : Map A => eq (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m) (Some (pair x y')))), eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A b m0) m with | Some _ => true | None => false end true
+++++
intros a' H1.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).
intros a' H1.

*****
H1 : sig\n (fun y' : Map A =>\n eq\n (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m)\n (Some (pair a' y')))
a' : ad
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A b m0) m with | Some _ => true | None => false end true
+++++
elim H1.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).
intros a' H1.
elim H1.

*****
H1 : sig\n (fun y' : Map A =>\n eq\n (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m)\n (Some (pair a' y')))
a' : ad
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
forall (x : Map A) (_ : eq (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m) (Some (pair a' x))), eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A b m0) m with | Some _ => true | None => false end true
+++++
intros m'0 H2.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).
intros a' H1.
elim H1.
intros m'0 H2.

*****
H2 : eq (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m)\n (Some (pair a' m'0))
m'0 : Map A
H1 : sig\n (fun y' : Map A =>\n eq\n (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m)\n (Some (pair a' y')))
a' : ad
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
eq match MapSweep (Map A) (fun (_ : ad) (m0 : Map A) => in_dom A b m0) m with | Some _ => true | None => false end true
+++++
rewrite H2.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).
intros a' H1.
elim H1.
intros m'0 H2.
rewrite H2.

*****
H2 : eq (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m)\n (Some (pair a' m'0))
m'0 : Map A
H1 : sig\n (fun y' : Map A =>\n eq\n (MapSweep (Map A) (fun (_ : ad) (m'0 : Map A) => in_dom A b m'0) m)\n (Some (pair a' y')))
a' : ad
H0 : eq (in_dom A b m0) true
H : eq (MapGet (Map A) m a) (Some m0)
m0 : Map A
a,b : ad
m : Map (Map A)
A : Type
*****
eq true true
+++++
reflexivity.
-----
Lemma in_dom_DMerge_3 : forall (m:Map (Map A)) (a b:ad) (m0:Map A), MapGet _ m a = Some m0 -> in_dom A b m0 = true -> in_dom A b (DMerge m) = true.
Proof.
intros m a b m0 H H0.
rewrite in_dom_DMerge_1.
elim (MapSweep_semantics_4 _ (fun (_:ad) (m'0:Map A) => in_dom A b m'0) _ _ _ H H0).
intros a' H1.
elim H1.
intros m'0 H2.
rewrite H2.
reflexivity.

*****

*****

+++++
Qed.
-----
End DMergeDef.
-----
